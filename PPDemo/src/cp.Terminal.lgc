[ ********************************************************************
[
[ cp.Terminal 
[
[ Master Options Control Console
[ MOCC
[
[ a command driven text terminal
[
[ ********************************************************************

#define cursor_row    v240
#define cursor_col    v241
#define cursor_char   v242
#define cursor_toggle v243
#define inputmode     v244
  #define IM_USERID    0 [ wait for userid
  #define IM_PASSWORD  1 [ wait for pw
  #define IM_CMDLINE   2 [ wait for commandline
  #define IM_ARGINPUT  3 [ wait for additional args/input
#define terminalfn    v245
  #define LINEFEED     1
  #define DELAY        2
  #define DELAY_LF     3
  #define ADDLINE      4
  #define ADDLINE_LF   5
  #define CLS          6
  #define DELAY_ADD    7
  #define NO_ACCESS    8
  #define SHOW_DIR     9
  #define CHKDSK_A    10
  #define CHKDSK_C    11
  #define FORMAT_A    12
  #define TYPE_PP     13
#define outputvar     v246
#define tmpCounter1   v247
#define tmpCounter2   v248
#define PWfunction    v249
  #define PW_LOGON     0
  #define PW_BADASS    1
  #define PW_CAISOCC   2
  #define PW_ERIDOCC   3
  #define PW_ESADOCC   4
  #define PW_ICAPOCC   5
  #define PW_OFROCC    6
  #define PW_RANDOCC   7
  #define PW_SUDO      8
#define vCurDir       v250
  #define C_ROOT    0 [ c:\
  #define C_USERS   1 [ c:\USERS\
  #define C_KW001   2 [ c:\USERS\KW001
  #define A_ROOT    3 [ a:
#define vShowDir      v251
  
#define cursorstate   f241
#define loggedon      f242
#define validmodule   f243
#define validPW       f244
#define tmpFlag       f245

#define input          s12
#define char           s13
#define output         s14
#define userid         s15
#define sCmd           s16
#define sTemp2         s17
#define sTemp3         s18

#define charmsg         m3
#define outputmsg       m4
#define promptmsg       m6

#define TOPROW         4
#define BTMROW        18
#define LEFTCOL        9
#define RIGHTCOL      48

[ room variable declarations

[ This room does not run the main agi loop; all input is handled
[ and responded within this logic. So no need to check for newRoom
[ flag.

[ load, draw and discard the picture resource for the current room
load.pic(currentRoom);
draw.pic(currentRoom);
discard.pic(currentRoom);

[ if a disk is inserted, show drive lever engaged
if (floppyInserted) {
  load.view(vw.TerminalArt);
  add.to.pic(vw.TerminalArt, 0, 1, 131, 95, 4, 4);
  discard.view(vw.TerminalArt);
}

[ extra functions for managing terminal commands
load.logics(lgc.TerminalFunctions);

[ no mouse
disable.item(mouse);

set.text.attribute(-1, 0);

[ display it
show.pic();

[ add return/cancel info
set.text.attribute(WHITE, BLACK);
display(22, 22, "Press <ESC> to return to control room");

[ set terminal colors (maybe use amber?)
set.text.attribute(GREEN, BLACK);

[ command input is not case sensitive
set.string(SET.CMPMODE, COMPARE_TEXT); [ set.cmpmode(mode);
:login
[ display welcome text
[                0123456789012345678901234567890123456789
display(5, 15,  "  *    *   *   ***    ****");
display(6, 15,  " * *   ** **  *   *  *");
display(7, 15,  "*****  * * *  *   *   ***");
display(8, 15,  "*   *  *   *  *   *      *");
display(9, 15,  "*   *  *   *   ***   ****");
display(11, 11, "AGI Mainframe Operating System v1.0");
display(12, 13, "  (c) 1986 Sierra Online, Inc.");
[display(14, 9, "(Shift-Ctrl-Enter to reboot)");
[ position cursor after userid prompt
display(16, 9, "userid: ");
cursor_row = 16; 
cursor_col = 17;
cursor_char = 1;
display.v(cursor_row, cursor_col, cursor_char);
inputmode = IM_USERID;

[ if first time drawing welcom text, need to fade in
if (newRoom) {
  block(FADE.IN, 0, FADECOUNT, BLACK); [ fade.in(BYVAR, DELAY, COLOR)
  reset(newRoom);
}

[skip prompt for userid/pw
goto(getKey);

:getInput
[ reset input line
input = "";
[ add prompt
work1 = &promptmsg;
display.v(cursor_row, cursor_col, work1);
++cursor_col;

[ main character input loop
:getKey
[ flush the keybuffer
lastChar = 0;

if (!have.key()) {
  [ delay 25 msec
  work1 = 25;
  cycle.time(o254, work1); 

  [ toggle the cursor every 200 msec
  ++cursor_toggle;
  if (cursor_toggle > 9) {
    cursor_toggle = 0;
    cursor_char *= -1;
    cursor_char += 3; [ this toggles cursor msg num between 1 and 2
    display.v(cursor_row, cursor_col, cursor_char);
  }
  
  [ check for a key
  goto(getKey);
}

:haveKey
[ make sure cursor gets hidden
if (cursor_char == 1) {
  cursor_char = 2;
  display.v(cursor_row, cursor_col, cursor_char);
}

[ if ESC
if (lastChar == 27) {
  [ restore default (inputline) attritubutes
  set.text.attribute(0, -1);
  
  [ fade out
  block(FADE.OUT, 0, FADECOUNT, BLACK); [ fade.out(BYVAR, DELAY, COLOR)
  
  [ clear return instruction row
  clear.lines(22, 22, BLACK);
  
  [ go back to terminal roonm
  new.room(rm.ControlRoom); [ ##LE001##
}

[ CTRL+SHIFT+ENTER for reboot
if (lastChar == 10) {
  block(GET.SHIFTSTATE, &work1, 0, 0); [ get.shiftstate(vSTATE)
  if (work1 == 3) { [  && inputmode == IM_CMDLINE) {
    if (inputmode != IM_CMDLINE) {
      terminalfn = LINEFEED;
      call(lgc.TerminalFunctions);
      terminalfn = LINEFEED;
      call(lgc.TerminalFunctions);
    }
    [ reboot
    :reboot
    output = "amos stop:all -f";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    tmpCounter2 = 7;
    :nextsys1
      tmpCounter1 = &output;
      block(SET.STRING.V, &tmpCounter1, &tmpCounter2, 0); [ set.string.v(vSTR, vMSG)
      terminalfn = ADDLINE;
      call(lgc.TerminalFunctions);
      [ pause for a bit
      random(3, 5, tmpCounter1);
      output = ".";
      :wait4
        terminalfn = DELAY_ADD;
        call(lgc.TerminalFunctions);
        --tmpCounter1;
      if (tmpCounter1 > 0) {
        goto(wait4);
      }
      output = " END OK";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      ++tmpCounter2;
    if (tmpCounter2 < 14) {
      goto(nextsys1);
    }
    output = "shutting down";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    [ pause for a bit
    tmpCounter1 = 2;
    output = ".";
    :wait1
      terminalfn = DELAY_ADD;
      call(lgc.TerminalFunctions);
      --tmpCounter1;
    if (tmpCounter1 > 0) {
      goto(wait1);
    }
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
    
    output = "rebooting.";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    [ pause for a bit
    tmpCounter1 = 3;
    output = ".";
    :wait2
      terminalfn = DELAY_ADD;
      call(lgc.TerminalFunctions);
      --tmpCounter1;
    if (tmpCounter1 > 0) {
      goto(wait2);
    }
    [ clear the screen
    terminalfn = CLS;
    call(lgc.TerminalFunctions);
    
    [ show BIOS
    [ (draw directly; no need for functions since positions are known)
    display(4, 10, "\x1E");
    display(5, 9,"\x1E \x1E   AMT Mainframe BIOS v1.44b");

    [ memory check
    display(7, 12, "memory check: 0MB");
    work1 = 1;
    :wait3
    display(7, 26, "%v46MB");
    ++work1;
    work2 = 50;
    cycle.time(o254, work2); [ delay(vDELAY)
    if (work1 < 129) {
      goto(wait3);
    }
    display(7, 32, "- OK");
    cursor_row = 9;
    cursor_col = LEFTCOL;
    output = "load mouse.drv -h -p:200";
    terminalfn = DELAY_ADD;
    call(lgc.TerminalFunctions);
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
    output = "amos.bat -q";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "amos init:all";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    tmpCounter2 = 7;
    :nextsys2
      tmpCounter1 = &output;
      block(SET.STRING.V, &tmpCounter1, &tmpCounter2, 0); [ set.string.v(vSTR, vMSG)
      terminalfn = ADDLINE;
      call(lgc.TerminalFunctions);
      [ pause for a bit
      tmpCounter1 = 4;
      output = ".";
      :wait5
        terminalfn = DELAY_ADD;
        call(lgc.TerminalFunctions);
        --tmpCounter1;
      if (tmpCounter1 > 0) {
        goto(wait5);
      }
      output = " INIT OK";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      ++tmpCounter2;
    if (tmpCounter2 < 14) {
      goto(nextsys2);
    }
    output = "amos load:all";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    tmpCounter1 = 3;
    :delay1
      terminalfn = DELAY_LF;
      call(lgc.TerminalFunctions);
      -- tmpCounter1;
    if (tmpCounter1 > 0) {
      goto(delay1);
    }
    output = "ERROR: corrupt master password file";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "subsystems not loaded";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "use backup passwords to load";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "individual subsystems";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "-- pause --";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    lastChar = 0;
    :wait6
    if (!have.key()) {
      goto(wait6);
    }
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
    output = "amos interface:cmdline";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    terminalfn = DELAY;
    call(lgc.TerminalFunctions);
    terminalfn = DELAY;
    call(lgc.TerminalFunctions);

    [ MOCC is now reset, errors are gone
    set(resetMOCC);
    [ clear the screen
    terminalfn = CLS;
    call(lgc.TerminalFunctions);
    [ need login credentials
    inputmode = IM_USERID;
    goto(login);
  }
}

[ if ENTER or CTRL+ENTER
if ((lastChar == 13 || lastChar == 10)) {
  [ advance the inputline BEFORE processing
  terminalfn = LINEFEED;
  call(lgc.TerminalFunctions);
    
  [ parse the input
  parse(input);
    
  [ take appropriate action based on command and input mode
  if (inputmode == IM_USERID) {
    [ userid entered; get password
    block(STR.COPY, &input, &userid, 0); [ str.copy(sINPUT, sRESULT)
    inputmode = IM_PASSWORD;
    output = "password: ";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    [ get more input (no prompt)
    input = "";
    goto(getKey);
  }
  
  if (inputmode == IM_PASSWORD) {
    if (PWfunction == PW_LOGON) {
      [ validate userid/password
      sCmd = "kw001";
      sTemp2 = "Temp123!";
      if (compare.strings(userid, sCmd)) {
        [ id is valid
        set(loggedon);
      }
      [ passwords are case sensitive
      set.string(SET.CMPMODE, COMPARE_BINARY); [ set.cmpmode(mode);
      if (!compare.strings(input, sTemp2)) {
        [ password is not valid
        reset(loggedon);
      }
      [ go back to case-insensitive compare
      set.string(SET.CMPMODE, COMPARE_TEXT); [ set.cmpmode(mode);
      [ if valid continue
      if (loggedon) {
        inputmode = IM_CMDLINE;
        output = "logged on as kw001";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        output = "access level: 1";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        terminalfn = LINEFEED;
        call(lgc.TerminalFunctions);
        inputmode = IM_CMDLINE;
        [ get more input
        goto(getInput);
      } else {
        inputmode = IM_USERID;
        output = "invalid userid and/or password";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        [ position cursor after userid prompt
        output = "userid: ";
        terminalfn = ADDLINE;
        call(lgc.TerminalFunctions);
        [ get input, no prompt
        input = "";
        goto(getKey);
      }
    }
    
    [ passwords are case sensitive
    set.string(SET.CMPMODE, COMPARE_BINARY); [ set.cmpmode(mode);
    [ check for sudo
    if (PWfunction == PW_SUDO) {
      [ never valid
      output = "invalid password";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      [ get more input
      inputmode = IM_CMDLINE;
      goto(getInput);
    }
    
    [ check for loading subsystem
    reset(validPW);
    if (PWfunction == PW_BADASS) {
      sCmd = "badassPW";
      if (compare.strings(input, sCmd)) {
        [ ok
        set(resetBaDASS);
        set(validPW);
      }
    }
    if (PWfunction == PW_CAISOCC) {
      sCmd = "caisoccPW";
      if (compare.strings(input, sCmd)) {
        [ ok
        set(enableCAISOCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_ERIDOCC) {
      sCmd = "eridoccPW";
      if (compare.strings(input, sCmd)) {
        [ ok
        set(enableERIDOCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_ESADOCC) {
      sCmd = "esadoccPW";
      if (compare.strings(input, sCmd)) {
        [ ok
        set(enableESADOCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_ICAPOCC) {
      sCmd = "icapoccPW";
      if (compare.strings(input, sCmd)) {
        [ ok
        set(enableICAPOCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_OFROCC) {
      sCmd = "ofroccPW";
      if (compare.strings(input, sCmd)) {
        [ ok
        set(enableOFROCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_RANDOCC) {
      sCmd = "randoccPW";
      if (compare.strings(input, sCmd)) {
        [ ok
        set(enableRANDOCC);
        set(validPW);
      }
    }
    [ go back to case-insensitive compare
    set.string(SET.CMPMODE, COMPARE_TEXT); [ set.cmpmode(mode);
    if (validPW) {
      output = "  loading module %s17...";
      terminalfn = ADDLINE;
      call(lgc.TerminalFunctions);
      terminalfn = DELAY;
      call(lgc.TerminalFunctions);
      output = " OK";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
    } else {
      [ not valid
      output = "invalid password";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
    }
    inputmode = IM_CMDLINE;
    [ get more input
    goto(getInput);
  }
[ TODO: add occasional error codes until reset
  if (inputmode == IM_CMDLINE) {
    [ convert input to lower case, trim it,
    block(STR.LOWER, &input, &input, 0); [ str.upper(sINPUT, sRESULT)
    work1 = 0;
    block(STR.TRIM, &input, &input, &work1); [ strTrim(sINPUT, sRESULT, vMODE)
    [ then extract the command (first word)
    work1 = 32;
    work2 = 0;
    block(INSTR, &input, &work1, &work2); [ instr(sINPUT, vCHAR, vPOS)
    if (work2 != -1) {
      block(STR.LEFT, &input, &sCmd, &work2); [ str.left(sINPUT, sRESULT, vLEN)
      [ remove cmd from input, and trim it
      block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
      work1 -= work2;
      block(STR.RIGHT, &input, &input, &work1); [ strRight(sINPUT, sRESULT, vCOUNT)
      work1 = 0;
      block(STR.TRIM, &input, &input, &work1); [ strTrim(sINPUT, sRESULT, vMODE)
    } else {
     block(STR.COPY, &input, &sCmd, 0); [ str.copy(sINPUT, sRESULT)
     input = "";
    }
    [ check ascii of first char to quick check for valid cmd
    block(CHAR2BYTE, &sCmd, &work1, 0); [ char2byte(sCHAR, vRESULT)
    if (work1 == 0) {
      goto(getInput);
    }
    if (work1 == 97) {
      goto(inputA);
    }
    if (work1 == 99) {
      goto(inputC);
    }
    if (work1 == 100) {
      goto(inputD);
    }
    if (work1 == 101) {
      goto(inputE);
    }
    if (work1 == 102) {
      goto(inputF);
    }
    if (work1 == 104) {
      goto(inputH);
    }
    if (work1 == 108) {
      goto(inputL);
    }
    if (work1 == 109) {
      goto(inputM);
    }
    if (work1 == 114) {
      goto(inputR);
    }
    if (work1 == 115) {
      goto(inputS);
    }
    if (work1 == 116) {
      goto(inputT);
    }
    if (work1 == 118) {
      goto(inputV);
    }
    [ anything else is an error
    :syntaxerror
    output = "syntax error";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    [ get more input
    goto(getInput);
    
    :inputA
    [ AMOS
    if (!said("amos", "rol")) {
      [ amos is only valid 'a' command
      goto(syntaxerror);
    }
    
    [ check for 'load:'
    work1 = 5;
    block(STR.LEFT, &input, &sCmd, &work1); [ str.left(sINPUT, sRESULT, vLEN)
    sTemp2 = "load:";
    if (compare.strings(sCmd, sTemp2)) {
      [ strip off module
      block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
      work1 -= 5;
      block(STR.RIGHT, &input, &sCmd, &work1); [ strRight(sINPUT, sRESULT, vCOUNT)
      work1 = 0;
      block(STR.TRIM, &sCmd, &sCmd, &work1); [ strTrim(sINPUT, sRESULT, vMODE)
      reset(validmodule);
      [ check for one of the seven subsystems
      sTemp2 = "badass";
      if (compare.strings(sCmd, sTemp2)) {
        [get BaDASS password
        PWfunction = PW_BADASS;
        set(validmodule);
        goto(checkmodule);
      }
      sTemp2 = "caisocc";
      if (compare.strings(sCmd, sTemp2)) {
        [get CAISOCC password
        PWfunction = PW_CAISOCC;
        set(validmodule);
        goto(checkmodule);
      }
      sTemp2 = "eridocc";
      if (compare.strings(sCmd, sTemp2)) {
        [get ERIDOCC password
        PWfunction = PW_ERIDOCC;
        set(validmodule);
        goto(checkmodule);
      }
      sTemp2 = "esadocc";
      if (compare.strings(sCmd, sTemp2)) {
        [get ESADOCC password
        PWfunction = PW_ESADOCC;
        goto(checkmodule);
        set(validmodule);
      }
      sTemp2 = "icapocc";
      if (compare.strings(sCmd, sTemp2)) {
        [get ICAPOCC password
        PWfunction = PW_ICAPOCC;
        goto(checkmodule);
        set(validmodule);
      }
      sTemp2 = "ofrocc";
      if (compare.strings(sCmd, sTemp2)) {
        [get OFROCC password
        PWfunction = PW_OFROCC;
        goto(checkmodule);
        set(validmodule);
      }
      sTemp2 = "randocc";
      if (compare.strings(sCmd, sTemp2)) {
        [get RANDOCC password
        PWfunction = PW_RANDOCC;
        set(validmodule);
      }
      
      :checkmodule
      if (validmodule) {
        inputmode = IM_PASSWORD;
        output = "password: ";
        terminalfn = ADDLINE;
        call(lgc.TerminalFunctions);
        [ get more input (no prompt)
        input = "";
        goto(getKey);
      } else {
        [ 'all' is valid but doesn't work
        sTemp2 = "all";
        if (compare.strings(sCmd, sTemp2)) {
          tmpCounter1 = 3;
          :delay2
            terminalfn = DELAY_LF;
            call(lgc.TerminalFunctions);
            -- tmpCounter1;
          if (tmpCounter1 > 0) {
            goto(delay2);
          }
          output = "ERROR: corrupt master password file";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          output = "subsystems not loaded";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          output = "use backup passwords to load";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          output = "individual subsystems";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          output = "-- pause --";
          terminalfn = ADDLINE;
          call(lgc.TerminalFunctions);
          lastChar = 0;
          :wait9
          if (!have.key()) {
            goto(wait9);
          }
          terminalfn = LINEFEED;
          call(lgc.TerminalFunctions);
        } else {
        [ invalid module
          output = "syntax error - ";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          output = "unknown module: %s16";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
        }
        goto(getInput);
      }
    }
    sTemp2 = "stop:";
    if (compare.strings(sCmd, sTemp2)) {
      [ not allowed
      terminalfn = NO_ACCESS;
      call(lgc.TerminalFunctions);
      goto(getInput);
    }
    sTemp2 = "init:";
    if (compare.strings(sCmd, sTemp2)) {
      [ not allowed
      terminalfn = NO_ACCESS;
      call(lgc.TerminalFunctions);
      goto(getInput);
    }
    [ if nothing matches, it's a syntax error
    goto(syntaxerror);
    
    :inputC
    [ CD/CHDIR
    reset(tmpFlag);
    sTemp2 = "cd";
    if (compare.strings(sCmd, sTemp2)) {
      [ same as chdir 
      goto(chdir);
    }
    sTemp2 = "chdir";
    if (compare.strings(sCmd, sTemp2)) {
      :chdir
      [ check parameter
      block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
      if (work1 == 0) {
        [ do nothing
        goto(getInput);
      }
      [ strip off trailing '\' if one is there
      work1 = 1;
      block(STR.RIGHT, &input, &sCmd, &work1); [ strRight(sINPUT, sRESULT, vCOUNT)
      block(CHAR2BYTE, &sCmd, &work1, 0); [ char2byte(sCHAR, vRESULT)
      if (work1 == 92) {
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        --work1;
        block(STR.LEFT, &input, &input, &work1); [ strRight(sINPUT, sRESULT, vCOUNT)
      }
      [ valid dir values from any dir:
      [ c:, c:\users, c:\users\kw001, a:
      sTemp2 = "c:";
      if (compare.strings(input, sTemp2)) {
        vCurDir = C_ROOT;
        output = "DIR --> C:\\\\";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      sTemp2 = "c:\\users";
      if (compare.strings(input, sTemp2)) {
        vCurDir = C_USERS;
        output = "DIR --> C:\\\\USERS";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      sTemp2 = "c:\\users\\kw001";
      if (compare.strings(input, sTemp2)) {
        vCurDir = C_KW001;
        output = "DIR --> A:\\\\USERS\\\\KW001";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      sTemp2 = "a:";
      if (compare.strings(input, sTemp2)) {
        if (!floppyInserted) {
          output = "Drive not ready";
        } else {
          if (!floppyFormatted) {
            output = "Disk read error";
          } else {
            vCurDir = A_ROOT;
            output = "DIR --> A:\\\\";
          }
        }
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }

      [ valid dir values from c:\
      [ users, users\kw001
      if (vCurDir == C_ROOT) {
        sTemp2 = "users";
        if (compare.strings(input, sTemp2)) {
          vCurDir = C_USERS;
          output = "DIR --> C:\\\\USERS";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
        sTemp2 = "users\\kw001";
        if (compare.strings(input, sTemp2)) {
          vCurDir = C_KW001;
          output = "DIR --> C:\\\\USERS\\\\KW001";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
      }
      
      [ valid dir values from c:\users:
      [ kw001
      if (vCurDir == C_USERS) {
        sTemp2 = "kw001";
        if (compare.strings(input, sTemp2)) {
          vCurDir = C_KW001;
          output = "DIR --> C:\\\\USERS\\\\KW001";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
      }
      [ any other directory is not allowed
      output = "ERROR: invalid or protected directory";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      goto(getInput);
    }
    
    [ CHKDSK
    sTemp2 = "chkdsk";
    if (compare.strings(sCmd, sTemp2)) {
      sTemp2 = "";
      if (compare.strings(input, sTemp2)) {
        output = "no drive specified";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
      } else {
        [ acceptable params a:, a, c:, c
        reset(tmpFlag);
        sTemp2 = "a";
        if (compare.strings(input, sTemp2)) {
          work1 = 0;
          set(tmpFlag);
        } else {
          sTemp2 = "a:";
          if (compare.strings(input, sTemp2)) {
            work1 = 0;
            set(tmpFlag);
          } else {
            sTemp2 = "c";
            if (compare.strings(input, sTemp2)) {
              work1 = 1;
              set(tmpFlag);
            } else {
              sTemp2 = "c:";
              if (compare.strings(input, sTemp2)) {
                work1 = 1;
                set(tmpFlag);
              }
            }
          }
        }
        if (tmpFlag) {
          if (work1 == 0) {
            [ a drive
            if (floppyInserted) {
              if (floppyFormatted) {
                terminalfn = CHKDSK_A;
                call(lgc.TerminalFunctions);
              } else {
                output = "Disk read error";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
              }
            } else {
              output = "Drive not ready";
              terminalfn = ADDLINE_LF;
              call(lgc.TerminalFunctions);
            } 
          } else {
            [ c drive
            terminalfn = CHKDSK_C;
            call(lgc.TerminalFunctions);
          }
        } else {
          output = "The specified drive is invalid";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
        }
      }
      goto(getInput);
    }
    
    [ CLS
    sTemp2 = "cls";
    if (compare.strings(sCmd, sTemp2)) {
      [ no parameters allowed
      block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
      if (work1 == 0) {
        terminalfn = CLS;
        call(lgc.TerminalFunctions);
        goto(getinput);      
      } else {
        goto(syntaxerror);
      }
    }
    
    [ COPY
    sTemp2 = "copy";
    if (compare.strings(sCmd, sTemp2)) {
      work1 = 32;
      work2 = 0;
      block(INSTR, &input, &work1, &work2); [ instr(sINPUT, vCHAR, vPOS)
      if (work2 != -1) {
        [ extract dest
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        work1 -= work2;
        block(STR.RIGHT, &input, &sTemp3, &work1); [ strRight(sINPUT, sRESULT, vCOUNT)
        work1 = 0;
        block(STR.TRIM, &sTemp3, &sTemp3, &work1); [ strTrim(sINPUT, sRESULT, vMODE)
        [ trim src
        block(STR.LEFT, &input, &input, &work2); [ str.left(sINPUT, sRESULT, vLEN)
      } else {
        [ no destination
        sTemp3 = "";
      }
      [ input = src; sTemp3 = dest
      [ only destination is a:
      sTemp2 = "a:";
      if (!compare.strings(sTemp2, sTemp3)) {
        [ dest not allowed
        output = "invalid or restricted destination";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }

      [ only in c:\users\kw001
      if (vCurDir == C_KW001) {
        [ only files pwrpack.zip and pwrpack.txt, *.*
        reset(tmpFlag);
        tmpCounter1 = 0;
        sTemp2 = "pwrpack.zip";
        if (compare.strings(sTemp2, input)) {
          set(tmpFlag);
          tmpCounter1 = 1;
          goto(chksource);
        }
        sTemp2 = "pwrpack.txt";
        if (compare.strings(sTemp2, input)) {
          set(tmpFlag);
          tmpCounter1 = 2;
          goto(chksource);
        }
        sTemp2 = "*.*";
        if (compare.strings(sTemp2, input)) {
          set(tmpFlag);
          tmpCounter1 = 3;
          goto(chksource);
        }
        sTemp2 = "pwrpack.*";
        if (compare.strings(sTemp2, input)) {
          set(tmpFlag);
          tmpCounter1 = 3;
          goto(chksource);
        }
        :chksource        
        if (tmpFlag) {
          [ is drive ready?
          if (!floppyInserted) {
            output = "drive a: not ready";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            goto(getInput);
          }
          [ is drive formatted?
          if (!floppyFormatted) {
            output = "disk error in drive a:";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            goto(getInput);
          }
          [ ok to copy!
          if ((tmpCounter1 == 1 || tmpCounter1 == 3)) {
            [ if file already there,
            if ((floppyfiles == 1 || floppyfiles == 3)) {
              output = "PWRPACK.TXT already exists on a:";
              terminalfn = ADDLINE_LF;
              call(lgc.TerminalFunctions);
              output = "overwrite? (y/n) ?";
              terminalfn = ADDLINE;
              call(lgc.TerminalFunctions);
              
              :getKeyCopy1
              lastChar = 0;
              if (!have.key()) {
                goto(getKeyCopy1);
              }
              if ((lastChar == 78 || lastChar == 110)) {
                output = "n";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
                goto(chkzip);
              }
              if ((lastChar == 89 || lastChar == 121)) {
                output = "y";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
              } else {
                goto(getKeyCopy1);
              }
             
            }
            output = "copying PWRPACK.TXT to a:  ";
            terminalfn = ADDLINE;
            call(lgc.TerminalFunctions);
            terminalfn = DELAY;
            call(lgc.TerminalFunctions);
            output = "done";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            block(BIT.OR, 0, &floppyfiles, 1); [ bit.or(BYVAL, VAR, MASK)
          }
          
          :chkzip
          if ((tmpCounter1 == 2 || tmpCounter1 == 3)) {
            [ if file already there,
            if ((floppyfiles == 2 || floppyfiles == 3)) {
              output = "PWRPACK.ZIP already exists on a:";
              terminalfn = ADDLINE_LF;
              call(lgc.TerminalFunctions);
              output = "overwrite? (y/n) ?";
              terminalfn = ADDLINE;
              call(lgc.TerminalFunctions);
              
              :getKeyCopy2
              lastChar = 0;
              if (!have.key()) {
                goto(getKeyCopy2);
              }
              if ((lastChar == 78 || lastChar == 110)) {
                output = "n";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
                goto(getInput);
              }
              if ((lastChar == 89 || lastChar == 121)) {
                output = "y";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
              } else {
                goto(getKeyCopy2);
              }
             
            }
            output = "copying PWRPACK.ZIP to a:  ";
            terminalfn = ADDLINE;
            call(lgc.TerminalFunctions);
            terminalfn = DELAY;
            call(lgc.TerminalFunctions);
            terminalfn = DELAY;
            call(lgc.TerminalFunctions);
            terminalfn = DELAY;
            call(lgc.TerminalFunctions);
            output = "done";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            block(BIT.OR, 0, &floppyfiles, 2); [ bit.or(BYVAL, VAR, MASK)
          }
        } else {
          [ not a valid source
          output = "destination directory is same as source";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
        }
        goto(getInput);
      } else {
        [ if in a:
        if (vCurDir == A_ROOT) {
          [ src=dest
          output = "destination directory is same as source";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
        } else {
          [ files in this directory are protrcted
          output = "copying not allowed -";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          output = "current directory is restricted";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
        }
        goto(getInput);
      }
    }
    
    [ no other 'c' commands
    goto(syntaxerror);
    
    :inputD
    [ DIR
    sTemp2 = "dir";
    if (compare.strings(sCmd, sTemp2)) {
      [ check parameter
      block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
      if (work1 == 0) {
        [ show current directory
        vShowDir = vCurDir;
      } else {
        [ strip off trailing '\' if one is there
        work1 = 1;
        block(STR.RIGHT, &input, &sCmd, &work1); [ strRight(sINPUT, sRESULT, vCOUNT)
        block(CHAR2BYTE, &sCmd, &work1, 0); [ char2byte(sCHAR, vRESULT)
        if (work1 == 92) {
          block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
          --work1;
          block(STR.LEFT, &input, &input, &work1); [ strRight(sINPUT, sRESULT, vCOUNT)
        }
        vShowDir = -1;
        [ valid dir values from any dir:
        [ c:, c:\users, c:\users\kw001, a:
        sTemp2 = "c:";
        if (compare.strings(input, sTemp2)) {
          vShowDir = C_ROOT;
        }
        sTemp2 = "c:\\users";
        if (compare.strings(input, sTemp2)) {
          vShowDir = C_USERS;
        }
        sTemp2 = "c:\\users\\kw001";
        if (compare.strings(input, sTemp2)) {
          vShowDir = C_KW001;
        }
        sTemp2 = "a:";
        if (compare.strings(input, sTemp2)) {
          if (!floppyInserted) {
            output = "Drive not ready";
            call(lgc.TerminalFunctions);
            goto(getInput);
          } else {
            if (!floppyFormatted) {
              output = "Disk read error";
              call(lgc.TerminalFunctions);
              goto(getInput);
            } else {
              vShowDir = A_ROOT;
            }
          }
        }
        
        
        [ valid dir values from c:\
        [ users, users\kw001
        if (vCurDir == C_ROOT && vShowDir != -1) {
          sTemp2 = "users";
          if (compare.strings(input, sTemp2)) {
            vShowDir = C_USERS;
          }
          sTemp2 = "users\\kw001";
          if (compare.strings(input, sTemp2)) {
            vShowDir = C_KW001;
          }
        }
        [ valid dir values from c:\users:
        [ kw001
        if (vCurDir == C_USERS && vShowDir != -1) {
          sTemp2 = "kw001";
          if (compare.strings(input, sTemp2)) {
            vShowDir = C_KW001;
          }
        }
      }
      if (vShowDir != -1) {
        terminalfn = SHOW_DIR;
      } else {
        [ any other directory is invalid
        output = "ERROR: invalid or protected directory";
        terminalfn = ADDLINE_LF;
      }
      call(lgc.TerminalFunctions);
      goto(getInput);
    }
    
    [ DEL/ERASE
    sTemp2 = "del";
    if (compare.strings(sTemp2, sCmd)) {
      :delfile
      [ never allowed
      terminalfn = NO_ACCESS;
      call(lgc.TerminalFunctions);
      goto(getInput);
    }
    [ no other 'd' commands
    goto(syntaxerror);
    
    :inputE
    [ ERASE
    sTemp2 = "erase";
    if (compare.strings(sTemp2, sCmd)) {
      [ same as 'del'
      goto(delfile);
    }
    
    [ EXIT
    sTemp2 = "exit";
    if (compare.strings(sTemp2, sCmd)) {
      goto(reboot);
    }
    [ no other 'e' commands
    goto(syntaxerror);
    
    :inputF
    [ FORMAT
    sTemp2 = "format";
    if (compare.strings(sCmd, sTemp2)) {
      sTemp2 = "";
      if (compare.strings(input, sTemp2)) {
        output = "no drive specified";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
      } else {
        [ acceptable params a, c, a:, c:
        reset(tmpFlag);
        sTemp2 = "a";
        if (compare.strings(input, sTemp2)) {
          work1 = 0;
          set(tmpFlag);
        } else {
          sTemp2 = "a:";
          if (compare.strings(input, sTemp2)) {
            work1 = 0;
            set(tmpFlag);
          } else {
            sTemp2 = "c";
            if (compare.strings(input, sTemp2)) {
              work1 = 1;
              set(tmpFlag);
            } else {
              sTemp2 = "c:";
              if (compare.strings(input, sTemp2)) {
                work1 = 1;
                set(tmpFlag);
              }
            }
          }
        }
        if (tmpFlag) {
          if (work1 == 0) {
            [ a: drive
            if (floppyInserted) {
              if (floppyFormatted) {
                [ ask to overwrite
                output = "Drive A is already formatted.";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
                output = "Re-formatting will erase entire";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
                output = "disk contents. Continue? (y/n)?";
                terminalfn = ADDLINE;
                call(lgc.TerminalFunctions);
                :getKeyFormat
                lastChar = 0;
                if (!have.key()) {
                  goto(getKeyFormat);
                }
                if ((lastChar == 78 || lastChar == 110)) {
                  output = "n";
                  terminalfn = ADDLINE_LF;
                  call(lgc.TerminalFunctions);
                  goto(getInput);
                }
                if ((lastChar == 89 || lastChar == 121)) {
                  output = "y";
                  terminalfn = ADDLINE_LF;
                  call(lgc.TerminalFunctions);
                } else {
                  goto(getKeyFormat);
                }
              }
              terminalfn = FORMAT_A;
              call(lgc.TerminalFunctions);
              set(floppyFormatted);
              goto(getInput);
            } else {
              output = "Drive not ready";
              terminalfn = ADDLINE_LF;
              call(lgc.TerminalFunctions);
            } 
          } else {
            [ c drive
            output = "access denied";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
          }
        } else {
          output = "The specified drive is invalid";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
        }
      }
      goto(getInput);
    }
    [ no other 'f' commands
    goto(syntaxerror);
    
    :inputH
    [ HELP 
    if (said("help")) {
      [ show help lines
      output = "valid commands:";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "AMOS       Provides access to AMOS sub- ";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "           systems and configuration";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "CLS        Clears the screen.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "CD/CHDIR   Changes the current";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "           directory.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "CHKDSK     Checks a disk and displays a";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "           status report";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "DIR        Displays a list of files in ";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "           a directory.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "COPY       Copies files to another";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "           location.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "DEL/ERASE  Deletes files.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
       output = "-- pause --";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      lastChar = 0;
      :wait7
      if (!have.key()) {
        goto(wait7);
      }
      output = "EXIT       Quits and restarts AMOS ";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "FORMAT     Formats a disk.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "HELP       Displays a list of AMOS ";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "           commands.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "LOGOFF     Logs a user off AMOS.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "MD/MKDIR   Creates a directory.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "RD/RMDIR   Removes a directory.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "REN/RENAME Renames a file or files.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "SUDO       Runs AMOS commands with admin";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "           privileges. ";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "TYPE       Displays the contents of a";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "           text file.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "VER        Displays AMOS version.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
       output = "-- pause --";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      lastChar = 0;
      :wait8
      if (!have.key()) {
        goto(wait8);
      }
      output = "VOL        Displays a disk volume label";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "           and serial number.";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
    goto(getInput);
    }
    [ no other 'h' commands
    goto(syntaxerror);
    
    :inputL
    [ LOGOFF
    if (said("logoff")) {
      output = "signing off...";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      terminalfn = DELAY;
      call(lgc.TerminalFunctions);
      [ clear the screen
      terminalfn = CLS;
      call(lgc.TerminalFunctions);
      [ jump to login code
      goto(login);
    }
    [ no other 'l' commands
    goto(syntaxerror);
    
    :inputM
    [ MD/MKDIR
    sTemp2 = "mkdir";
    if (compare.strings(sTemp2, sCmd)) {
      :mkdir
      [ never allowed
      terminalfn = NO_ACCESS;
      call(lgc.TerminalFunctions);
      goto(getInput);
    }
    sTemp2 = "md";
    if (compare.strings(sTemp2, sCmd)) {
      [ same as mkdid
      goto(mkdir);
    }
    [ no other 'm' commands
    goto(syntaxerror);
    
    :inputR
    [ RD/RMDIR
    sTemp2 = "rmdir";
    if (compare.strings(sTemp2, sCmd)) {
      :rmdir
      [ never allowed
      terminalfn = NO_ACCESS;
      call(lgc.TerminalFunctions);
      goto(getInput);
    }

    sTemp2 = "rd";
    if (compare.strings(sTemp2, sCmd)) {
      [ same as rmdir
      goto(rmdir);
    }
    
    [ REN/RENAME
    sTemp2 = "rename";
    if (compare.strings(sTemp2, sCmd)) {
      :rename
      [ never allowed
      terminalfn = NO_ACCESS;
      call(lgc.TerminalFunctions);
      goto(getInput);
    }

    sTemp2 = "ren";
    if (compare.strings(sTemp2, sCmd)) {
      [ same as rename
      goto(rename);
    }
    [ no other 'r' commands
    goto(syntaxerror);
    
    :inputS
    [ SUDO
    sTemp2 = "sudo";
    if (compare.strings(sTemp2, sCmd)) {
      [ should always be another command
      block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
      if (work1 == 0) {
        output = "no command specified";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        goto(getInput);
      } else {
        [ get an admin password 
        [ (which will never work)
        inputmode = IM_PASSWORD;
        PWfunction = PW_SUDO;
        output = "admin password: ";
        terminalfn = ADDLINE;
        call(lgc.Terminalfunctions);
        [ get more input (no prompt)
        input = "";
        goto(getKey);
      }
    }
    [ no other 's' commands
    goto(syntaxerror);
    
    :inputT
    [ TYPE
    sTemp2 = "type";
    if (compare.strings(sTemp2, sCmd)) {
      sTemp2 = "";
      if (compare.strings(input, sTemp2)) {
        output = "no file specified";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        goto(getInput);
      }
      [ only valid file is PWRPACK.TXT in
      [ c:\users\kw001 or a:
      sTemp2 = "pwrpack.txt";
      if (compare.strings(input, sTemp2) && 
         (vCurDir == C_KW001 || vCurDir == A_ROOT)) {
        terminalfn = TYPE_PP;
        call(lgc.Terminalfunctions);
      } else {
        output = "%s12 is not a text file";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
      }
      goto(getInput);
    }
    [ no other 't' commands
    goto(syntaxerror);
    
    :inputV
    [ VER
    sTemp2 = "ver";
    if (compare.strings(sTemp2, sCmd)) {
      output = "AGI Mainframe Operating System v1.0";
      terminalfn = ADDLINE_LF;
      call(lgc.Terminalfunctions);
      output = "Build 244, 08/06/89";
      terminalfn = ADDLINE_LF;
      call(lgc.Terminalfunctions);
      terminalfn = LINEFEED;
      call(lgc.Terminalfunctions);
      output = "Power Pack module versions:";
      terminalfn = ADDLINE_LF;
      call(lgc.Terminalfunctions);
      output = "  CAISOCC    1.22a";
      terminalfn = ADDLINE_LF;
      call(lgc.Terminalfunctions);
      output = "  ERIDOCC    1.04";
      terminalfn = ADDLINE_LF;
      call(lgc.Terminalfunctions);
      output = "  ESADOCC    2.22";
      terminalfn = ADDLINE_LF;
      call(lgc.Terminalfunctions);
      output = "  ICAPOCC    1.10";
      terminalfn = ADDLINE_LF;
      call(lgc.Terminalfunctions);
      output = "  OFROCC     1.01";
      terminalfn = ADDLINE_LF;
      call(lgc.Terminalfunctions);
      output = "  RANDOCC    2.00";
      terminalfn = ADDLINE_LF;
      call(lgc.Terminalfunctions);
      goto(getInput);
    }
    
    [ VOL
    sTemp2 = "vol";
    if (compare.strings(sTemp2, sCmd)) {
      sTemp2 = "";
      if (compare.strings(input, sTemp2)) {
        output = "no drive specified";
      } else {
        [ acceptable params a:, a, c:, c
        reset(tmpFlag);
        sTemp2 = "a";
        if (compare.strings(input, sTemp2)) {
          work1 = 0;
          set(tmpFlag);
        } else {
          sTemp2 = "a:";
          if (compare.strings(input, sTemp2)) {
            work1 = 0;
            set(tmpFlag);
          } else {
            sTemp2 = "c";
            if (compare.strings(input, sTemp2)) {
              work1 = 1;
              set(tmpFlag);
            } else {
              sTemp2 = "c:";
              if (compare.strings(input, sTemp2)) {
                work1 = 1;
                set(tmpFlag);
              }
            }
          }
        }
        if (tmpFlag) {
          if (work1 == 0) {
            [ a drive
            if (floppyInserted) {
              if (floppyFormatted) {
                output = "Volume in drive a is %s5";
              } else {
                output = "Disk read error";
              }
            } else {
              output = "Drive not ready";
            } 
          } else {
            [ c drive
            output = "Volume in drive a is AMOSDISK";
          }
        } else {
          output = "The specified drive is invalid";
        }
      }
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      goto(getInput);
    }
    [ no other 'v' commands
    goto(syntaxerror);
  }
  
  [ args/extra input
  if (inputmode == IM_ARGINPUT) {
    [ tbd
    output = "accept input";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
      
    [ get more input
    goto(getInput);
  }
}

[ check for backspace
if (lastChar == 8) {
  [ get input length
  block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
  [ if anything on the input line, backspace is allowed
  if (work1 > 0) {
    [ if not at left edge
    if (cursor_col > LEFTCOL) {
      [ back up one space
      --cursor_col;
    } else {
      [ if at left edge, go up one row to right edge
      --cursor_row;
      cursor_col = RIGHTCOL;
    }
    [ remove char from display (backspace char will erase it)
    display.v(cursor_row, cursor_col, cursor_char);
    
    [ remove the last char from the input line
    --work1;
    block(STR.LEFT, &input, &input, &work1); [ str.left(sINPUT, sRESULT, vLEN);
  }
} else {
  [ if any other char, add it to input
  block(BYTE2CHAR, &char, &lastChar, 0); [ byte2char(sRESULT, vCHAR);
  block(STR.CONCAT, &input, &char, 0); [ sINPUT, sADD);
  [ if in password mode, display an asterisk
  if (inputmode == IM_PASSWORD) {
    work1 = &m5;
  } else {
    if (lastChar == 92) {
      work1 = &m14;
    } else {
      work1 = &charmsg;
    }
  }
  display.v(cursor_row, cursor_col, work1);
  
  [ advance cursor
  ++cursor_col;
  if (cursor_col > RIGHTCOL) {
    [ advance the inputline
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
  }
}
[ then get next keypress
goto(getKey);



[*****
:exit              [  test for leaving the room
[*****

[ add exit checks here (or use layout editor)
return();


[ **************************************
[ DECLARED MESSAGES
[ **************************************
#message 1 "_"
#message 2 " "
#message 3 "%s13"
#message 4 "%s14"
#message 5 "*"
#message 6 ">"
#message 7 "BaDASS"
#message 8 "caisocc"
#message 9 "eridocc"
#message 10 "esadocc"
#message 11 "icapocc"
#message 12 "ofrocc"
#message 13 "randocc"
#message 14 "\\\\"