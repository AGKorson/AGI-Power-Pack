[ ********************************************************************
[
[ cp.Terminal 
[
[ Master Options Control Console
[
[ a command driven text terminal
[
[ ********************************************************************

#define cursor_row    v240
#define cursor_col    v241
#define cursor_char   v242
#define cursor_toggle v243

#define cursorstate   f241

#define input   s12
#define char    s13

#define charmsg  m3

#define toprow         5
#define btmrow        16
#define leftcol       11
#define rightcol      46

[ room variable declarations

[ This room does not run the main agi loop; all input is handled
[ and responded within this logic. So no need to check for newRoom
[ flag.

[ this is the first cycle through this room
[ load, draw and discard the picture resource for the current room
[ do basic room initialization

load.pic(currentRoom);
draw.pic(currentRoom);
discard.pic(currentRoom);

load.logics(lgc.TerminalFunctions);

[ no mouse
disable.item(mouse);

set.text.attribute(-1, 0);

[ display it
show.pic();

[ add return/cancel info
set.text.attribute(WHITE, BLACK);
display(22, 22, "Press <ESC> to return to control room");

[ set terminal colors (maybe use amber?)
set.text.attribute(GREEN, BLACK);
block(FADE.IN, 0, FADECOUNT, BLACK); [ fade.in(BYVAR, DELAY, COLOR)

[ position cursor at first line of virtual screen, at right edge
cursor_row = toprow;
cursor_col = leftcol;
cursor_char = 1;
display.v(cursor_row, cursor_col, cursor_char);

[ reset input line
input = "";

[ main input loop
:getKey
[ flush the keybuffer
lastChar = 0;

if (!have.key()) {
  [ delay 25 msec
  work1 = 25;
  cycle.time(o254, work1); 

  [ toggle the cursor every 200 msec
  ++cursor_toggle;
  if (cursor_toggle > 9) {
    cursor_toggle = 0;
    cursor_char *= -1;
    cursor_char += 3; [ this toggles cursor msg num between 1 and 2
    display.v(cursor_row, cursor_col, cursor_char);
  }
  
  [ check for a key
  goto(getKey);
}

:havekey
[[ DEBUG: display the key value
[display(24, 1, "%v19   ");

[ make sure cursor gets hidden
if (cursor_char == 1) {
  cursor_char = 2;
  display.v(cursor_row, cursor_col, cursor_char);
}

[ if ESC
if (lastChar == 27) {
  [ restore default (inputline) attritubutes
  set.text.attribute(0, -1);
  
  [ fade out
  block(FADE.OUT, 0, FADECOUNT, BLACK); [ fade.out(BYVAR, DELAY, COLOR)
  
  [ clear return instruction row
  clear.lines(22, 22, BLACK);
  
  [ go back to terminal roonm
  new.room(rm.ControlRoom); [ ##LE001##
}
  

[ if ENTER or CTRL+ENTER
if ((lastChar == 13 || lastChar == 10)) {
  [ advance the inputline BEFORE processing
  work1 = 1;
  call(lgc.TerminalFunctions);
    
  [ parse the input
  parse(input);

  [ deal with input
  if (said("help")) {
    [ show some help lines
    work1 = 5;
    display.v(cursor_row, cursor_col, work1);
    [ linefeed
    work1 = 1;
    call(lgc.TerminalFunctions);
    work1 = 6;
    display.v(cursor_row, cursor_col, work1);
    [ linefeed
    work1 = 1;
    call(lgc.TerminalFunctions);
  }
  
  if (said("open", "door")) {
    set(resetBaDASS);
#message 24 "done"
    work1 = &m24;
    display.v(cursor_row, cursor_col, work1);
    work1 = 1;
    call(lgc.TerminalFunctions);
  }
  
#message 20 "  terminating process..."
#message 21 "  loading module %w2..."
#message 22 "  initializing..."
#message 23 "OK"

  if (said("restart", "anyword")) {
    work1 = &m20;
    display.v(cursor_row, cursor_col, work1);
    work1 = 3;
    call(lgc.TerminalFunctions);
    work1 = &m21;
    display.v(cursor_row, cursor_col, work1);
    work1 = 3;
    call(lgc.TerminalFunctions);
    work1 = &m22;
    display.v(cursor_row, cursor_col, work1);
    work1 = 2;
    call(lgc.TerminalFunctions);
    work1 = &m23;
    work2 = cursor_col;
    work2 += 18;
    display.v(cursor_row, work2, work1);
    work1 = 1;
    call(lgc.TerminalFunctions);
    reset(haveMatch);  
    if (said("restart", "caisocc")) {
      set(enableCAISOCC);
    }
    if (said("restart", "randocc")) {
      set(enableRANDOCC);
    }
    if (said("restart", "icapocc")) {
      set(enableICAPOCC);
    }
    if (said("restart", "esadocc")) {
      set(enableESADOCC);
    }
    if (said("restart", "ofrocc")) {
      set(enableOFROCC);
    }
    if (said("restart", "eridocc")) {
      set(enableERIDOCC);
    }
  }
    
  [ clear input
  input = "";

  [ if input was processed, get more input
  if (haveMatch) {
    goto(getKey);
  }
  
  [ anything else is not acknowledged
display(24, 0, "%w1, %w2, %w3, %w4");  
  [ display syntax error message
  work1 = 4;
  display.v(cursor_row, cursor_col, work1);
  [ linefeed
  work1 = 1;
  call(lgc.TerminalFunctions);
  
  [ get more input
  goto(getKey);
}

[ backspace
if (lastChar == 8) {
  if (cursor_col > leftcol) {
    --cursor_col;
    display.v(cursor_row, cursor_col, cursor_char);
    work1 = cursor_col;
    work1 -= leftcol;
    [ remove the last char from the input line
    block(STR.LEFT, &input, &input, &work1); [ str.left(sINPUT, sRESULT, vLEN);
  }
  goto(getKey);
}

[ if any other char, add it to screen
block(BYTE2CHAR, &char, &lastChar, 0); [ byte2char(sRESULT, vCHAR);
work1 = &charmsg;
display.v(cursor_row, cursor_col, work1);

[ add it to input
block(STR.CONCAT, &input, &char, 0); [ sINPUT, sADD);

[ advance cursor
++cursor_col;
if (cursor_col >= rightcol) {
  [ advance the inputline
  work1 = 1;
  call(lgc.TerminalFunctions);
}
[ then get more input
goto(getKey);



[*****
:exit              [  test for leaving the room
[*****

[ add exit checks here (or use layout editor)
return();

[*****
[ messages         [  declared messages go here
[*****
#message 1 "_"
#message 2 " "
#message 3 "%s13"
#message 4 "syntax error"
#message 5 "command list:"
#message 6 "  quit"
#message 60 "exiting..."