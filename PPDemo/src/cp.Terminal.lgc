[*********************************************************************
[
[ cp.Terminal 
[
[ Master Options Control Console
[
[ A simple text terminal that controls all other consoles. MOCC starts
[ out corrupted. Commands will randomly fail until it gets reset.
[ Only one account (kw002) is accessible. Password is on the memo 
[ found on the printer in the office.
[ After resetting, all six consoles, and the security system need to
[ be restarted; passwords to start them are hidden in various places
[ in the two side rooms.
[
[ The source code files for the Power Pack are located in kw001 user
[ drive. Player has to find a disk, format it, then copy the files to
[ the disk in order to win.
[
[ The MOCC simulates an operating system by providing a bunch of DOS
[ commands. Most don't do anything real. Valic commands include:
[   AMOS       CLS        CD         CHDIR   
[   CHKDSK     DIR        COPY       DEL
[   ERASE      EXIT       FORMAT     HELP
[   LOGOFF     MD         MKDIR      RD
[   RMDIR      REN        RENAME     SUDO
[   TYPE       VER        VOL
[*********************************************************************

[ power pack support
#include "powerpack.txt"

[***************************************
[ LOCAL DEFINES
[***************************************
#define cursor_row    v240
#define cursor_col    v241
#define cursor_char   v242
#define cursor_toggle v243
#define inputmode     v244
  #define IM_USERID    0 [ wait for userid
  #define IM_PASSWORD  1 [ wait for pw
  #define IM_CMDLINE   2 [ wait for commandline
  #define IM_ARGINPUT  3 [ wait for additional args/input
#define terminalfn    v245
  #define LINEFEED     1
  #define DELAY        2
  #define DELAY_LF     3
  #define ADDLINE      4
  #define ADDLINE_LF   5
  #define CLS          6
  #define DELAY_ADD    7
  #define NO_ACCESS    8
  #define SHOW_DIR     9
  #define CHKDSK_A    10
  #define CHKDSK_C    11
  #define FORMAT_A    12
  #define TYPE_PP     13
  #define SHOW_HELP   14
#define outputvar     v246
#define tmpCounter1   v247
#define tmpCounter2   v248
#define PWfunction    v249
  #define PW_LOGON     0
  #define PW_BADASS    1
  #define PW_CAISOCC   2
  #define PW_ERIDOCC   3
  #define PW_ESADOCC   4
  #define PW_ICAPOCC   5
  #define PW_OFROCC    6
  #define PW_RANDOCC   7
  #define PW_SUDO      8
  #define PW_CHANGE    9
#define vCurDir       v250
  #define C_ROOT    0 [ c:\
  #define C_USERS   1 [ c:\USERS\
  #define C_KW002   2 [ c:\USERS\KW002
  #define A_ROOT    3 [ a:
#define vShowDir      v251
  
#define cursorstate   f241
#define loggedon      f242
#define validmodule   f243
#define validPW       f244
#define tmpFlag       f245
#define defaultPW     f246

#define input          s12
#define char           s13
#define output         s14
#define userid         s15
#define sCmd           s16
#define sTemp2         s17
#define sTemp3         s18

#define charmsg         m3
#define outputmsg       m4
#define promptmsg       m6

#define TOPROW         4
#define BTMROW        18
#define LEFTCOL        9
#define RIGHTCOL      48

[***************************************
[ MAIN CODE BLOCK 
[***************************************

[ This room does not run the main agi loop; all input is handled
[ and responded within this logic. So no need to check for newRoom
[ flag.

[ load, draw and discard the picture resource for the current room
load.pic(currentRoom);
draw.pic(currentRoom);
discard.pic(currentRoom);

[ if a disk is inserted, show drive lever engaged
if (floppyInserted) {
  load.view(vw.TerminalArt);
  add.to.pic(vw.TerminalArt, 0, 1, 131, 95, 4, 4);
  discard.view(vw.TerminalArt);
}

[ check password to see if it's been changed
set.string(SET.CMPMODE, COMPARE_BINARY); [ set.cmpmode(MODE)
sTemp2 = "Temp123!";
if (compare.strings(sTemp2, kwpassword)) {
  set(defaultPW);
} else {
  reset(defaultPW);
}

[ extra functions for managing terminal commands
load.logics(lgc.TerminalFunctions);

[ no mouse
disable.item(mouse);

set.text.attribute(PUSH.ATTRIBUTES, 0); [ push.attributes()

[ display picture
show.pic();

[ add return/cancel info
set.text.attribute(WHITE, BLACK);
display(22, 22, "Press <ESC> to return to control room");

[ set terminal colors
set.text.attribute(GREEN, BLACK);

[ command input is not case sensitive
set.string(SET.CMPMODE, COMPARE_TEXT); [ set.cmpmode(MODE)
:login
[ display welcome text
[ if not restarted, include a few glitches
if (resetMOCC) {
[                          0123456789012345678901234567890123456789
  display(5, 15, m22);  [ "  *    *   *   ***    ****"
  display(6, 15, m23);  [ " * *   ** **  *   *  *"
  display(7, 15, m24);  [ "*****  * * *  *   *   ***"
  display(8, 15, m25);  [ "*   *  *   *  *   *      *"
  display(9, 15, m26);  [ "*   *  *   *   ***   ****"
  display(11, 11, m27); [ "AGI Mainframe Operating System v1.0"
  display(12, 13, m28); [ "  (c) 1986 Sierra Online, Inc."
} else {
  display(5, 15, m15);  [ "  *    *   *   **\x08    ****"
  display(6, 15, m16);  [ " * *  œ** **  *   *  *"
  display(7, 15, m17);  [ "*****  * * *  *   î   ***"
  display(8, 15, m18);  [ "„  *  *   *  *   *      *"
  display(9, 15, m19);  [ "*   *  *  #*   ***   **±*"
  display(11, 11, m20); [ "AGI Mainframe Operating S?stem v1.0"
  display(12, 13, m21); [ "  (c) 1«86 Sierra Online, Inc."
}

[ if a major holiday, add it
block(GET.DATE, &work1, &work2, &work3); [ get.date(vYEAR, vMONTH, vDAY)
display(14, 9, "%v47|2/%v48|2/20%v46 ");
if (work2 == 1 && work3 == 1) {
  display(15, 9, "Happy New Year 20%v46!");
}
if (work2 == 12 && work3 == 25) {
  display(15, 9, "Merry Christmas!");
}
if (work2 == 7 && work3 == 4) {
  display(15, 9, "Happy Independence Day!");
}
if (work2 == 5 && work3 == 6) {
  display(15, 9, "The Sierra Network rocks!");
}
block(GET.TIME, &work1, &work2, &work3); [ get.time(vHOUR, vMINUTE, vSECOND)
if (work1 > 11) {
  sTemp2 = "PM";
  work1 -= 12;
} else {
  sTemp2 = "AM";
}
if (work1 == 0) {
  work1 = 12;
}
display(14, 20, "%v46|2:%v47|2:%v48|2 %s17");

[ position cursor after userid prompt
display(17, 9, "userid: ");
cursor_row = 17; 
cursor_col = 17;
cursor_char = 1;
display.v(cursor_row, cursor_col, cursor_char);
inputmode = IM_USERID;
input = "";

[ if first time drawing welcome text, need to fade in
if (newRoom) {
  block(FADE.IN, BYNUM, FADECOUNT, BLACK); [ fade.in(FN_MODE, DELAY, COLOR)
  reset(newRoom);
}

[skip prompt for userid/pw
goto(getKey);

:getInput
[ reset input line
input = "";
[ add prompt
work1 = &promptmsg;
display.v(cursor_row, cursor_col, work1);
++cursor_col;

[ main character input loop
:getKey
[ flush the keybuffer
lastChar = 0;

if (!have.key()) {
  [ delay 25 msec
  work1 = 25;
  cycle.time(o254, work1); 

  [ toggle the cursor every 200 msec
  ++cursor_toggle;
  if (cursor_toggle > 9) {
    cursor_toggle = 0;
    cursor_char *= -1;
    cursor_char += 3; [ this toggles cursor msg num between 1 and 2
    display.v(cursor_row, cursor_col, cursor_char);
  }
  
  [ check for a key
  goto(getKey);
}

:haveKey
[ make sure cursor gets hidden
if (cursor_char == 1) {
  cursor_char = 2;
  display.v(cursor_row, cursor_col, cursor_char);
}

[ if ESC
if (lastChar == 27) {
  [ restore default (inputline) attritubutes
  set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
  
  [ fade out
  block(FADE.OUT, BYNUM, FADECOUNT, BLACK); [ fade.out(FN_MODE, DELAY, COLOR)
  
  [ clear return instruction row
  clear.lines(22, 22, BLACK);
  
  [ go back to terminal roonm
  new.room(rm.ControlRoom); [ ##LE001##
}

[ CTRL+SHIFT+ENTER for reboot
if (lastChar == 10) {
  block(GET.SHIFTSTATE, &work1, 0, 0); [ get.shiftstate(vSTATE)
  if (work1 == 3) {
    if (inputmode != IM_CMDLINE) {
      terminalfn = LINEFEED;
      call(lgc.TerminalFunctions);
      terminalfn = LINEFEED;
      call(lgc.TerminalFunctions);
    }
    [ reboot
    :reboot
    output = "amos stop:all -f";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    tmpCounter2 = 7;
    :nextsys1
      tmpCounter1 = &output;
      block(SET.STRING.V, &tmpCounter1, &tmpCounter2, 0); [ set.string.v(vSTR, vMSG)
      terminalfn = ADDLINE;
      call(lgc.TerminalFunctions);
      [ pause for a bit
      random(3, 5, tmpCounter1);
      output = ".";
      :wait4
        terminalfn = DELAY_ADD;
        call(lgc.TerminalFunctions);
        --tmpCounter1;
      if (tmpCounter1 > 0) {
        goto(wait4);
      }
      output = " END OK";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      ++tmpCounter2;
    if (tmpCounter2 < 14) {
      goto(nextsys1);
    }
    output = "shutting down";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    [ pause for a bit
    tmpCounter1 = 2;
    output = ".";
    :wait1
      terminalfn = DELAY_ADD;
      call(lgc.TerminalFunctions);
      --tmpCounter1;
    if (tmpCounter1 > 0) {
      goto(wait1);
    }
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
    
    output = "rebooting.";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    [ pause for a bit
    tmpCounter1 = 3;
    output = ".";
    :wait2
      terminalfn = DELAY_ADD;
      call(lgc.TerminalFunctions);
      --tmpCounter1;
    if (tmpCounter1 > 0) {
      goto(wait2);
    }
    [ clear the screen
    terminalfn = CLS;
    call(lgc.TerminalFunctions);
    
    [ show BIOS
    [ (draw directly; no need for functions since positions are known)
    display(4, 10, "\x1E");
    display(5, 9,"\x1E \x1E   AMT Mainframe BIOS v1.44b");

    [ memory check
    display(7, 12, "memory check: 0MB");
    work1 = 1;
    :wait3
    display(7, 26, "%v46MB");
    ++work1;
    work2 = 50;
    cycle.time(o254, work2); [ delay(vDELAY)
    if (work1 < 129) {
      goto(wait3);
    }
    display(7, 32, "- OK");
    cursor_row = 9;
    cursor_col = LEFTCOL;
    output = "load mouse.drv -h -p:200";
    terminalfn = DELAY_ADD;
    call(lgc.TerminalFunctions);
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
    output = "amos.bat -q";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "amos init:all";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    tmpCounter2 = 7;
    :nextsys2
      tmpCounter1 = &output;
      block(SET.STRING.V, &tmpCounter1, &tmpCounter2, 0); [ set.string.v(vSTR, vMSG)
      terminalfn = ADDLINE;
      call(lgc.TerminalFunctions);
      [ pause for a bit
      tmpCounter1 = 4;
      output = ".";
      :wait5
        terminalfn = DELAY_ADD;
        call(lgc.TerminalFunctions);
        --tmpCounter1;
      if (tmpCounter1 > 0) {
        goto(wait5);
      }
      output = " INIT OK";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      ++tmpCounter2;
    if (tmpCounter2 < 14) {
      goto(nextsys2);
    }
    output = "amos load:all";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    tmpCounter1 = 3;
    :delay1
      terminalfn = DELAY_LF;
      call(lgc.TerminalFunctions);
      -- tmpCounter1;
    if (tmpCounter1 > 0) {
      goto(delay1);
    }
    output = "ERROR: corrupt master password file";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "subsystems not loaded";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "use backup passwords to load";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "individual subsystems";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    output = "-- pause --";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    lastChar = 0;
    :wait6
    if (!have.key()) {
      goto(wait6);
    }
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
    output = "amos interface:cmdline";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    terminalfn = DELAY;
    call(lgc.TerminalFunctions);
    terminalfn = DELAY;
    call(lgc.TerminalFunctions);

    [ MOCC is now reset, errors are gone
    if (!resetMOCC) {
      work1 = 2;
      call(lgc.ScoreHandler);
    }
    set(resetMOCC);
    [ clear the screen
    terminalfn = CLS;
    call(lgc.TerminalFunctions);
    [ need login credentials
    inputmode = IM_USERID;
    goto(login);
  }
}

[ if ENTER or CTRL+ENTER
if ((lastChar == 13 || lastChar == 10)) {
  [ advance the inputline BEFORE processing
  terminalfn = LINEFEED;
  call(lgc.TerminalFunctions);
    
  [ parse the input
  parse(input);
    
  [ take appropriate action based on command and input mode
  
  [ process userID
  if (inputmode == IM_USERID) {
    [ userid entered; get password
    block(STR.COPY, &input, &userid, 0); [ str.copy(sINPUT, sRESULT)
    inputmode = IM_PASSWORD;
    PWfunction = PW_LOGON;
    output = "password: ";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    [ get more input (no prompt)
    input = "";
    goto(getKey);
  }
  
  [ process password
  if (inputmode == IM_PASSWORD) {
    if (PWfunction == PW_LOGON) {
      [ assume not valid
      reset(loggedon);
      [ validate userid/password
      sCmd = "kw002";
      if (compare.strings(userid, sCmd)) {
        [ id is valid
        set(loggedon);
      }
      [ passwords are case sensitive
      set.string(SET.CMPMODE, COMPARE_BINARY); [ set.cmpmode(MODE)
      if (!compare.strings(input, kwpassword)) {
        [ password is not valid
        reset(loggedon);
      }
      [ go back to case-insensitive compare
      set.string(SET.CMPMODE, COMPARE_TEXT); [ set.cmpmode(MODE)
      [ if valid continue
      if (loggedon) {
        output = "logged on as kw002";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        output = "access level: 1";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        terminalfn = LINEFEED;
        call(lgc.TerminalFunctions);
        [ change password if first time logging on
        if (defaultPW) {
          output = "welcome kw002";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          output = "password change is required:";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          output = "new password: ";
          terminalfn = ADDLINE;
          call(lgc.TerminalFunctions);
          PWFunction = PW_CHANGE;
        } else {
          inputmode = IM_CMDLINE;
        }
        [ get more input
        goto(getInput);
      } else {
        inputmode = IM_USERID;
        output = "invalid userid and/or password";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        [ position cursor after userid prompt
        output = "userid: ";
        terminalfn = ADDLINE;
        call(lgc.TerminalFunctions);
        [ get input, no prompt
        input = "";
        goto(getKey);
      }
    }
    
    [ passwords are case sensitive
    set.string(SET.CMPMODE, COMPARE_BINARY); [ set.cmpmode(MODE)
    
    [ changing password
    if (PWfunction == PW_CHANGE) {
      [ can't be same as default
      if (compare.strings(input, kwpassword)) {
        output = "invalid: password cannot match default";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        output = "new password: ";
        terminalfn = ADDLINE;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      [ must be 8 or more characters
      block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
      if (work1 < 8) {
        output = "invalid: must be 8 or more characters";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        output = "new password: ";
        terminalfn = ADDLINE;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      [ check character rules
      work3 = 0;
      block(STR.COPY, &input, &sTemp2, 0); [ str.copy(sINPUT, sRESULT)
      :nextchar
      block(CHAR2BYTE, &sTemp2, &work2, 0); [ char2byte(sCHAR, vRESULT)
      [ must have at least one upper
      if (work2 > 64 && work2 < 91) {
        block(BIT.OR, BYNUM, &work3, 1); [ bit.or(FN_MODE, VAR, MASK)
      } else {
        [ must have at least one lower
        if (work2 > 96 && work2 < 123) {
          block(BIT.OR, BYNUM, &work3, 2); [ bit.or(FN_MODE, VAR, MASK)
        } else {
          [ must have at least one number
          if (work2 > 47 && work2 < 58) {
            block(BIT.OR, BYNUM, &work3, 4); [ bit.or(FN_MODE, VAR, MASK)
          } else {
            [ must have at least one special
            block(BIT.OR, BYNUM, &work3, 8); [ bit.or(FN_MODE, VAR, MASK)
          }
        }
      }
      --work1;
      if (work1 > 0) {
        block(STR.RIGHT, &sTemp2, &sTemp2, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
        goto(nextchar);
      }
      [ if all criteria met
      if (work3 == 15) {
        reset(defaultPW);
        block(STR.COPY, &input, &kwpassword, 0); [ str.copy(sINPUT, sRESULT)
        output = "password changed";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        [ go back to normal command input
        goto(getCmdInput);
      } else {
        if (work3 < 8) {
          [ missing special
          output = "invalid: missing special character";
        } else {
          work3 -= 8;
        }
        if (work3 < 4) {
          [ missing number
          output = "invalid: missing a number";
        } else {
          work3 -= 4;
        }
        if (work3 < 2) {
          [ missing lower
          output = "invalid: missing lower case";
        } else {
          work3 -= 2;
        }
        if (work3 < 1) {
          [ missing upper
          output = "invalid: missing upper case";
        }
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        output = "new password: ";
        terminalfn = ADDLINE;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
    }
    
    [ check for sudo
    if (PWfunction == PW_SUDO) {
      [ never valid
      output = "invalid password";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      [ go back to normal command input
      goto(getCmdInput);
    }
    
    [ check for loading subsystem
    reset(validPW);
    if (PWfunction == PW_BADASS) {
      sCmd = "W7tg49@qd";
      if (compare.strings(input, sCmd)) {
        [ ok
        if (!resetBaDASS) {
          work1 = 5;
          call(lgc.ScoreHandler);
        }
        set(resetBaDASS);
        set(validPW);
      }
    }
    if (PWfunction == PW_CAISOCC) {
      sCmd = "G#Am7Dsus";
      if (compare.strings(input, sCmd)) {
        [ ok
        if (!enableCAISOCC) {
          work1 = 2;
          call(lgc.ScoreHandler);
        }
        set(enableCAISOCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_ERIDOCC) {
      sCmd = "ERID081489.a";
      if (compare.strings(input, sCmd)) {
        [ ok
        if (!enableERIDOCC) {
          work1 = 2;
          call(lgc.ScoreHandler);
        }
        set(enableERIDOCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_ESADOCC) {
      sCmd = "Snd4chan$";
      if (compare.strings(input, sCmd)) {
        [ ok
        if (!enableESADOCC) {
          work1 = 2;
          call(lgc.ScoreHandler);
        }
        set(enableESADOCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_ICAPOCC) {
      sCmd = "Drac@1897";
      if (compare.strings(input, sCmd)) {
        [ ok
        if (!enableICAPOCC) {
          work1 = 2;
          call(lgc.ScoreHandler);
        }
        set(enableICAPOCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_OFROCC) {
      sCmd = "PqII:10-36";
      if (compare.strings(input, sCmd)) {
        [ ok
        if (!enableOFROCC) {
          work1 = 2;
          call(lgc.ScoreHandler);
        }
        set(enableOFROCC);
        set(validPW);
      }
    }
    if (PWfunction == PW_RANDOCC) {
      sCmd = "GrGt5!VI";
      if (compare.strings(input, sCmd)) {
        [ ok
        if (!enableRANDOCC) {
          work1 = 2;
          call(lgc.ScoreHandler);
        }
        set(enableRANDOCC);
        set(validPW);
      }
    }
    if (validPW) {
      output = "  loading module %s17...";
      terminalfn = ADDLINE;
      call(lgc.TerminalFunctions);
      terminalfn = DELAY;
      call(lgc.TerminalFunctions);
      output = " OK";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
    } else {
      [ not valid
      output = "invalid password";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
    }
    
    [ command input is case-insensitive
    :getCmdInput
    set.string(SET.CMPMODE, COMPARE_TEXT); [ set.cmpmode(MODE)
    inputmode = IM_CMDLINE;
    [ get more input
    goto(getInput);
  }
  
  [ process command line
  if (inputmode == IM_CMDLINE) {
    if (!resetMOCC) {
      [ add occasional error codes if not reset
      random(1, 10, work1);
      if (work1 == 1) {
        :memerr
        [ create a random address
        random(16, 255, work1);
        block(BYTE2HEX, &sTemp2, &work1, 0); [ byte2hex(sRESULT, vINPUT)
        random(0, 255, work1);
        block(BYTE2HEX, &sTemp3, &work1, 0); [ byte2hex(sRESULT, vINPUT)
        block(STR.CONCAT, &sTemp2, &sTemp3, 0); [ str.concat(sINPUT, sADD)
        output = "Invalid instruction at 78F4:%s17 in ";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        output = "module mem.sys.";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        output = "Program image is corrupt.";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
    }
    
    [ convert input to lower case, trim it,
    block(STR.LOWER, &input, &input, 0); [ str.lower(sINPUT, sRESULT)
    work1 = TRIM_ALL;
    block(STR.TRIM, &input, &input, &work1); [ str.trim(sINPUT, sRESULT, vMODE)
    [ then extract the command (first word)
    work1 = 32;
    work2 = 0;
    block(INSTR, &input, &work1, &work2); [ instr(sINPUT, vCHAR, vPOS)
    if (work2 != -1) {
      block(STR.LEFT, &input, &sCmd, &work2); [ str.left(sINPUT, sRESULT, vLEN)
      [ remove cmd from input, and trim it
      block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
      work1 -= work2;
      block(STR.RIGHT, &input, &input, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
      work1 = TRIM_ALL;
      block(STR.TRIM, &input, &input, &work1); [ str.trim(sINPUT, sRESULT, vMODE)
    } else {
     block(STR.COPY, &input, &sCmd, 0); [ str.copy(sINPUT, sRESULT)
     input = "";
    }
    [ check ascii of first char to quick check for valid cmd
    block(CHAR2BYTE, &sCmd, &work1, 0); [ char2byte(sCHAR, vRESULT)
    if (work1 == 0) {
      goto(getInput);
    }
    
    [ commands starting with 'a'
    if (work1 == 97) {
      [ AMOS
      sTemp2 = "amos";
      if (!compare.strings(sCmd, sTemp2)) {
        [ amos is only valid 'a' command
        goto(syntaxerror);
      }

      [ always fails until module is reset
      if (!resetMOCC) {
        goto (memerr);
      }
      [ allowable subcmds:
      [ init:
      [ load:
      [ stop:
      [ interface:
      [ open:
      
      [ get subcmd
      work1 = 5;
      block(STR.LEFT, &input, &sCmd, &work1); [ str.left(sINPUT, sRESULT, vLEN)
      sTemp2 = "init:";
      if (compare.strings(sCmd, sTemp2)) {
        [ strip off module
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        work1 -= 5;
        block(STR.RIGHT, &input, &sCmd, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
        work1 = TRIM_ALL;
        block(STR.TRIM, &sCmd, &sCmd, &work1); [ str.trim(sINPUT, sRESULT, vMODE)
        reset(validmodule);
        sTemp2 = "badass";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule1);
        }
        sTemp2 = "caisocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule1);
        }
        sTemp2 = "eridocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule1);
        }
        sTemp2 = "esadocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule1);
        }
        sTemp2 = "icapocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule1);
        }
        sTemp2 = "ofrocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule1);
        }
        sTemp2 = "randocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
        }
        :checkmodule1
        if (validmodule) {
          [ already inited
          output = "module already initialized";
        } else {
          [ 'all' is valid
          sTemp2 = "all";
          if (compare.strings(sCmd, sTemp2)) {
            output = "all modules are already initialized";
          } else {
            [ invalid module
            output = "syntax error - ";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            output = "unknown module: %s16";
          }
        }
        terminalfn = ADDLINE;
        call(lgc.TerminalFunctions);
        [ get more input 
        goto(getInput);
      }
      
      sTemp2 = "load:";
      if (compare.strings(sCmd, sTemp2)) {
        [ strip off module
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        work1 -= 5;
        block(STR.RIGHT, &input, &sCmd, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
        work1 = TRIM_ALL;
        block(STR.TRIM, &sCmd, &sCmd, &work1); [ str.trim(sINPUT, sRESULT, vMODE)
        reset(validmodule);
        [ check for one of the seven subsystems
        sTemp2 = "badass";
        if (compare.strings(sCmd, sTemp2)) {
          [get BaDASS password
          PWfunction = PW_BADASS;
          set(validmodule);
          goto(checkmodule2);
        }
        sTemp2 = "caisocc";
        if (compare.strings(sCmd, sTemp2)) {
          [get CAISOCC password
          PWfunction = PW_CAISOCC;
          set(validmodule);
          goto(checkmodule2);
        }
        sTemp2 = "eridocc";
        if (compare.strings(sCmd, sTemp2)) {
          [get ERIDOCC password
          PWfunction = PW_ERIDOCC;
          set(validmodule);
          goto(checkmodule2);
        }
        sTemp2 = "esadocc";
        if (compare.strings(sCmd, sTemp2)) {
          [get ESADOCC password
          PWfunction = PW_ESADOCC;
          set(validmodule);
          goto(checkmodule2);
        }
        sTemp2 = "icapocc";
        if (compare.strings(sCmd, sTemp2)) {
          [get ICAPOCC password
          PWfunction = PW_ICAPOCC;
          set(validmodule);
          goto(checkmodule2);
        }
        sTemp2 = "ofrocc";
        if (compare.strings(sCmd, sTemp2)) {
          [get OFROCC password
          PWfunction = PW_OFROCC;
          set(validmodule);
          goto(checkmodule2);
        }
        sTemp2 = "randocc";
        if (compare.strings(sCmd, sTemp2)) {
          [get RANDOCC password
          PWfunction = PW_RANDOCC;
          set(validmodule);
        }
        
        :checkmodule2
        if (validmodule) {
          inputmode = IM_PASSWORD;
          output = "password: ";
          terminalfn = ADDLINE;
          call(lgc.TerminalFunctions);
          [ get more input (no prompt)
          input = "";
          goto(getKey);
        } else {
          [ 'all' is valid but doesn't work
          sTemp2 = "all";
          if (compare.strings(sCmd, sTemp2)) {
            tmpCounter1 = 3;
            :delay2
              terminalfn = DELAY_LF;
              call(lgc.TerminalFunctions);
              -- tmpCounter1;
            if (tmpCounter1 > 0) {
              goto(delay2);
            }
            output = "ERROR: corrupt master password file";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            output = "subsystems not loaded";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            output = "use backup passwords to load";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            output = "individual subsystems";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            output = "-- pause --";
            terminalfn = ADDLINE;
            call(lgc.TerminalFunctions);
            lastChar = 0;
            :wait9
            if (!have.key()) {
              goto(wait9);
            }
            terminalfn = LINEFEED;
            call(lgc.TerminalFunctions);
          } else {
            [ invalid module
            output = "syntax error - ";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            output = "unknown module: %s16";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
          }
          goto(getInput);
        }
      }
      
      sTemp2 = "stop:";
      if (compare.strings(sCmd, sTemp2)) {
        [ strip off module
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        work1 -= 5;
        block(STR.RIGHT, &input, &sCmd, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
        work1 = TRIM_ALL;
        block(STR.TRIM, &sCmd, &sCmd, &work1); [ str.trim(sINPUT, sRESULT, vMODE)
        reset(validmodule);
        sTemp2 = "badass";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule3);
        }
        sTemp2 = "caisocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule3);
        }
        sTemp2 = "eridocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule3);
        }
        sTemp2 = "esadocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule3);
        }
        sTemp2 = "icapocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule3);
        }
        sTemp2 = "ofrocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
          goto(checkmodule3);
        }
        sTemp2 = "randocc";
        if (compare.strings(sCmd, sTemp2)) {
          set(validmodule);
        }
        :checkmodule3
        if (validmodule) {
          [ not allowed
          terminalfn = NO_ACCESS;
          call(lgc.TerminalFunctions);
          goto(getInput);
        } else {
          [ 'all' is valid
          sTemp2 = "all";
          if (compare.strings(sCmd, sTemp2)) {
            [ not allowed
            terminalfn = NO_ACCESS;
            call(lgc.TerminalFunctions);
          } else {
            [ invalid module
            output = "syntax error - ";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            output = "unknown module: %s16";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
          }
        }
        [ get more input 
        goto(getInput);
      }
      
      [ interface (longer than 4 chars!)
      sTemp2 = "inter";
      if (compare.strings(sCmd, sTemp2)) {
        work1 = 10;
        block(STR.LEFT, &input, &sCmd, &work1); [ str.left(sINPUT, sRESULT, vLEN)
        sTemp2 = "interface:";
        if (compare.strings(sCmd, sTemp2)) {
          [ not allowed
          output = "error - interface already set";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
      }
      
      [ 'open'
      sTemp2 = "open:";
      if (compare.strings(sCmd, sTemp2)) {
        [ strip off module
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        work1 -= 5;
        block(STR.RIGHT, &input, &sCmd, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
        work1 = TRIM_ALL;
        block(STR.TRIM, &sCmd, &sCmd, &work1); [ str.trim(sINPUT, sRESULT, vMODE)
        reset(validmodule);
        [ check for one of the seven subsystems
        sTemp2 = "badass";
        if (compare.strings(sCmd, sTemp2)) {
          [ no interface to run
          output = "no interface for BADASS module";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
        sTemp2 = "caisocc";
        if (compare.strings(sCmd, sTemp2)) {
          [ restore default (inputline) attritubutes
          set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
          [ fade out
          block(FADE.OUT, BYNUM, FADECOUNT, BLACK); [ fade.out(FN_MODE, DELAY, COLOR)
          [ clear return instruction row
          clear.lines(22, 22, BLACK);
          [ switch to caisocc module
          new.room(cp.CAISOCC); [ ##LE002##
        }
        sTemp2 = "eridocc";
        if (compare.strings(sCmd, sTemp2)) {
          [ restore default (inputline) attritubutes
          set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
          [ fade out
          block(FADE.OUT, BYNUM, FADECOUNT, BLACK); [ fade.out(FN_MODE, DELAY, COLOR)
          [ clear return instruction row
          clear.lines(22, 22, BLACK);
          [ switch to eridocc module
          new.room(cp.ERIDOCC); [ ##LE003##
        }
        sTemp2 = "esadocc";
        if (compare.strings(sCmd, sTemp2)) {
          [ restore default (inputline) attritubutes
          set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
          [ fade out
          block(FADE.OUT, BYNUM, FADECOUNT, BLACK); [ fade.out(FN_MODE, DELAY, COLOR)
          [ clear return instruction row
          clear.lines(22, 22, BLACK);
          [ switch to esadocc module
          new.room(cp.ESADOCC); [ ##LE004##
        }
        sTemp2 = "icapocc";
        if (compare.strings(sCmd, sTemp2)) {
          [ restore default (inputline) attritubutes
          set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
          [ fade out
          block(FADE.OUT, BYNUM, FADECOUNT, BLACK); [ fade.out(FN_MODE, DELAY, COLOR)
          [ clear return instruction row
          clear.lines(22, 22, BLACK);
          [ switch to esadocc module
          new.room(cp.ICAPOCC); [ ##LE005##
        }
        sTemp2 = "ofrocc";
        if (compare.strings(sCmd, sTemp2)) {
          [ restore default (inputline) attritubutes
          set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
          [ fade out
          block(FADE.OUT, BYNUM, FADECOUNT, BLACK); [ fade.out(FN_MODE, DELAY, COLOR)
          [ clear return instruction row
          clear.lines(22, 22, BLACK);
          [ switch to ofrocc module
          new.room(cp.OFROCC); [ ##LE006##
        }
        sTemp2 = "randocc";
        if (compare.strings(sCmd, sTemp2)) {
          [ restore default (inputline) attritubutes
          set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
          [ fade out
          block(FADE.OUT, BYNUM, FADECOUNT, BLACK); [ fade.out(FN_MODE, DELAY, COLOR)
          [ clear return instruction row
          clear.lines(22, 22, BLACK);
          [ switch to randocc module
          new.room(cp.RANDOCC); [ ##LE007##
        }
        
        [ invalid module
        output = "syntax error - ";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        output = "unknown module: %s16";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      
      [ if nothing matches, it's a syntax error
      goto(syntaxerror);
    }
    
    [ commands that start with 'c'
    if (work1 == 99) {
      [ CD/CHDIR
      reset(tmpFlag);
      sTemp2 = "cd";
      if (compare.strings(sCmd, sTemp2)) {
        [ same as chdir 
        goto(chdir);
      }
      sTemp2 = "chdir";
      if (compare.strings(sCmd, sTemp2)) {
        :chdir
        [ check parameter
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        if (work1 == 0) {
          [ do nothing
          goto(getInput);
        }
        [ strip off trailing '\' if one is there
        work1 = 1;
        block(STR.RIGHT, &input, &sCmd, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
        block(CHAR2BYTE, &sCmd, &work1, 0); [ char2byte(sCHAR, vRESULT)
        if (work1 == 92) {
          block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
          --work1;
          block(STR.LEFT, &input, &input, &work1); [ str.left(sINPUT, sRESULT, vCOUNT)
        }
        [ valid dir values from any dir:
        [ c:, c:\users, c:\users\kw002, a:
        sTemp2 = "c:";
        if (compare.strings(input, sTemp2)) {
          vCurDir = C_ROOT;
          output = "DIR --> C:\\\\";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
        sTemp2 = "c:\\users";
        if (compare.strings(input, sTemp2)) {
          vCurDir = C_USERS;
          output = "DIR --> C:\\\\USERS";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
        sTemp2 = "c:\\users\\kw002";
        if (compare.strings(input, sTemp2)) {
          vCurDir = C_KW002;
          output = "DIR --> C:\\\\USERS\\\\KW002";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
        sTemp2 = "a:";
        if (compare.strings(input, sTemp2)) {
          if (!floppyInserted) {
            output = "Drive not ready";
          } else {
            if (!floppyFormatted) {
              output = "Disk read error";
            } else {
              vCurDir = A_ROOT;
              output = "DIR --> A:\\\\";
            }
          }
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
  
        [ valid dir values from c:\
        [ users, users\kw002
        if (vCurDir == C_ROOT) {
          sTemp2 = "users";
          if (compare.strings(input, sTemp2)) {
            vCurDir = C_USERS;
            output = "DIR --> C:\\\\USERS";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            goto(getInput);
          }
          sTemp2 = "users\\kw002";
          if (compare.strings(input, sTemp2)) {
            vCurDir = C_KW002;
            output = "DIR --> C:\\\\USERS\\\\KW002";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            goto(getInput);
          }
        }
        
        [ valid dir values from c:\users:
        [ .., kw002
        if (vCurDir == C_USERS) {
          sTemp2 = "..";
          if (compare.strings(input, sTemp2)) {
            vCurDir = C_ROOT;
            output = "DIR --> C:\\\\";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            goto(getInput);
          }
          sTemp2 = "kw002";
          if (compare.strings(input, sTemp2)) {
            vCurDir = C_KW002;
            output = "DIR --> C:\\\\USERS\\\\KW002";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            goto(getInput);
          }
        }
        [ valid dir values from c:\users\kw002:
        [ ..
        if (vCurDir == C_KW002) {
          sTemp2 = "..";
          if (compare.strings(input, sTemp2)) {
            vCurDir = C_USERS;
            output = "DIR --> C:\\\\USERS";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            goto(getInput);
          }
        }
        [ any other directory is not allowed
        output = "ERROR: invalid or protected directory";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      
      [ CHKDSK
      sTemp2 = "chkdsk";
      if (compare.strings(sCmd, sTemp2)) {
        sTemp2 = "";
        if (compare.strings(input, sTemp2)) {
          output = "no drive specified";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
        } else {
          [ acceptable params a:, a, c:, c
          reset(tmpFlag);
          sTemp2 = "a";
          if (compare.strings(input, sTemp2)) {
            work1 = 0;
            set(tmpFlag);
          } else {
            sTemp2 = "a:";
            if (compare.strings(input, sTemp2)) {
              work1 = 0;
              set(tmpFlag);
            } else {
              sTemp2 = "c";
              if (compare.strings(input, sTemp2)) {
                work1 = 1;
                set(tmpFlag);
              } else {
                sTemp2 = "c:";
                if (compare.strings(input, sTemp2)) {
                  work1 = 1;
                  set(tmpFlag);
                }
              }
            }
          }
          if (tmpFlag) {
            if (work1 == 0) {
              [ a drive
              if (floppyInserted) {
                if (floppyFormatted) {
                  terminalfn = CHKDSK_A;
                  call(lgc.TerminalFunctions);
                } else {
                  output = "Disk read error";
                  terminalfn = ADDLINE_LF;
                  call(lgc.TerminalFunctions);
                }
              } else {
                output = "Drive not ready";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
              } 
            } else {
              [ c drive
              terminalfn = CHKDSK_C;
              call(lgc.TerminalFunctions);
            }
          } else {
            output = "The specified drive is invalid";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
          }
        }
        goto(getInput);
      }
      
      [ CLS
      sTemp2 = "cls";
      if (compare.strings(sCmd, sTemp2)) {
        [ no parameters allowed
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        if (work1 == 0) {
          terminalfn = CLS;
          call(lgc.TerminalFunctions);
          goto(getInput);      
        } else {
          goto(syntaxerror);
        }
      }
      
      [ COPY
      sTemp2 = "copy";
      if (compare.strings(sCmd, sTemp2)) {
        work1 = 32;
        work2 = 0;
        block(INSTR, &input, &work1, &work2); [ instr(sINPUT, vCHAR, vPOS)
        if (work2 != -1) {
          [ extract dest
          block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
          work1 -= work2;
          block(STR.RIGHT, &input, &sTemp3, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
          work1 = TRIM_ALL;
          block(STR.TRIM, &sTemp3, &sTemp3, &work1); [ str.trim(sINPUT, sRESULT, vMODE)
          [ trim src
          block(STR.LEFT, &input, &input, &work2); [ str.left(sINPUT, sRESULT, vLEN)
        } else {
          [ no destination
          sTemp3 = "";
        }
        [ input = src; sTemp3 = dest
        [ only destination is a:
        sTemp2 = "a:";
        if (!compare.strings(sTemp2, sTemp3)) {
          [ dest not allowed
          output = "invalid or restricted destination";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
          goto(getInput);
        }
  
        [ only in c:\users\kw002
        if (vCurDir == C_KW002) {
          [ only files pwrpack.zip and pwrpack.txt, *.*
          reset(tmpFlag);
          tmpCounter1 = 0;
          sTemp2 = "pwrpack.zip";
          if (compare.strings(sTemp2, input)) {
            set(tmpFlag);
            tmpCounter1 = 1;
            goto(chksource);
          }
          sTemp2 = "pwrpack.txt";
          if (compare.strings(sTemp2, input)) {
            set(tmpFlag);
            tmpCounter1 = 2;
            goto(chksource);
          }
          sTemp2 = "*.*";
          if (compare.strings(sTemp2, input)) {
            set(tmpFlag);
            tmpCounter1 = 3;
            goto(chksource);
          }
          sTemp2 = "pwrpack.*";
          if (compare.strings(sTemp2, input)) {
            set(tmpFlag);
            tmpCounter1 = 3;
            goto(chksource);
          }
          :chksource        
          if (tmpFlag) {
            [ is drive ready?
            if (!floppyInserted) {
              output = "drive a: not ready";
              terminalfn = ADDLINE_LF;
              call(lgc.TerminalFunctions);
              goto(getInput);
            }
            [ is drive formatted?
            if (!floppyFormatted) {
              output = "disk error in drive a:";
              terminalfn = ADDLINE_LF;
              call(lgc.TerminalFunctions);
              goto(getInput);
            }
            [ ok to copy!
            if ((tmpCounter1 == 1 || tmpCounter1 == 3)) {
              [ if file already there,
              if ((floppyfiles == 1 || floppyfiles == 3)) {
                output = "PWRPACK.TXT already exists on a:";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
                output = "overwrite? (y/n) ?";
                terminalfn = ADDLINE;
                call(lgc.TerminalFunctions);
                
                :getKeyCopy1
                lastChar = 0;
                if (!have.key()) {
                  goto(getKeyCopy1);
                }
                if ((lastChar == 78 || lastChar == 110)) {
                  output = "n";
                  terminalfn = ADDLINE_LF;
                  call(lgc.TerminalFunctions);
                  goto(chkzip);
                }
                if ((lastChar == 89 || lastChar == 121)) {
                  output = "y";
                  terminalfn = ADDLINE_LF;
                  call(lgc.TerminalFunctions);
                } else {
                  goto(getKeyCopy1);
                }
               
              } else {
                work1 = 1;
                call(lgc.ScoreHandler);
              }
              output = "copying PWRPACK.TXT to a: .";
              terminalfn = DELAY_ADD;
              call(lgc.TerminalFunctions);
              output = "done";
              terminalfn = ADDLINE_LF;
              call(lgc.TerminalFunctions);
              block(BIT.OR, BYNUM, &floppyfiles, 1); [ bit.or(FN_MODE, VAR, MASK)
            }
            
            :chkzip
            if ((tmpCounter1 == 2 || tmpCounter1 == 3)) {
              [ if file already there,
              if ((floppyfiles == 2 || floppyfiles == 3)) {
                output = "PWRPACK.ZIP already exists on a:";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
                output = "overwrite? (y/n) ?";
                terminalfn = ADDLINE;
                call(lgc.TerminalFunctions);
                
                :getKeyCopy2
                lastChar = 0;
                if (!have.key()) {
                  goto(getKeyCopy2);
                }
                if ((lastChar == 78 || lastChar == 110)) {
                  output = "n";
                  terminalfn = ADDLINE_LF;
                  call(lgc.TerminalFunctions);
                  goto(getInput);
                }
                if ((lastChar == 89 || lastChar == 121)) {
                  output = "y";
                  terminalfn = ADDLINE_LF;
                  call(lgc.TerminalFunctions);
                } else {
                  goto(getKeyCopy2);
                }
               
              } else {
                work1 = 5;
                call(lgc.ScoreHandler);
              }
              output = "copying PWRPACK.ZIP to a: .";
              terminalfn = DELAY_ADD;
              call(lgc.TerminalFunctions);
              output = ".";
              terminalfn = DELAY_ADD;
              call(lgc.TerminalFunctions);
              output = ".";
              terminalfn = DELAY_ADD;
              call(lgc.TerminalFunctions);
              output = "done";
              terminalfn = ADDLINE_LF;
              call(lgc.TerminalFunctions);
              block(BIT.OR, BYNUM, &floppyfiles, 2); [ bit.or(FN_MODE, VAR, MASK)
            }
          } else {
            [ not a valid source
            output = "destination directory is same as source";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
          }
          goto(getInput);
        } else {
          [ if in a:
          if (vCurDir == A_ROOT) {
            [ src=dest
            output = "destination directory is same as source";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
          } else {
            [ files in this directory are protrcted
            output = "copying not allowed -";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
            output = "current directory is restricted";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
          }
          goto(getInput);
        }
      }
      
      [ no other 'c' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 'd'
    if (work1 == 100) {
      [ DIR
      sTemp2 = "dir";
      if (compare.strings(sCmd, sTemp2)) {
        [ check parameter
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        if (work1 == 0) {
          [ show current directory
          vShowDir = vCurDir;
        } else {
          [ strip off trailing '\' if one is there
          work1 = 1;
          block(STR.RIGHT, &input, &sCmd, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
          block(CHAR2BYTE, &sCmd, &work1, 0); [ char2byte(sCHAR, vRESULT)
          if (work1 == 92) {
            block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
            --work1;
            block(STR.LEFT, &input, &input, &work1); [ str.left(sINPUT, sRESULT, vCOUNT)
          }
          vShowDir = -1;
          [ valid dir values from any dir:
          [ c:, c:\users, c:\users\kw002, a:
          sTemp2 = "c:";
          if (compare.strings(input, sTemp2)) {
            vShowDir = C_ROOT;
          }
          sTemp2 = "c:\\users";
          if (compare.strings(input, sTemp2)) {
            vShowDir = C_USERS;
          }
          sTemp2 = "c:\\users\\kw002";
          if (compare.strings(input, sTemp2)) {
            vShowDir = C_KW002;
          }
          sTemp2 = "a:";
          if (compare.strings(input, sTemp2)) {
            if (!floppyInserted) {
              output = "Drive not ready";
              call(lgc.TerminalFunctions);
              goto(getInput);
            } else {
              if (!floppyFormatted) {
                output = "Disk read error";
                call(lgc.TerminalFunctions);
                goto(getInput);
              } else {
                vShowDir = A_ROOT;
              }
            }
          }
          
          
          [ valid dir values from c:\
          [ users, users\kw002
          if (vCurDir == C_ROOT && vShowDir != -1) {
            sTemp2 = "users";
            if (compare.strings(input, sTemp2)) {
              vShowDir = C_USERS;
            }
            sTemp2 = "users\\kw002";
            if (compare.strings(input, sTemp2)) {
              vShowDir = C_KW002;
            }
          }
          [ valid dir values from c:\users:
          [ kw002
          if (vCurDir == C_USERS && vShowDir != -1) {
            sTemp2 = "kw002";
            if (compare.strings(input, sTemp2)) {
              vShowDir = C_KW002;
            }
          }
        }
        if (vShowDir != -1) {
          terminalfn = SHOW_DIR;
        } else {
          [ any other directory is invalid
          output = "ERROR: invalid or protected directory";
          terminalfn = ADDLINE_LF;
        }
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      
      [ DEL/ERASE
      sTemp2 = "del";
      if (compare.strings(sTemp2, sCmd)) {
        :delfile
        [ never allowed
        terminalfn = NO_ACCESS;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      [ no other 'd' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 'e'
    if (work1 == 101) {
      [ ERASE
      sTemp2 = "erase";
      if (compare.strings(sTemp2, sCmd)) {
        [ same as 'del'
        goto(delfile);
      }
      
      [ EXIT
      sTemp2 = "exit";
      if (compare.strings(sTemp2, sCmd)) {
        [ same as reboot
        terminalfn = CLS;
        call(lgc.TerminalFunctions);
        goto(reboot);
      }
      [ no other 'e' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 'f'
    if (work1 == 102) {
      [ FORMAT
      sTemp2 = "format";
      if (compare.strings(sCmd, sTemp2)) {
        [ check for argument ('a', 'c', etc)
        sTemp2 = "";
        if (compare.strings(input, sTemp2)) {
          output = "no drive specified";
          terminalfn = ADDLINE_LF;
          call(lgc.TerminalFunctions);
        } else {
          [ acceptable params a, c, a:, c:
          reset(tmpFlag);
          sTemp2 = "a";
          if (compare.strings(input, sTemp2)) {
            work1 = 0;
            set(tmpFlag);
          } else {
            sTemp2 = "a:";
            if (compare.strings(input, sTemp2)) {
              work1 = 0;
              set(tmpFlag);
            } else {
              sTemp2 = "c";
              if (compare.strings(input, sTemp2)) {
                work1 = 1;
                set(tmpFlag);
              } else {
                sTemp2 = "c:";
                if (compare.strings(input, sTemp2)) {
                  work1 = 1;
                  set(tmpFlag);
                }
              }
            }
          }
          if (tmpFlag) {
            if (work1 == 0) {
              [ a: drive
              if (floppyInserted) {
                if (floppyFormatted) {
                  [ ask to overwrite
                  output = "Drive A is already formatted.";
                  terminalfn = ADDLINE_LF;
                  call(lgc.TerminalFunctions);
                  output = "Re-formatting will erase entire";
                  terminalfn = ADDLINE_LF;
                  call(lgc.TerminalFunctions);
                  output = "disk contents. Continue? (y/n)?";
                  terminalfn = ADDLINE;
                  call(lgc.TerminalFunctions);
                  :getKeyFormat
                  lastChar = 0;
                  if (!have.key()) {
                    goto(getKeyFormat);
                  }
                  if ((lastChar == 78 || lastChar == 110)) {
                    output = "n";
                    terminalfn = ADDLINE_LF;
                    call(lgc.TerminalFunctions);
                    goto(getInput);
                  }
                  if ((lastChar == 89 || lastChar == 121)) {
                    output = "y";
                    terminalfn = ADDLINE_LF;
                    call(lgc.TerminalFunctions);
                    if (floppyfiles > 0) {
                      if ((floppyfiles == 1 || floppyfiles == 3)) {
                        work1 = -1;
                        call(lgc.ScoreHandler);
                      }
                      if ((floppyfiles == 2 || floppyfiles == 3)) {
                        work1 = -5;
                        call(lgc.ScoreHandler);
                      }
                      floppyfiles = 0;
                    }
                  } else {
                    goto(getKeyFormat);
                  }
                }
                terminalfn = FORMAT_A;
                call(lgc.TerminalFunctions);
                set(floppyFormatted);
                goto(getInput);
              } else {
                output = "Drive not ready";
                terminalfn = ADDLINE_LF;
                call(lgc.TerminalFunctions);
              } 
            } else {
              [ c drive
              output = "access denied";
              terminalfn = ADDLINE_LF;
              call(lgc.TerminalFunctions);
            }
          } else {
            output = "The specified drive is invalid";
            terminalfn = ADDLINE_LF;
            call(lgc.TerminalFunctions);
          }
        }
        goto(getInput);
      }
      [ no other 'f' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 'h'
    if (work1 == 104) {
      [ HELP 
      sTemp2 = "help";
      if (compare.strings(sCmd, sTemp2)) {
        terminalfn = SHOW_HELP;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      [ no other 'h' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 'l'
    if (work1 == 108) {
      [ LOGOFF
      sTemp2 = "logoff";
      if (compare.strings(sCmd, sTemp2)) {
        output = "signing off...";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        terminalfn = DELAY;
        call(lgc.TerminalFunctions);
        [ clear the screen
        terminalfn = CLS;
        call(lgc.TerminalFunctions);
        [ jump to login code
        goto(login);
      }
      [ no other 'l' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 'm'
    if (work1 == 109) {
      [ MD/MKDIR
      sTemp2 = "mkdir";
      if (compare.strings(sTemp2, sCmd)) {
        :mkdir
        [ never allowed
        terminalfn = NO_ACCESS;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      sTemp2 = "md";
      if (compare.strings(sTemp2, sCmd)) {
        [ same as mkdir
        goto(mkdir);
      }
      [ no other 'm' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 'r'
    if (work1 == 114) {
      [ RD/RMDIR
      sTemp2 = "rmdir";
      if (compare.strings(sTemp2, sCmd)) {
        :rmdir
        [ never allowed
        terminalfn = NO_ACCESS;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
  
      sTemp2 = "rd";
      if (compare.strings(sTemp2, sCmd)) {
        [ same as rmdir
        goto(rmdir);
      }
      
      [ REN/RENAME
      sTemp2 = "rename";
      if (compare.strings(sTemp2, sCmd)) {
        :rename
        [ never allowed
        terminalfn = NO_ACCESS;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
  
      sTemp2 = "ren";
      if (compare.strings(sTemp2, sCmd)) {
        [ same as rename
        goto(rename);
      }
      [ no other 'r' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 's'
    if (work1 == 115) {
      [ SUDO
      sTemp2 = "sudo";
      if (compare.strings(sTemp2, sCmd)) {
        [ should always be another command
        block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
        if (work1 == 0) {
          output = "no command specified";
          terminalfn = ADDLINE_LF;
          call(lgc.Terminalfunctions);
          goto(getInput);
        } else {
          [ get an admin password 
          [ (which will never work)
          inputmode = IM_PASSWORD;
          PWfunction = PW_SUDO;
          output = "admin password: ";
          terminalfn = ADDLINE;
          call(lgc.Terminalfunctions);
          [ get more input (no prompt)
          input = "";
          goto(getKey);
        }
      }
      [ no other 's' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 't'
    if (work1 == 116) {
      [ TYPE
      sTemp2 = "type";
      if (compare.strings(sTemp2, sCmd)) {
        sTemp2 = "";
        if (compare.strings(input, sTemp2)) {
          output = "no file specified";
          terminalfn = ADDLINE_LF;
          call(lgc.Terminalfunctions);
          goto(getInput);
        }
        [ PWRPACK.TXT in c:\users\kw002 or (a: if copied)
        reset(tmpFlag);
        sTemp2 = "pwrpack.txt";
        if (compare.strings(input, sTemp2)) {
          if (vCurDir == C_KW002) {
            set(tmpFlag);
            goto(checktype);
          }
          if (vCurDir == A_ROOT && (floppyfiles == 1 || floppyfiles == 3) ) {
            set(tmpFlag);
            goto(checktype);
          }
        }
        [ kw002\PWRPACK.TXT in c:\users
        sTemp2 = "kw002\\pwrpack.txt";
        if (compare.strings(input, sTemp2) && vCurDir == C_USERS) {
          set(tmpFlag);
          goto(checktype);
        }
        [ users\kw002\PWRPACK.TXT in c:\
        sTemp2 = "users\\kw002\\pwrpack.txt";
        if (compare.strings(input, sTemp2) && vCurDir == C_ROOT) {
          set(tmpFlag);
          goto(checktype);
        }
        [ c:\users\kw002\PWRPACK.TXT in any directory
        sTemp2 = "c:\\users\\kw002\\pwrpack.txt";
        if (compare.strings(input, sTemp2)) {
          set(tmpFlag);
          goto(checktype);
        }
        [ a:\PWRPACK.TXT or a:PWRPACK.TXT in any directory
        [    (if copied and disk installed/formatted)
        if (floppyInserted && (floppyfiles == 1 || floppyfiles == 3)) {
          sTemp2 = "a:\\pwrpack.txt";
          if (compare.strings(input, sTemp2)) {
            set(tmpFlag);
            goto(checktype);
          }
          sTemp2 = "a:pwrpack.txt";
          if (compare.strings(input, sTemp2)) {
            set(tmpFlag);
          }
        }
        :checktype
        if (tmpFlag) {
          reset(tmpFlag);
          terminalfn = TYPE_PP;
          call(lgc.Terminalfunctions);
        } else {
          output = "file not found or invalid file format";
          terminalfn = ADDLINE_LF;
          call(lgc.Terminalfunctions);
        }
        goto(getInput);
      }
      [ no other 't' commands
      goto(syntaxerror);
    }
    
    [ commands that start with 'v'
    if (work1 == 118) {
      [ VER
      sTemp2 = "ver";
      if (compare.strings(sTemp2, sCmd)) {
        output = "AGI Mainframe Operating System v2.3";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        output = "Build 244, 08/06/89";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        terminalfn = LINEFEED;
        call(lgc.Terminalfunctions);
        output = "Power Pack module versions:";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        output = "  CAISOCC    1.22a";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        output = "  ERIDOCC    1.04";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        output = "  ESADOCC    2.22";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        output = "  ICAPOCC    1.10";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        output = "  OFROCC     1.01";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        output = "  RANDOCC    2.00";
        terminalfn = ADDLINE_LF;
        call(lgc.Terminalfunctions);
        goto(getInput);
      }
      
      [ VOL
      sTemp2 = "vol";
      if (compare.strings(sTemp2, sCmd)) {
        sTemp2 = "";
        if (compare.strings(input, sTemp2)) {
          output = "no drive specified";
        } else {
          [ acceptable params a:, a, c:, c
          reset(tmpFlag);
          sTemp2 = "a";
          if (compare.strings(input, sTemp2)) {
            work1 = 0;
            set(tmpFlag);
          } else {
            sTemp2 = "a:";
            if (compare.strings(input, sTemp2)) {
              work1 = 0;
              set(tmpFlag);
            } else {
              sTemp2 = "c";
              if (compare.strings(input, sTemp2)) {
                work1 = 1;
                set(tmpFlag);
              } else {
                sTemp2 = "c:";
                if (compare.strings(input, sTemp2)) {
                  work1 = 1;
                  set(tmpFlag);
                }
              }
            }
          }
          if (tmpFlag) {
            if (work1 == 0) {
              [ a drive
              if (floppyInserted) {
                if (floppyFormatted) {
                  output = "Volume in drive A is %s5";
                } else {
                  output = "Disk read error";
                }
              } else {
                output = "Drive not ready";
              } 
            } else {
              [ c drive
              output = "Volume in drive C is AMOSDISK";
            }
          } else {
            output = "The specified drive is invalid";
          }
        }
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        goto(getInput);
      }
      [ no other 'v' commands
      goto(syntaxerror);
    }
    
    [ anything else is an error
    :syntaxerror
    output = "syntax error";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    [ get more input
    goto(getInput);
  }
  
  [ args/extra input
  if (inputmode == IM_ARGINPUT) {
    [ currently no commands use this feature
    output = "accept input";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
    inputmode = IM_CMDLINE;
    [ get more input
    goto(getInput);
  }
}

[ check for backspace
if (lastChar == 8) {
  [ get input length
  block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
  [ if anything on the input line, backspace is allowed
  if (work1 > 0) {
    [ if not at left edge
    if (cursor_col > LEFTCOL) {
      [ back up one space
      --cursor_col;
    } else {
      [ if at left edge, go up one row to right edge
      --cursor_row;
      cursor_col = RIGHTCOL;
    }
    [ remove char from display (backspace char will erase it)
    display.v(cursor_row, cursor_col, cursor_char);
    
    [ remove the last char from the input line
    --work1;
    block(STR.LEFT, &input, &input, &work1); [ str.left(sINPUT, sRESULT, vLEN)
  }
} else {
  [ if any other char, add it to input
  block(BYTE2CHAR, &char, &lastChar, 0); [ byte2char(sRESULT, vCHAR)
  block(STR.CONCAT, &input, &char, 0); [ str.concat(sINPUT, sADD)
  [ if in password mode, display an asterisk
  if (inputmode == IM_PASSWORD) {
    work1 = &m5;
  } else {
    if (lastChar == 92) {
      work1 = &m14;
    } else {
      work1 = &charmsg;
    }
  }
  display.v(cursor_row, cursor_col, work1);
  
  [ advance cursor
  ++cursor_col;
  if (cursor_col > RIGHTCOL) {
    [ advance the inputline
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
  }
}
[ then get next keypress
goto(getKey);



[ **************************************
[ CHECK FOR AN EXIT CONDITION
[ **************************************

return();


[***************************************
[ DECLARED MESSAGES
[***************************************
#message 1 "_"
#message 2 " "
#message 3 "%s13"
#message 4 "%s14"
#message 5 "*"
#message 6 ">"
#message 7 "BaDASS"
#message 8 "caisocc"
#message 9 "eridocc"
#message 10 "esadocc"
#message 11 "icapocc"
#message 12 "ofrocc"
#message 13 "randocc"
#message 14 "\\\\"
#message 15 "  *    *   *   **\x08    ****"
#message 16 " * *  œ** **  *   *  *"
#message 17 "*****  * * *  *   î   ***"
#message 18 "„  *  *   *  *   *      *"
#message 19 "*   *  *  #*   ***   **±*"
#message 20 "AGI Mainframe Operating S?stem v2.3"
#message 21 "  (c) 1«86 Sierra Online, Inc."

#message 22 "  *    *   *   ***    ****"
#message 23 " * *   ** **  *   *  *"
#message 24 "*****  * * *  *   *   ***"
#message 25 "*   *  *   *  *   *      *"
#message 26 "*   *  *   *   ***   ****"
#message 27 "AGI Mainframe Operating System v2.3"
#message 28 "  (c) 1986 Sierra Online, Inc."
