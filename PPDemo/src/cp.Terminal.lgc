[ ********************************************************************[[ cp.Terminal [[ Master Options Control Console[[ a command driven text terminal[[ ********************************************************************#define cursor_row    v240#define cursor_col    v241#define cursor_char   v242#define cursor_toggle v243#define cursorstate   f241#define input   s12#define char    s13#define charmsg  m3#define toprow         5#define btmrow        16#define leftcol       11#define rightcol      46[ room variable declarations[ This room does not run the main agi loop; all input is handled[ and responded within this logic. So no need to check for newRoom[ flag.[ this is the first cycle through this room[ load, draw and discard the picture resource for the current room[ do basic room initializationcall(lgc.RoomInit);load.pic(currentRoom);draw.pic(currentRoom);discard.pic(currentRoom);load.logics(lgc.TerminalFunctions);[ no mousedisable.item(mouse);[ set colorsset.text.attribute(-1, 0);[ maybe use amber?set.text.attribute(GREEN, BLACK);[[ clear the simulated screen[clear.text.rect(toprow, leftcol, btmrow, rightcol, BLACK);[ display itshow.pic();block(FADE.IN, 0, FADECOUNT, BLACK); [ fade.in(BYVAR, DELAY, COLOR)[ position cursor at first line of virtual screen, at right edgecursor_row = toprow;cursor_col = leftcol;cursor_char = 1;display.v(cursor_row, cursor_col, cursor_char);[ main input loop:getKey[ flush the keybufferlastChar = 0;if (!have.key()) {  [ delay 25 msec  work1 = 25;  cycle.time(o254, work1);   [ toggle the cursor every 200 msec  ++cursor_toggle;  if (cursor_toggle > 9) {    cursor_toggle = 0;    cursor_char *= -1;    cursor_char += 3; [ this toggles cursor msg num between 1 and 2    display.v(cursor_row, cursor_col, cursor_char);  }    [ check for a key  goto(getKey);}:havekey[[ DEBUG: display the key value[display(24, 1, "%v19   ");[ make sure cursor gets hiddenif (cursor_char == 1) {  cursor_char = 2;  display.v(cursor_row, cursor_col, cursor_char);}[ if ENTER or CTRL+ENTERif ((lastChar == 13 || lastChar == 10)) {  [ advance the inputline BEFORE processing  work1 = 1;  call(lgc.TerminalFunctions);      [ parse the input  parse(input);    [ deal with input  if (said("quit")) {    [ display exit msg    work1 = &m60;    display.v(cursor_row, cursor_col, work1);        [ short delay    work1 = 255;    cycle.time(o254, work1);    [ restore default (inputline) attritubutes    set.text.attribute(0, -1);        [ now fade out again (no delay though)    block(FADE.OUT, 0, FADECOUNT, BLACK); [ fade.out(BYVAR, DELAY, COLOR)        [ go back to terminal roonm    new.room(rm.Terminal); [ ##LE001##  }    if (said("help")) {    [ show some help lines    work1 = 5;    display.v(cursor_row, cursor_col, work1);    [ linefeed    work1 = 1;    call(lgc.TerminalFunctions);    work1 = 6;    display.v(cursor_row, cursor_col, work1);    [ linefeed    work1 = 1;    call(lgc.TerminalFunctions);  }    [ clear input  input = "";  [ if input was processed, get more input  if (haveMatch) {[set(enableTrace);[trace.on();    goto(getKey);  }    [ anything else is not acknowledged    [ display syntax error message  work1 = 4;  display.v(cursor_row, cursor_col, work1);  [ linefeed  work1 = 1;  call(lgc.TerminalFunctions);    [ get more input  goto(getKey);}[ backspaceif (lastChar == 8) {  if (cursor_col > leftcol) {    --cursor_col;    display.v(cursor_row, cursor_col, cursor_char);    work1 = cursor_col;    work1 -= leftcol;    [ remove the last char from the input line    block(STR.LEFT, &input, &input, &work1); [ str.left(sINPUT, sRESULT, vLEN);  }  goto(getKey);}[ if any other char, add it to screenblock(BYTE2CHAR, &char, &lastChar, 0); [ byte2char(sRESULT, vCHAR);work1 = &charmsg;display.v(cursor_row, cursor_col, work1);[ add it to inputblock(STR.CONCAT, &input, &char, 0); [ sINPUT, sADD);[ advance cursor++cursor_col;if (cursor_col >= rightcol) {  [ advance the inputline  work1 = 1;  call(lgc.TerminalFunctions);}[ then get more inputgoto(getKey);[*****:exit              [  test for leaving the room[*****[ add exit checks here (or use layout editor)return();[*****[ messages         [  declared messages go here[*****#message 1 "_"#message 2 " "#message 3 "%s13"#message 4 "syntax error"#message 5 "command list:"#message 6 "  quit"#message 60 "exiting..."