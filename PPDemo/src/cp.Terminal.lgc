[ ********************************************************************[[ cp.Terminal[[ a command driven text terminal[[ ********************************************************************#define cursor_row    v240#define cursor_col    v241#define cursor_char   v242#define cursor_toggle v243#define cursorstate   f241#define input   s10#define toprow         5#define btmrow        16#define leftcol       11#define rightcol      46[ room variable declarations[ This room does not run the main agi loop; all input is handled[ and responded within this logic. So no need to check for newRoom[ flag.[ this is the first cycle through this room[ load, draw and discard the picture resource for the current roomload.pic(currentRoom);draw.pic(currentRoom);discard.pic(currentRoom);[ do basic room initializationcall(lgc.RoomInit);load.logics(lgc.TerminalFunctions);[ no objects[ set colorsset.text.attribute(-1, 0);[maybe use amber?set.text.attribute(GREEN, BLACK);[ 80 colconfigure.screen(-1, 0, 1);[[ clear the simulated screen[clear.text.rect(toprow, leftcol, btmrow, rightcol, BLACK);[ position cursor at first line of virtual screen, at right edgecursor_row = toprow;cursor_col = leftcol;cursor_char = 1;[ draw itdisplay.v(cursor_row, cursor_col, cursor_char);[ hide mouse in this room:getKey[ flush the keybufferlastChar = 0;if (!have.key()) {  [ delay 50 msec  work = 50;  cycle.time(o254, work);  [ toggle the cursor every 200 msec  ++cursor_toggle;  if (cursor_toggle > 5) {    cursor_toggle = 0;    cursor_char *= -1;    cursor_char += 3;    display.v(cursor_row, cursor_col, cursor_char);  }    [ check for a key  goto(getKey);}:havekey[ DEBUG: display the key valuedisplay(24, 1, "%v19   ");[ make sure cursor gets hiddenif (cursor_char == 1) {  cursor_char = 2;  display.v(cursor_row, cursor_col, cursor_char);}[ if ENTER or CTRL+ENTERif ((lastChar == 13 || lastChar == 10)) {  [ advance the inputline BEFORE processing  work = 1;  call(lgc.TerminalFunctions);      [ parse the input  parse(input);    [ deal with input  if (said("quit")) {    [ restore default (inputline) attritubutes    set.text.attribute(0, -1);        [restore 40?    configure.screen(-1, 0, 0);        [ go back to terminal roonm    new.room(rm.Terminal); [ ##LE001##  }    if (said("help")) {    [ show some help lines    work = 5;    display.v(cursor_row, cursor_col, work);    [ linefeed    work = 1;    call(lgc.TerminalFunctions);    work = 6;    display.v(cursor_row, cursor_col, work);    [ linefeed    work = 1;    call(lgc.TerminalFunctions);  }    [ clear input  input = "";  [ if input was processed, get more input  if (haveMatch) {[set(enableTrace);[trace.on();    goto(getKey);  }    [ anything else is not acknowledged    [ display syntax error message  work = 4;  display.v(cursor_row, cursor_col, work);  [ linefeed  work = 1;  call(lgc.TerminalFunctions);    [ get more input  goto(getKey);}[ backspaceif (lastChar == 8) {  if (cursor_col > leftcol) {    --cursor_col;    display.v(cursor_row, cursor_col, cursor_char);    work = cursor_col;    work -= leftcol;    [ remove the last char from the input line    block(STR.LEFT, 10, 10, 46); [ str.left(sINPUT, sRESULT, vLEN);  }  goto(getKey);}[ if any other char, add it to screenblock(BYTE2CHAR, 3, 19, 0); [ byte2char(sRESULT, vCHAR);work = 3;display.v(cursor_row, cursor_col, work);[ add it to inputblock(STR.CONCAT, 10, 3, 0); [ sINPUT, sADD);[ advance cursor++cursor_col;if (cursor_col >= rightcol) {  [ advance the inputline  work = 1;  call(lgc.TerminalFunctions);}[ then get more inputgoto(getKey);[*****:exit              [  test for leaving the room[*****[ add exit checks here (or use layout editor)return();[*****[ messages         [  declared messages go here[*****#message 1 "_"#message 2 " "#message 3 "%s3"#message 4 "syntax error"#message 5 "command list:"#message 6 "  quit"