[ ********************************************************************
[
[ cp.Terminal 
[
[ Master Options Control Console
[
[ a command driven text terminal
[
[ ********************************************************************

#define cursor_row    v240
#define cursor_col    v241
#define cursor_char   v242
#define cursor_toggle v243
#define inputmode     v244
  #define IM_USERID    0 [ wait for userid
  #define IM_PASSWORD  1 [ wait for pw
  #define IM_CMDLINE   2 [ wait for commandline
  #define IM_ARGINPUT  3 [ wait for additional args/input
#define terminalfn    v245
  #define LINEFEED     1
  #define DELAY        2
  #define DELAY_LF     3
  #define ADDLINE      4
  #define ADDLINE_LF   5
  #define CLS          6
#define outputvar     v246
#define tmpCounter1   v247
#define tmpCounter2   v248

#define cursorstate   f241
#define loggedon      f242
#define validmodule   f243

#define input          s12
#define char           s13
#define output         s14
#define userid         s15
#define validID        s16
#define validPW        s17

#define charmsg         m3
#define outputmsg       m4
#define promptmsg       m6

#define TOPROW         4
#define BTMROW        18
#define LEFTCOL        9
#define RIGHTCOL      48

[ room variable declarations

[ This room does not run the main agi loop; all input is handled
[ and responded within this logic. So no need to check for newRoom
[ flag.

[ load, draw and discard the picture resource for the current room
load.pic(currentRoom);
draw.pic(currentRoom);
discard.pic(currentRoom);

load.logics(lgc.TerminalFunctions);

[ no mouse
disable.item(mouse);

set.text.attribute(-1, 0);

[ display it
show.pic();
[[display(0, 0, "012345678901234567890123456789012345678901234567890123456789");
[[display(1, 0, "1\n2\n3\n4\n5\n6\n7\n8\n9\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n0");

[ add return/cancel info
set.text.attribute(WHITE, BLACK);
display(22, 22, "Press <ESC> to return to control room");

[ set terminal colors (maybe use amber?)
set.text.attribute(GREEN, BLACK);

[ valid ID/PW
validID = "kw001";
validPW = "Temp123!";

[[display(TOPROW, LEFTCOL, "X");
[[display(TOPROW, RIGHTCOL, "X");
[[display(BTMROW, LEFTCOL, "X");
[[display(BTMROW, RIGHTCOL, "X");

:login
[ display welcome text
[                0123456789012345678901234567890123456789
display(5, 15,  "  *    *   *   ***    ****");
display(6, 15,  " * *   ** **  *   *  *");
display(7, 15,  "*****  * * *  *   *   ***");
display(8, 15,  "*   *  *   *  *   *      *");
display(9, 15,  "*   *  *   *   ***   ****");
display(11, 11, "AGI Mainframe Operating System v1.0");
display(12, 13, "  (c) 1986 Sierra Online, Inc.");
display(14, 9, "(Shift-Ctrl-Enter to reboot)");
[ position cursor after userid prompt
display(16, 9, "userid: ");
cursor_row = 16; 
cursor_col = 17;
cursor_char = 1;
display.v(cursor_row, cursor_col, cursor_char);
inputmode = IM_USERID;

[ if first time drawing welcom text, need to fade in
if (newRoom) {
  block(FADE.IN, 0, FADECOUNT, BLACK); [ fade.in(BYVAR, DELAY, COLOR)
  reset(newRoom);
}

[skip prompt for userid/pw
goto(getKey);

:getInput
[ reset input line
input = "";
[ add prompt
work1 = &promptmsg;
display.v(cursor_row, cursor_col, work1);
++cursor_col;

[ main character input loop
:getKey
[ flush the keybuffer
lastChar = 0;

if (!have.key()) {
  [ delay 25 msec
  work1 = 25;
  cycle.time(o254, work1); 

  [ toggle the cursor every 200 msec
  ++cursor_toggle;
  if (cursor_toggle > 9) {
    cursor_toggle = 0;
    cursor_char *= -1;
    cursor_char += 3; [ this toggles cursor msg num between 1 and 2
    display.v(cursor_row, cursor_col, cursor_char);
  }
  
  [ check for a key
  goto(getKey);
}

:haveKey
[ make sure cursor gets hidden
if (cursor_char == 1) {
  cursor_char = 2;
  display.v(cursor_row, cursor_col, cursor_char);
}

[ if ESC
if (lastChar == 27) {
  [ restore default (inputline) attritubutes
  set.text.attribute(0, -1);
  
  [ fade out
  block(FADE.OUT, 0, FADECOUNT, BLACK); [ fade.out(BYVAR, DELAY, COLOR)
  
  [ clear return instruction row
  clear.lines(22, 22, BLACK);
  
  [ go back to terminal roonm
  new.room(rm.ControlRoom); [ ##LE001##
}

[ CTRL+SHIFT+ENTER for reboot
if (lastChar == 10) {
  block(GET.SHIFTSTATE, &work1, 0, 0); [ get.shiftstate(vSTATE)
  if (work1 == 3 && inputmode == IM_CMDLINE) {
    [ TODO: add reboot code here
    output = "shutting down.";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    [ pause for a bit
    tmpCounter1 = 5;
    output = ".";
    :wait1
    terminalfn = DELAY;
    call(lgc.TerminalFunctions);
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    --tmpCounter1;
    if (tmpCounter1 > 0) {
      goto(wait1);
    }
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
    
    output = "rebooting.";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    [ pause for a bit
    tmpCounter1 = 8;
    output = ".";
    :wait2
    terminalfn = DELAY;
    call(lgc.TerminalFunctions);
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    --tmpCounter1;
    if (tmpCounter1 > 0) {
      goto(wait2);
    }
    [ clear the screen
    terminalfn = CLS;
    call(lgc.TerminalFunctions);
    
    [ show BIOS
    [ (draw directly; no need for functions since positions are known)
    display(4, 10, "\x1E");
    display(5, 9,"\x1E \x1E   AMT Mainframe BIOS v1.44b");

    [ memory check
    display(7, 12, "memory check: 0MB");
    work1 = 1;
    :wait3
    display(7, 26, "%v46MB");
    ++work1;
    work2 = 50;
    cycle.time(o254, work2); [ delay(vDELAY)
    if (work1 < 129) {
      goto(wait3);
    }
    display(7, 32, "- OK");
    cursor_row = 9;
    cursor_col = LEFTCOL;
    
    [ initialize/run AMOS
    [ init floppy drives, modem (stays error; no networking)
    [ switch to hard disk, c:, run AMOS bootstrap
    [ make note that all subsystems are reset, need to be
    [ reloaded/restarted
    
    [ MOCC is now reset, errors are gone
    set(resetMOCC);
    [ clear the screen
    terminalfn = CLS;
    call(lgc.TerminalFunctions);
    [ need login credentials
    inputmode = IM_USERID;
    goto(login);
  }
}

[ if ENTER or CTRL+ENTER
if ((lastChar == 13 || lastChar == 10)) {
  [ advance the inputline BEFORE processing
  terminalfn = LINEFEED;
  call(lgc.TerminalFunctions);
    
  [ parse the input
  parse(input);
    
  [ take appropriate action based on command and input mode
  if (inputmode == IM_USERID) {
    [ userid entered; get password
    block(STR.COPY, &input, &userid, 0); [ str.copy(sINPUT, sRESULT)
    inputmode = IM_PASSWORD;
    output = "password: ";
    terminalfn = ADDLINE;
    call(lgc.TerminalFunctions);
    [ get more input (no prompt)
    input = "";
    goto(getKey);
  }
  
  if (inputmode == IM_PASSWORD) {
    [ validate userid/password
    [ id is not case sensitive
    set.string(SET.CMPMODE, COMPARE_TEXT); [ set.cmpmode(mode);
    if (compare.strings(userid, validID)) {
      [ id is valid
      set(loggedon);
    }
    [ password is case sensitive
    set.string(SET.CMPMODE, COMPARE_BINARY); [ set.cmpmode(mode);
    if (!compare.strings(input, validPW)) {
      [ password is not valid
      reset(loggedon);
    }
    [ if valid continue
    if (loggedon) {
      inputmode = IM_CMDLINE;
      output = "logged on as kw001";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "access level: 1";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      terminalfn = LINEFEED;
      call(lgc.TerminalFunctions);
    } else {
      inputmode = IM_USERID;
      output = "invalid userid and/or password";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      [ position cursor after userid prompt
      output = "userid: ";
      terminalfn = ADDLINE;
      call(lgc.TerminalFunctions);
      [ get input, no prompt
      input = "";
      goto(getKey);
    }
    [ get more input
    goto(getInput);
  }
  
  if (inputmode == IM_CMDLINE) {
    [ deal with input
    if (said("help")) {
      [ show some help lines
      output = "available commands:";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "ASSOC         CHKDSK    DATE";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "ATTRIB        CLS       DEL";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      output = "CD/CHDIR      COPY       DIR";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
    }
  
    if (said("test")) {
      display(12, 40, "test msg - should go past 40 columns");
    }
    
    if (said("logoff")) {
      output = "wait...";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      [ clear the screen
      clear.text.rect(TOPROW, LEFTCOL, BTMROW, RIGHTCOL, BLACK);
      [ jump to login code
      goto(login);
    }
    
    if (said("reset", "BaDASS")) {
      set(resetBaDASS);
      output = "done";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
    }
    
    if (said("restart", "anyword")) {
      reset(haveMatch);
      reset(validmodule);
      [ check for correct system name/pw
      if (said("restart", "caisocc")) {
        set(enableCAISOCC);
        set(validmodule);  
      }
      if (said("restart", "randocc")) {
        set(enableRANDOCC);
        set(validmodule);  
      }
      if (said("restart", "icapocc")) {
        set(enableICAPOCC);
        set(validmodule);  
      }
      if (said("restart", "esadocc")) {
        set(enableESADOCC);
        set(validmodule);  
      }
      if (said("restart", "ofrocc")) {
        set(enableOFROCC);
        set(validmodule);  
      }
      if (said("restart", "eridocc")) {
        set(enableERIDOCC);
        set(validmodule);  
      }
      if (validmodule) {
        output = "  terminating process...";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        terminalfn = DELAY;
        call(lgc.TerminalFunctions);
        output = "  loading module %w2...";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        terminalfn = DELAY;
        call(lgc.TerminalFunctions);
        output = "  initializing...";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        terminalfn = DELAY;
        call(lgc.TerminalFunctions);
        output = "OK";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        reset(validmodule);
      } else {
        output = "syntax error - ";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
        output = "unknown module: %w2";
        terminalfn = ADDLINE_LF;
        call(lgc.TerminalFunctions);
      }
    }
    
    [ if input was not processed, display error
    if (!haveMatch) {
display(24, 0, "%w1, %w2, %w3, %w4");  
      [ display syntax error message
      output = "syntax error";
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
    }
    [ get more input
    goto(getInput);
  }
  
  [ args/extra input
  if (inputmode == IM_ARGINPUT) {
    [ tbd
    output = "accept input";
    terminalfn = ADDLINE_LF;
    call(lgc.TerminalFunctions);
      
    [ get more input
    goto(getInput);
  }
}

[ check for backspace
if (lastChar == 8) {
  [ get input length
  block(STR.LEN, &input, &work1, 0); [ str.len(sINPUT, vRESULT)
  [ if anything on the input line, backspace is allowed
  if (work1 > 0) {
    [ if not at left edge
    if (cursor_col > LEFTCOL) {
      [ back up one space
      --cursor_col;
    } else {
      [ if at left edge, go up one row to right edge
      --cursor_row;
      cursor_col = RIGHTCOL;
    }
    [ remove char from display (backspace char will erase it)
    display.v(cursor_row, cursor_col, cursor_char);
    
    [ remove the last char from the input line
    --work1;
    block(STR.LEFT, &input, &input, &work1); [ str.left(sINPUT, sRESULT, vLEN);
  }
} else {
  [ if any other char, add it to input
  block(BYTE2CHAR, &char, &lastChar, 0); [ byte2char(sRESULT, vCHAR);
  block(STR.CONCAT, &input, &char, 0); [ sINPUT, sADD);
  [ if in password mode, display an asterisk
  if (inputmode == IM_PASSWORD) {
    work1 = &m5;
  } else {
    work1 = &charmsg;
  }
  display.v(cursor_row, cursor_col, work1);
  
  [ advance cursor
  ++cursor_col;
  if (cursor_col > RIGHTCOL) {
    [ advance the inputline
    terminalfn = LINEFEED;
    call(lgc.TerminalFunctions);
  }
}
[ then get next keypress
goto(getKey);



[*****
:exit              [  test for leaving the room
[*****

[ add exit checks here (or use layout editor)
return();

[*****
[ messages         [  declared messages go here
[*****
#message 1 "_"
#message 2 " "
#message 3 "%s13"
#message 4 "%s14"
#message 5 "*"
#message 6 ">"