[ ********************************************************************[[ cp.Mouse[[ Emulated Rodent Input Device Option Control Console[ ERIDOCC[[ ********************************************************************#define oCursorB       o1  [ need four objects for cursor otherwise#define oCursorT       o2  [ text gets erased#define oCursorL       o3#define oCursorR       o4#define optCursor      o5#define cursorpos    v220#define newpos       v221#define    CP_MOUSE   1#define    CP_KEYB    2#define    CP_PREVIEW 3#define    CP_SAVE    4#define    CP_RESTORE 5#define    CP_EXPORT  5#define    CP_EXIT    6#define tmpRow       v222#define tmpCol       v223#define tmpVal       v224#define cursorX      v231#define cursorY      v232#define btnAction    v233#define    B_PREVIEW  1#define    B_SAVE     2#define    B_RESTORE  3#define    B_EXPORT   4#define    B_EXIT     5#define egoPrevX     v234#define egoPrevY     v235#define egoPrevDir   v236#define update       f220#define cursormode   f221#define refresh      f222 [ used to redraw text on screen when the screen is first displayed[ loop values assigned to objects#define LP_OPT      0#define LP_CUR_1    1#define LP_CUR_2    2#define LP_CUR_3    3#define LP_CUR_4    4if (newRoom)   {  [ this is the first cycle through this room  [ load, draw and discard the picture resource for the current room  load.pic(currentRoom);  draw.pic(currentRoom);  discard.pic(currentRoom);    call(lgc.RoomInit);    [ this view has all the art for cursors and buttons  load.view(vw.cp.MouseArt);  [ option button that determines input mode; mouse or keyboard  animate.obj(optCursor);  set.view(optCursor, vw.cp.MouseArt);  set.loop(optCursor, LP_OPT);  set.cel(optCursor, 0);  stop.cycling(optCursor);  position(optCursor, 8, 65);  draw(optCursor);    [ cursor is in four parts; used to highlight command buttons  [ and option buttons  animate.obj(oCursorB);  ignore.objs(oCursorB);  set.view(oCursorB, vw.cp.MouseArt);  set.loop(oCursorB, LP_CUR_1);  set.cel(oCursorB, 0);  stop.cycling(oCursorB);  position(oCursorB, 30, 65);    animate.obj(oCursorT);  ignore.objs(oCursorT);  set.view(oCursorT, vw.cp.MouseArt);  set.loop(oCursorT, LP_CUR_1);  set.cel(oCursorT, 0);  stop.cycling(oCursorT);  position(oCursorT, 30, 54);    animate.obj(oCursorL);  ignore.objs(oCursorL);  set.view(oCursorL, vw.cp.MouseArt);  set.loop(oCursorL, LP_CUR_1);  set.cel(oCursorL, 1);  stop.cycling(oCursorL);  position(oCursorL, 30, 64);    animate.obj(oCursorR);  ignore.objs(oCursorR);  set.view(oCursorR, vw.cp.MouseArt);  set.loop(oCursorR, LP_CUR_1);  set.cel(oCursorR, 1);  stop.cycling(oCursorR);  position(oCursorR, 47, 65);    cursorpos = 2;  newpos = 2;    [ no text input in this room  prevent.input();  lastChar = 0;  [ arrow keys control cursor here  egoDir = 0;    [ mouse is enabled, not cursor  enable.item(mouse);  reset(cursormode);  btnAction = 0;    [ set speed to fast for best mouse performance  animationInterval = 1;  [ buttons  [ 'save' to update cursor for a particular function  [ 'restore' to return a cursor to it's default  [ 'close/exit' to stop editing  [ 'test/preview' to load the cursor, and drive it around  [  (click anywhere to go back to editing)  [ ' export (use log feature)    [left click to set a pixel; right click to clear a pixel  [ should be able to do drag operations pretty easily  [  [    [ load ego view, animate and draw ego  [ this is sometimes handled in logic 0  [ instead of in each individual logic    [ cache ego movement parameters (to be restored  [ when returning to the control room)  egoPrevX = egoX;  egoPrevY = egoY;  egoPrevDir = egoDir;    [ set speed to fst for best mouse performance  animationInterval = 1;  [ need to show the pic before text can be added  show.pic();  }[ if room is being drawn or redrawn, need to add textif ((newRoom || refresh)) {  [ push display colors  set.text.attribute(-1, 0);    [ add button text  set.text.attribute(BLACK, WHITE);  display(12, 1, "Preview");  display(14, 1, " Save  ");  display(16, 1, "Restore");  display(18, 1, "Export ");  display(20, 1, " Exit  ");    set.text.attribute(BLACK, LT_GRAY);  display(6, 2, "  Cursor");  display(8, 4, "Ms");  display(8, 10, "Kb");    [ pop display colors  set.text.attribute(0, -1);    if (refresh) {    reset(refresh);    return();  }}[ is cursor in text mode?if (cursormode) {  [ check for direction arrow keypress  if (egoDir != STOPPED) {    [ cursor up    if (egoDir == UP) {    }        [ cursor right    if (egoDir == RIGHT) {    }        [ cursor down    if (egoDir == DOWN) {    }        [ cursor left    if (egoDir == LEFT) {    }        [ always reset dir so another keypress can be detected    egoDir = 0;        [ check for new cursor position    if (cursorpos != newpos) {      [ update the position      cursorpos = newpos;      [ depending on where cursor is, set the position and size/shape      [ option buttons      if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {        set.loop(oCursorB, LP_CUR_1);        set.loop(oCursorT, LP_CUR_1);        set.loop(oCursorL, LP_CUR_1);        set.loop(oCursorR, LP_CUR_1);                cursorY = 65;        if (cursorpos == CP_MOUSE) {          cursorX = 7;        } else {          cursorX = 31;        }      }            [ Preview, Save, Restore, Exit, Cancel buttons      if (cursorpos >= CP_PREVIEW && cursorpos <= CP_EXIT) {        set.loop(oCursorB, LP_CUR_2);        set.loop(oCursorT, LP_CUR_2);        set.loop(oCursorL, LP_CUR_2);        set.loop(oCursorR, LP_CUR_2);                cursorX = 3;        [ convert cursorpos into desired y value        cursorY = cursorpos;        cursorY -= 8;        cursorY *= 16;        cursorY += 128;      }            [ to move cursor, erase it first, otherwise, it will      [ clear any text that is present anywhere between the      [ new position and the old position      erase(oCursorB);      erase(oCursorL);      erase(oCursorT);      erase(oCursorR);            [ reposition the four-part cursor and       [ show it      position.v(oCursorB, cursorX, cursorY);      draw(oCursorB);      --cursorY;      [ save ypos to restore it later      work = cursorY;      position.v(oCursorL, cursorX, cursorY);      draw(oCursorL);      [ adjust for height (depends on button type)      if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {        cursorY -= 10;      }      if (cursorpos >= CP_PREVIEW && cursorpos <= CP_EXIT) {          cursorY -= 8;      }      position.v(oCursorT, cursorX, cursorY);      draw(oCursorT);      [ reset y      cursorY = work;      [ adjust for width      cursorX += 29;            position.v(oCursorR, cursorX, cursorY);      draw(oCursorR);    }  }    [ check for selection (space/enter for button)  if (have.key()) {    [ space/enter    if ((lastChar == 32 || lastChar == 13 || lastChar == 10)) {      if (cursorpos  == CP_MOUSE) {        [ switch to mouse control        reset(cursormode);        enable.item(mouse);        erase(optCursor);        position(optCursor, 8, 97);        draw(optCursor);        [ erase the cursor objects        erase(oCursorB);        erase(oCursorT);        erase(oCursorL);        erase(oCursorR);      }      if (cursorpos  >= CP_PREVIEW && cursorpos <= CP_EXIT) {        btnAction = cursorpos;        btnAction -= 2;      }    }  }} else {  [ mouse is active: check for mouse actions    [ check for mouse clicks  if (controller(cLeftClick)) {    [ over cursor type keyboard option     if (mouseX > 30 && mouseX < 38 && mouseY > 95 && mouseY < 104) {      [ switch to keyboard cursor      set(cursormode);      disable.item(mouse);      erase(optCursor);      position(optCursor, 32, 97);      draw(optCursor);      [ show the cursor object      cursorpos = 2;      newpos = 2;      position(oCursorB, 31, 97);      draw(oCursorB);      position(oCursorT, 31, 86);      draw(oCursorT);      position(oCursorL, 31, 96);      draw(oCursorL);      position(oCursorR, 48, 96);      draw(oCursorR);    }    [ over PREVIEW button [2, 102 - 33, 129] (need to add 8 to y due to pic offset)    if (mouseX > 2 && mouseX < 33 && mouseY > 94 && mouseY < 105) {      btnAction = B_PREVIEW;    }          [ over SAVE button [2, 102 - 33, 113] (need to add 8 to y due to pic offset)    if (mouseX > 2 && mouseX < 33 && mouseY > 110 && mouseY < 121) {      btnAction = B_SAVE;    }          [ over RESTORE button [2, 118 - 33, 129] (need to add 8 to y due to pic offset)    if (mouseX > 2 && mouseX < 33 && mouseY > 126 && mouseY < 137) {      btnAction = B_RESTORE;    }          [ over EXPORT button [2, 134 - 33, 145]    if (mouseX > 2 && mouseX < 33 && mouseY > 142 && mouseY < 153) {      btnAction = B_EXPORT;    }        [ over EXIT button [2, 150 - 33, 161]    if (mouseX > 2 && mouseX < 33 && mouseY > 158 && mouseY < 169) {      btnAction = B_EXIT;    }  }}[ check for button actionif (btnAction == B_EXIT) {    [ restore ego movement parameters  egoX = egoPrevX;  egoY = egoPrevY;  egoDir = egoPrevDir;    [restore speed  animationInterval = NORMAL_SPEED;    [ go back to previous room  new.room.v(previousRoom); }if (btnAction == B_PREVIEW) {}if (btnAction == B_SAVE) {  }if (btnAction == B_RESTORE) {  }if (btnAction == B_EXPORT) {  }[ always reset button actionbtnAction = 0;  return();[*****[ messages         [  declared messages go here[*****#message 1 "" 