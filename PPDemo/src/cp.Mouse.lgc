[ ********************************************************************[[ cp.Mouse[[ Emulated Rodent Input Device Option Control Console[ ERIDOCC[[ ********************************************************************#define oCursorB       o1  [ need four objects for cursor otherwise#define oCursorT       o2  [ text gets erased#define oCursorL       o3#define oCursorR       o4#define optCursor      o5#define gridCursor     o6#define cursorpos    v220#define newpos       v221#define    CP_MOUSE   1#define    CP_KEYB    2#define    CP_IDX_DN  3#define    CP_IDX_UP  4#define    CP_PREVIEW 5#define    CP_SAVE    6#define    CP_RESTORE 7#define    CP_EXPORT  8#define    CP_EXIT    9#define    CP_GRID   10#define gridX        v222#define gridY        v223#define gridmode     v224#define tmpX         v225#define tmpY         v226#define cursorX      v231#define cursorY      v232#define btnAction    v233#define    B_IDX_UP   1#define    B_IDX_DN   2#define    B_PREVIEW  3#define    B_SAVE     4#define    B_RESTORE  5#define    B_EXPORT   6#define    B_EXIT     7#define egoPrevX     v234#define egoPrevY     v235#define egoPrevDir   v236#define update       f220#define cursormode   f221#define refresh      f222 [ used to redraw text on screen when the screen is first displayed#define updategrid   f223#define fOnGrid      f224#define fChgCursor   f225#define tmpFlag      f226#define sCursor       s12 [ uses s12, s13, s14, s15[ loop values assigned to objects#define LP_OPT      0#define LP_CUR_1    1#define LP_CUR_2    2#define LP_CUR_3    3#define LP_CUR_4    4#define LP_CUR_5    5if (newRoom) {  [ this is the first cycle through this room  [ load, draw and discard the picture resource for the current room  load.pic(currentRoom);  draw.pic(currentRoom);  discard.pic(currentRoom);    call(lgc.RoomInit);    [ this view has all the art for cursors and buttons  load.view(vw.cp.MouseArt);  [ option button that determines input mode; mouse or keyboard  animate.obj(optCursor);  set.view(optCursor, vw.cp.MouseArt);  set.loop(optCursor, LP_OPT);  set.cel(optCursor, 0);  stop.cycling(optCursor);  position(optCursor, 8, 65);  draw(optCursor);    [ cursor is in four parts; used to highlight command buttons  [ and option buttons  animate.obj(oCursorB);  ignore.objs(oCursorB);  set.view(oCursorB, vw.cp.MouseArt);  set.loop(oCursorB, LP_CUR_1);  set.cel(oCursorB, 0);  stop.cycling(oCursorB);  position(oCursorB, 30, 65);    animate.obj(oCursorT);  ignore.objs(oCursorT);  set.view(oCursorT, vw.cp.MouseArt);  set.loop(oCursorT, LP_CUR_1);  set.cel(oCursorT, 0);  stop.cycling(oCursorT);  position(oCursorT, 30, 54);    animate.obj(oCursorL);  ignore.objs(oCursorL);  set.view(oCursorL, vw.cp.MouseArt);  set.loop(oCursorL, LP_CUR_1);  set.cel(oCursorL, 1);  stop.cycling(oCursorL);  position(oCursorL, 30, 64);    animate.obj(oCursorR);  ignore.objs(oCursorR);  set.view(oCursorR, vw.cp.MouseArt);  set.loop(oCursorR, LP_CUR_1);  set.cel(oCursorR, 1);  stop.cycling(oCursorR);  position(oCursorR, 47, 65);    cursorpos = 2;  newpos = 2;    [ grid cursor object  animate.obj(gridCursor);  position(gridCursor, 57, 74);  set.view(gridCursor, vw.cp.MouseArt);  set.loop(gridCursor, LP_CUR_5);  work = 2;  cycle.time(gridCursor, work);    [ no text input in this room  prevent.input();  lastChar = 0;  [ arrow keys control cursor here  egoDir = 0;    [ mouse is enabled, not cursor  enable.item(mouse);  reset(cursormode);  btnAction = 0;    [ buttons  [ 'save' to update cursor for a particular function  [ 'restore' to return a cursor to it's default  [ 'close/exit' to stop editing  [ 'test/preview' to load the cursor, and drive it around  [  (click anywhere to go back to editing)  [ ' export (use log feature)    [ cursors:  [  - normal  [  - walk  [  - look  [  - use  [  - talk    [left click to set a pixel; right click to clear a pixel  [ should be able to do drag operations pretty easily  [  [    [ load ego view, animate and draw ego  [ this is sometimes handled in logic 0  [ instead of in each individual logic    [ cache ego movement parameters (to be restored  [ when returning to the control room)  egoPrevX = egoX;  egoPrevY = egoY;  egoPrevDir = egoDir;    [ set speed to fst for best mouse performance  animationInterval = 1;  [ need to show the pic before text can be added  show.pic();}[ if room is being drawn or redrawn, need to add textif ((newRoom || refresh)) {  [ push display colors  set.text.attribute(-1, 0);    [ add button text  set.text.attribute(BLACK, WHITE);  display(12, 1, "Preview");  display(14, 1, " Save  ");  display(16, 1, "Restore");  display(18, 1, "Export ");  display(20, 1, " Exit  ");  display(7, 22, "\x11");  display(7, 32, "\x10");    set.text.attribute(BLACK, LT_GRAY);  display(6, 2, "   Mode");  display(8, 4, "Ms");  display(8, 10, "Kb");    display(6, 24, "CURSOR:");  [ default cursor starts  display(7, 24, "default");[  display(7, 22, " walk  ");[  display(7, 22, " talk  ");[  display(7, 22, "  use  ");    [ pop display colors  set.text.attribute(0, -1);    if (refresh) {    reset(refresh);    return();  }}[ is cursor in text mode?if (cursormode) {  [ check for direction arrow keypress  if (egoDir != STOPPED) {    [ cursor up    if (egoDir == UP) {      if (cursorpos == CP_PREVIEW) {        newpos = CP_MOUSE;      }      if (cursorpos > CP_PREVIEW && cursorpos <= CP_EXIT) {        --newpos;      }      if (cursorpos == CP_GRID) {        if (gridY == 0) {          if (gridmode == 0) {            newpos = CP_IDX_DN;          } else {            newpos = CP_IDX_UP;          }        } else {          --gridY;          set(updateGrid);        }      }    }        [ cursor right    if (egoDir == RIGHT) {      if (cursorpos < CP_IDX_UP) {        ++newpos;      }      if (cursorpos > CP_IDX_UP && cursorpos < CP_GRID) {        newpos = CP_GRID;        gridmode = 0;        gridX = 0;        gridY = cursorpos;        gridY -= 5;        gridY *= 11;        gridY /= 4;        gridY += 3;        set(updateGrid);      }              if (cursorpos == CP_GRID) {        if (gridmode == 0) {          ++gridX;          if (gridX == 16) {            gridmode = 1;            gridX = 0;          }          set(updategrid);        } else {          if (gridX < 15) {            ++gridX;            set(updategrid);          }        }      }    } [ right        [ cursor down    if (egoDir == DOWN) {      if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {        newpos = CP_PREVIEW;      }            if (cursorpos == CP_IDX_DN) {        newpos = CP_GRID;        gridmode = 0;        gridX = 10;        gridY = 0;        set(updategrid);      }      if (cursorpos == CP_IDX_UP) {        newpos = CP_GRID;        gridmode = 1;        gridX = 6;        gridY = 0;        set(updategrid);      }            if (cursorpos > CP_IDX_UP && cursorpos < CP_EXIT) {        ++newpos;      }            if (cursorpos == CP_GRID) {        if (gridY < 15) {          ++gridY;          set(updategrid);        }      }    } [ down        [ cursor left    if (egoDir == LEFT) {      if (cursorpos > CP_MOUSE && cursorpos < CP_PREVIEW) {        --newpos;      }            if (cursorpos == CP_GRID) {        if (gridmode == 0) {          if (gridX > 0) {            --gridX;            set(updategrid);          } else {            if (gridY < 4) {              newpos = CP_PREVIEW;            } else {              if (gridY < 6) {                newpos = CP_SAVE;              } else {                if (gridY < 9) {                  newpos = CP_RESTORE;                } else {                  if (gridY < 12) {                    newpos = CP_EXPORT;                  } else {                    newpos = CP_EXIT;                  }                }              }            }          }        } else {          if (gridX > 0) {            --gridX;          } else {            gridmode = 0;            gridX = 15;          }          set(updategrid);        }      } [ grid    } [ left        [ always reset dir so another keypress can be detected    egoDir = 0;        [ check for new cursor position    if (cursorpos != newpos) {      [ update the position      cursorpos = newpos;      [ depending on where cursor is, set the position and size/shape      [ option buttons      if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {        set.loop(oCursorB, LP_CUR_1);        set.loop(oCursorT, LP_CUR_1);        set.loop(oCursorL, LP_CUR_1);        set.loop(oCursorR, LP_CUR_1);                cursorY = 65;        if (cursorpos == CP_MOUSE) {          cursorX = 7;        } else {          cursorX = 31;        }      }            [ index up/down buttons      if ((cursorpos == CP_IDX_DN || cursorpos == CP_IDX_UP)) {        set.loop(oCursorB, LP_CUR_4);        set.loop(oCursorT, LP_CUR_4);        set.loop(oCursorL, LP_CUR_4);        set.loop(oCursorR, LP_CUR_4);        cursorY = 56;        cursorX = cursorpos;        cursorX -= 3;        cursorX *= 40;        cursorX += 87;      }            [ Preview, Save, Restore, Exit, Cancel buttons      if (cursorpos >= CP_PREVIEW && cursorpos <= CP_EXIT) {        set.loop(oCursorB, LP_CUR_2);        set.loop(oCursorT, LP_CUR_2);        set.loop(oCursorL, LP_CUR_2);        set.loop(oCursorR, LP_CUR_2);                cursorX = 3;        [ convert cursorpos into desired y value        cursorY = cursorpos;        cursorY -= 5;        cursorY *= 16;        cursorY += 96;      }            [ to move cursor, erase it first, otherwise, it will      [ clear any text that is present anywhere between the      [ new position and the old position      erase(oCursorB);      erase(oCursorL);      erase(oCursorT);      erase(oCursorR);            [ if not on grid, draw the button cursor      if (cursorpos != CP_GRID) {        [ no grid cursor        erase(gridCursor);                [ reposition the four-part cursor and show it        position.v(oCursorB, cursorX, cursorY);        draw(oCursorB);        --cursorY;        [ save ypos to restore it later        work = cursorY;        position.v(oCursorL, cursorX, cursorY);        draw(oCursorL);        [ adjust for height (depends on button type)        if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {          cursorY -= 10;        }        if ((cursorpos == CP_IDX_DN || cursorpos == CP_IDX_UP)){          cursorY -= 8;        }        if (cursorpos >= CP_PREVIEW && cursorpos <= CP_EXIT) {            cursorY -= 8;        }        position.v(oCursorT, cursorX, cursorY);        draw(oCursorT);        [ reset y        cursorY = work;        [ adjust for width        if (cursorpos < CP_IDX_DN) {          cursorX += 17;        }         if ((cursorpos == CP_IDX_DN || cursorpos == CP_IDX_UP)) {          cursorX += 5;        }        if (cursorpos > CP_IDX_UP) {          cursorX += 29;        }        position.v(oCursorR, cursorX, cursorY);        draw(oCursorR);      } else {        [ draw the grid cursor        draw(gridCursor);      }    }        [ did grid cursor move?    if (updategrid) {      reset(updategrid);      tmpX = gridX;      tmpX *= 3;      tmpX += 57;      if (gridmode == 1) {        tmpX += 53;      }      tmpY = gridY;      tmpY *= 6;      tmpY += 74;      reposition.to.v(gridcursor, tmpX, tmpY);    }  }    [ check for selection (space/enter for button)  if (have.key()) {    [ space/enter    if ((lastChar == 32 || lastChar == 13 || lastChar == 10)) {      [      if (cursorpos  == CP_MOUSE) {        [ switch to mouse control        reset(cursormode);        enable.item(mouse);        erase(optCursor);        position(optCursor, 8, 65);        draw(optCursor);        [ erase the cursor objects        erase(oCursorB);        erase(oCursorT);        erase(oCursorL);        erase(oCursorR);      }            if (cursorpos  >= CP_PREVIEW && cursorpos <= CP_EXIT) {        btnAction = cursorpos;        btnAction -= 2;      }    }  }} else {  [ mouse is active    [ show correct cursor based on mouse position  reset(tmpFlag);  [ adjust yval for offset  if (mouseX > 56 && mouseX < 105 && mouseY > 76 && mouseY < 173) {    set(tmpFlag);  }  if (mouseX > 109 && mouseX < 158 && mouseY > 76 && mouseY < 173) {    set(tmpFlag);  }  if (tmpFlag) {      if (!fOnGrid) {      set(fChgCursor);      set(fOnGrid);    }  }  else {    if (fOnGrid) {      set(fChgCursor);      reset(fOnGrid);    }  }    if (fChgCursor) {    reset(fChgCursor);    if (fOnGrid) {      sCursor = "%m1";    }    else {      sCursor = "%g40";    }    set.key(-1, -1, c2);  }    [ check for mouse clicks  if (controller(cLeftClick)) {    [ over cursor type keyboard option  54-65    if (mouseX > 30 && mouseX < 38 && mouseY > 63 && mouseY < 72) {      [ switch to keyboard cursor      set(cursormode);      disable.item(mouse);      erase(optCursor);      position(optCursor, 32, 65);      draw(optCursor);      [ show the cursor object      cursorpos = 2;      newpos = 2;      position(oCursorB, 31, 65);      draw(oCursorB);      position(oCursorT, 31, 54);      draw(oCursorT);      position(oCursorL, 31, 64);      draw(oCursorL);      position(oCursorR, 48, 64);      draw(oCursorR);    }    [ over PREVIEW button [2, 102 - 33, 129] (need to add 8 to y due to pic offset)    if (mouseX > 2 && mouseX < 33 && mouseY > 94 && mouseY < 105) {      btnAction = B_PREVIEW;    }          [ over SAVE button [2, 102 - 33, 113] (need to add 8 to y due to pic offset)    if (mouseX > 2 && mouseX < 33 && mouseY > 110 && mouseY < 121) {      btnAction = B_SAVE;    }          [ over RESTORE button [2, 118 - 33, 129] (need to add 8 to y due to pic offset)    if (mouseX > 2 && mouseX < 33 && mouseY > 126 && mouseY < 137) {      btnAction = B_RESTORE;    }          [ over EXPORT button [2, 134 - 33, 145]    if (mouseX > 2 && mouseX < 33 && mouseY > 142 && mouseY < 153) {      btnAction = B_EXPORT;    }        [ over EXIT button [2, 150 - 33, 161]    if (mouseX > 2 && mouseX < 33 && mouseY > 158 && mouseY < 169) {      btnAction = B_EXIT;    }  }}[ check for button actionif (btnAction == B_EXIT) {    [ restore ego movement parameters  egoX = egoPrevX;  egoY = egoPrevY;  egoDir = egoPrevDir;    [restore speed  animationInterval = NORMAL_SPEED;    [ go back to previous room  new.room.v(previousRoom); }if (btnAction == B_PREVIEW) {}if (btnAction == B_SAVE) {  }if (btnAction == B_RESTORE) {  }if (btnAction == B_EXPORT) {  }[ always reset button actionbtnAction = 0;  return();[*****[ messages         [  declared messages go here[*****#message 1 "07077FFE3FFC3FFC3FFC3FFC3FFC01808001800101803FFC3FFC3FFC3FFC3FFC7FFE"           "0000800180018001800180018001FE7FFE7F8001800180018001800180010000"#message 2 "%s12"