[ ********************************************************************
[
[ lgc.Main: Main logic
[
[ This logic runs in every interpreter cycle and calls
[ other logics as needed.
[
[
[ To better manage variables and flags, they are 
[ grouped into reserved, global, local, and dynamic:
[
[ reserved = reserved by the interpreter 
[     v0 - v26
[     f0 - f16, f20
[     s0, s1
[
[ global = usable and accessible by all logics
[     v27 - v219
[     f17 - f18, f21 - f219
[     s2 - s11
[
[ local = usable and accessible by single room
[     v220 - v239
[     f220 - f239
[     s12 - s19
[
[ dynamic = usable and accesible by a non-room logic
[     v240 - v255
[     f240 - f255
[     s20 - s23
[
[ Local and dynamic variables/flags are reset whenever a new room is
[ loaded.
[

[ ********************************************************************

[**** BEGIN DEBUG CODE
[:wait
[if (!have.key()) {
[  goto(wait);
[}
[print("char: %v19");
[lastChar = 0;
[goto(wait);
[**** END DEBUG CODE

[ **************************************
[ LOCAL DEFINES
[ **************************************
#define rndNum                     v255

#define mnu_msgUseItem              m1
#define mnu_msgSndToggle            m2
#define mnu_msgSoundPC              m3
#define mnu_msgSoundFM              m4
#define mnu_msgSoundMIDI            m5
#define mnu_msgClockToggle          m6
#define mnu_msgGameTime             m7
#define mnu_msgRealTime             m8
#define mnu_msgSpeed                m9
#define mnu_msgSpeedSlow           m10
#define mnu_msgSpeedNorm           m11
#define mnu_msgSpeedFast           m12
#define mnu_msgSpeedFastest        m13

[ **************************************
[ ERROR CHECK
[ **************************************

[ if one of the few trappable errors in AGI is encountered, the game
[ is probably not able to continue; make an announcement to the player
[ and quit
if (errorNumber > 0) {
  block(FADE.IN, 0, 0, BLACK); [ fade.in(BYVAR, DELAY, COLOR)
  call(lgc.Error); 
}

[ **************************************
[ GAME START
[ **************************************
[ when game begins, or restarts, there are a number
[ of setup activities to take care of
if (currentRoom == 0) {
  [ when the game starts, the current room is zero, so all the
  [ setup/initialization code goes here
  [
  [ restarting a game also sets currentRoom to zero, and also
  [ requires most of the same setup/initialization steps

  if (!gameRestarted) { 
    [ confirm platform is PC
    if (machineType != PC) {
      load.logics(lgc.Error);
      print("%l97|33");
      quit(1);
    }
          
    [ run the powerpack mod BEFORE DOING ANYTHING ELSE
    call(lgc.Version2Check);
    if (!IntVersion) {
      load.logics(lgc.Error);
      print("%l97|34");
      quit(1);
    }
    if ((IntVersion == VERSION_2089 || IntVersion == VERSION_2272)) {
      [ these versions not supported
      load.logics(lgc.Error);
      print("%l97|35");
      quit(1);
    }
    if (IntVersion == VERSION_2411) {
      call(lgc.mod2411);
      goto(continue);
    }
    if (IntVersion == VERSION_2425) {
      call(lgc.mod2425);
      goto(continue);
    }
    if (IntVersion == VERSION_2426) {
      call(lgc.mod2426);
      goto(continue);
    }
    if (IntVersion == VERSION_2435) {
      call(lgc.mod2435);
      goto(continue);
    }
    if (IntVersion == VERSION_2439) {
      call(lgc.mod2439);
      goto(continue);
    }
    if (IntVersion == VERSION_2440) {
      call(lgc.mod2440);
      goto(continue);
    }
    if (IntVersion == VERSION_2903) {
      call(lgc.mod2903);
      goto(continue);
    }
    if (IntVersion == VERSION_2911) {
      call(lgc.mod2911);
      goto(continue);
    }
    if (IntVersion == VERSION_2912) {
      call(lgc.mod2912);
      goto(continue);
    }
    if (IntVersion == VERSION_2915) {
      call(lgc.mod2915);
      goto(continue);
    }
    if (IntVersion == VERSION_2917) {
      call(lgc.mod2917);
      goto(continue);
    }
    if (IntVersion == VERSION_2936) {
      call(lgc.mod2936);
      goto(continue);
    }
    :continue
    
    [ confirm video, sound and mouse settings
    if (monitorType != EGA) {
      load.logics(lgc.Error);
      print("%l97|36");
      quit(1);
    }
    if (!enableDblClick) {
      load.logics(lgc.Error);
      print("%l97|37");
      quit(1);
    }
    if (numberOfVoices != 4) {
      load.logics(lgc.Error);
      print("%l97|38");
      quit(1);
    }
  }

[set.text.attribute(BLACK, WHITE);
[display(1,1,"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F");
[display(2,1,"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F");
[display(3,1,"\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF");
[display(4,1,"\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF");
[display(5,1,"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF");
[display(6,1,"\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF");
[display(7,1,"\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF");
[display(8,1,"\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF");
[print.at("pause",13,5,30);
[quit(1);

  [ do start/restart initialization activities
  call(lgc.Init);       [ this sets up the game; assigns key controllers,
                        [ configures the screen and other startup activities
  
  [ some start/restart actions have to be done within logic0
  if (gameRestarted) {
    [ make sure speed menu is enabled
    s23 = m14; [ "Speed"
    block(SET.MSG, 0, &mnu_msgSpeed, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
    [ go to first room here (skip Intro)
    new.room(rm.ParkingLot);
  } else {
    [ if NOT restarting (meaning this is very beginning, need to create 
    [ the menu; it can't be done in lgc.Init, it MUST be done from within 
    [ logic 0, so do that before going to start room
    set.menu("PPDemo");
    set.menu.item("About           ", cAbout);
    set.menu.item("Version  <Alt-V>", cVersion);
    set.menu.item("Help        <F1>", cHelp);
[    set.menu.item("Skip Intro      ", cIntro);
    set.menu("File");
    set.menu.item("Save     <F5>", cSave);
    set.menu.item("Restore  <F7>", cRestore);
    set.menu.item("컴컴컴컴컴컴", cDummy);
    set.menu.item("Restart  <F9>", cRestart);
    set.menu.item("Quit  <Alt-Z>", cQuit);
    set.menu("Action");
    set.menu.item("Inventory    <Tab>", cStatus);
    set.menu.item(mnu_msgUseItem, cChooseItem); [ "Examine Item  <F4>"
    set.menu("Sound");
    set.menu.item(mnu_msgSndToggle, cToggleSound); [ "Sound: On   <F2>"
    set.menu.item("Quieter         ", cDecrescendo);
    set.menu.item("Louder          ", cCrescendo);
    set.menu.item("컴컴컴컴컴컴컴컴", cDummy);
    set.menu.item(mnu_msgSoundPC, cSoundPC);    [ " PC Speaker     "
    set.menu.item(mnu_msgSoundFM, cSoundFM);    [ " FM Synth       "
    set.menu.item(mnu_msgSoundMIDI, cSoundMIDI);  [ " MIDI           "
    set.menu("Time");
    set.menu.item(mnu_msgClockToggle, cClock);  [ "Clock: Off  <F6>"
    set.menu.item(mnu_msgGameTime, cGameClock); [ " Game Time      "
    set.menu.item(mnu_msgRealTime, cRealClock); [ " Real Time      "
    set.menu.item("컴컴컴컴컴컴컴컴", cDummy);
    set.menu.item("Pause      <Esc>", cPause);
    set.menu(mnu_msgSpeed);  [ "Speed"
    set.menu.item( "Slower  ", cSlower);
    set.menu.item( "Faster  ", cFaster);
    set.menu.item( "컴컴컴컴", cDummy);
    set.menu.item(mnu_msgSpeedSlow, cSlow); [ " Slow   "
    set.menu.item(mnu_msgSpeedNorm, cNormal); [ " Normal "
    set.menu.item(mnu_msgSpeedFast, cFast); [ " Fast   "
    set.menu.item(mnu_msgSpeedFastest, cFastest); [ " Fastest"
    
[ temporary debug items
set.menu("Debug");
set.menu.item(m38, cLogInput);   [ "Log Input:      Off"
set.menu.item(m39, cShowClicks); [ "Display Clicks: Off"

    [ submit the menu (which makes it ready to use)
    submit.menu();
    [ disable the separator lines
    disable.item(cDummy);
    
    [ start the game with the title screen
    new.room(rm.Title);
  }
}

[ **************************************
[ NEW ROOM
[ **************************************
if (newRoom) {
  [ First interpreter cycle in a new room
  [ Note: Everything other than logic 0 is discarded
  [ from memory when new.room is executed

  [ do basic room initialization
  call(lgc.RoomInit);
  
  if (!disableGameFunctions) {
    [ Load game specific functions logic into memory
    load.logics(lgc.GameFunctions);
    [ also toolbar functions
    load.logics(lgc.ToolbarFunctions);
    load.logics(lgc.UseItem);
  }
  [ if debugging is active
  if (debugging) {
    [ load debug logic into memory
    load.logics(lgc.Debug);
  }
  [ score handler (to allow score to go below zero)
  load.logics(lgc.ScoreHandler);
  
  [ always animate ego object when starting a new room
  animate.obj(ego);
  [ load and set view
  [ (for more complex games, this will probably need 
  [ to be moved into each room's logic)
  if (currentRoom > 2 && currentRoom < 11) {
    load.view(vw.Ego);
    set.view(ego, vw.Ego);
  }
  [ force clock value to update, if time is visible
  clearStatusSeconds = -1; 
  
  [ check for closet door being left open
  if (closetopen && !closetTimerStart && currentRoom != rm.Hallway && 
      currentRoom != rm.Closet && currentRoom != rm.SecretRoom) {
    [ start a fresh timer
    set(closetTimerStart);
    timerMin = 0; [4;
    timerSec = 20; [0;
    block(START.TIMER, &timerMin, &timerSec, &closetTimerDone); [ start.timer(vMINUTES, vSECONDS, fDONE)
  } else {
    if (closetTimerStart) {
      [ stop the timer
      reset(closetTimerStart);
      block(TOGGLE.TIMER, 0, 0, 0); [ toggle.timer(STATE)
    }
  }
  
  [ if cassette is playing (loaded and not paused or at end of side)
  if (cassetteLoaded && currentTrack > 0 && currentTrack < 128) {
    [ skip to next track
    ++currentTrack;
    [ if side is done
    if ((currentTrack == 43 || currentTrack == 85)) {
      [ stop the tape
      currentTrack = 0;
    }
  }
}

[ **************************************
[ EVERY CYCLE
[ **************************************

[ check for click-resets when coming from cutscenes
if (resetClicks) {
  reset(resetClicks);
  set.key(-1, -1, cLeftClick); [ clear.controller(cNUM)
}

[**** BEGIN DEBUG CODE
if (controller(cLogInput)) {
  [ toggle the message
  toggle(fLogInput);
  s23 = "Log Input:      %s22";
  if (fLogInput) {
    s22 = " On";    
  } else {
    s22 = "Off";
  }
  block(STR.FORMAT, &s23, &s23, 0); [ str.format(sINPUT, sRESULT)
  block(SET.MSG, 0, &m38, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
}
[ show click data
if (controller(cShowClicks)) {
  [ toggle the message
  toggle(fShowClicks);
  s23 = "Display Clicks: %s22";
  if (fShowClicks) {
    s22 = " On";
  } else {
    s22 = "Off";
  }
  block(STR.FORMAT, &s23, &s23, 0); [ str.format(sINPUT, sRESULT)
  block(SET.MSG, 0, &m39, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
}
if (fShowClicks) {
  [ used to assist in creating click statements and said statements
  if (controller(cLeftClick)  && currentRoom != 12 && currentRoom != 13) {
    get.posn(ego, work1, work2);
    display(4, 1, "left click: (%v27, %v28)  ego pos:  (%v46, %v47)        ");
  }
  [[ show the open closet door timer
  [ display(24, 0, "%v79|2:%v80|2");
  [ show remaining available memory
  display(24, 0, "mem pages: %v8  ");
}
if (fLogInput) {
  if (haveInput) {
    if (unknownWordNum > 0) {
      log("unknown word: %v9");
    } else {
      log("");
    }
  }
}
if (said("test", "get")) {
  get.num("add to score: ", work1);
  call(lgc.ScoreHandler);
}
if (said("test", "drop")) {
  get.num("sub from score: ", work1);
  work1 *= -1;
  call(lgc.ScoreHandler);
}
[**** END DEBUG CODE

[ MENU AND STATUS BAR CHECKS
if (!disableGameFunctions) {
  [ this trick makes it easy to test for
  [ 'if (controller(cLeftClick) && y > 247) || controller(cMenu)'
  if (!controller(cMenu) && (!controller(cLeftClick) || mouseY < 248)) {
  } else {   
    [ check for click on sound bar (but no controller)
    if (mouseX > 137 && !controller(cMenu)) {
      [ only in non-PC modes
      if (musicmode != PC_SOUND) {
        [ adjust sound volume based on clicked position
        work1 = mouseX;
        work1 -= 138; [ 0-21
        if (work1 >= 18) {
          [ set to max vol
          set(soundOn);
          work1 = 0;
        } else { [ 0-17
          if (work1 <= 2) {
            [ sound at minimum volume
            work1 = 63;
          } else { [ 3-17
            set(soundOn);
            [ calculate new sound attenuations from clicked value
            work1 *= -1;
            work1 += 18;  [15-1
            work1 *= 4;
          }
        }
        if (attenuation != work1) {
          [ update the config file
          attenuation = work1;
          call(lgc.SaveOptions);
        }
      }
      return();
    }
    [ if not on sound bar, show menu
    menu.input();
    oldSeconds = -1;
    [ reset click event
    set.key(-1, -1, cLeftClick); [ clear.controller(cNUM)
    
    [ refresh dynamic menu items
    [ inventory menu item
    if (deathType < 254) {
      if (cursormode == C_USE) {
        [ enable 'use item'
        enable.item(cChooseItem);
        s23 = m16;
        block(SET.MSG, 0, &mnu_msgUseItem, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
      } else {
        [ enable 'look item' for all other cursors
        enable.item(cChooseItem);
        s23 = m15;
        block(SET.MSG, 0, &mnu_msgUseItem, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
      }
    } else {
      [ not enabled if dead
      disable.item(cChooseItem);
    }
    
    [ sound toggle and mode
    if (soundOn) {
      s23 = "On ";
      enable.item(cSoundPC);
      enable.item(cSoundFM);
      enable.item(cSoundMIDI);
      if (4channelSound) {
        work1 = 62;
      } else {
        work1 = 14;
      }
      if (attenuation > work1) {
        disable.item(cDecrescendo);
      } else {
        enable.item(cDecrescendo);
      }
      if (attenuation == 0) {
        disable.item(cCrescendo);
      } else {
        enable.item(cCrescendo);
      }
    } else {
      s23 = "Off";
      disable.item(cSoundPC);
      disable.item(cSoundFM);
      disable.item(cSoundMIDI);
      disable.item(cCrescendo);
      disable.item(cDecrescendo);
    }
    s22 = "Sound: %s23  <F2>";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSndToggle, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
  
    [ check the correct sound option, uncheck the rest
    if (musicMode == PC_SOUND) {
      s23 = "\x10";
    } else {
      s23 = " ";
    }
    s22 = "%s23PC Speaker     ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSoundPC, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    
    if (musicMode == FM_SOUND) {
      s23 = "\x10";
    } else {
      s23 = " ";
    }
    s22 = "%s23FM Synth       ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSoundFM, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    
    if (musicMode == MIDI_SOUND) {
      s23 = "\x10";
    } else {
      s23 = " ";
    }
    s22 = "%s23MIDI           ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSoundMIDI, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)

    [ clock toggle and mode
    if (clockOn) {
      s23 = "On ";
      enable.item(cGameClock);
      enable.item(cRealClock);
    } else {
      s23 = "Off";
      disable.item(cGameClock);
      disable.item(cRealClock);
    }
    s22 = "Clock: %s23  <F6>"; 
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgClockToggle, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    if (realClock) {
      s21 = " ";
      s23 = "\x10";
    } else {
      s21 = "\x10";
      s23 = " ";
    }
    s22 = "%s21Game Time      ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgGameTime, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    s22 = "%s23Real Time      ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgRealTime, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)

    [ speed menu not available when dead
    s23 = mnu_msgSpeed;
    block(STR.LEN, &s23, &work1, 0); [ str.len(sINPUT, vRESULT)
    if (work1 == 0 && deathType != 254) {
      s23 = m14; [ "Speed"
      block(SET.MSG, 0, &mnu_msgSpeed, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
    }
    if (work1 !=0 && deathType == 254) {
      s23 = "";
      block(SET.MSG, 0, &mnu_msgSpeed, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
    }
    [ speed mode
    if (animationInterval == SLOW_SPEED) {
      disable.item(cSlower);
    } else {
      enable.item(cSlower);
    }
    if (animationInterval == FASTEST_SPEED) {
      disable.item(cFaster);
    } else {
      enable.item(cFaster);
    }
    [ slow (12) is 9 - 12
    if (animationInterval > 8) {
      s23 = "\x10";
    } else {
      s23 = " ";
    } 
    s22 = "%s23Slow   ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSpeedSlow, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    [ normal (6) is 5 - 8
    if (animationInterval > 4 && animationInterval < 9) {
      s23 = "\x10";
    } else {
      s23 = " ";
    }
    s22 = "%s23Normal ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSpeedNorm, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    [ fast (3) is 1 - 4 
    if (animationInterval > 0 && animationInterval < 5) {
      s23 = "\x10";
    } else {
      s23 = " ";
    } 
    s22 = "%s23Fast   ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSpeedFast, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    if (animationInterval == FASTEST_SPEED) {
      s23 = "\x10";
    } else {
      s23 = " ";
    } 
    s22 = "%s23Fastest";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSpeedFastest, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
  }
}

[ CHECK FOR GAME RESTORE
if (isset(gameRestored)) {
  [ make sure input area is cleared
  clear.lines(23, 24, 0);
  [ need to 're-disable menu separators)
  disable.item(cDummy);
  [ and redraw toolbar buttons
  call(lgc.InitToolbar);
}

[ CLOCK DISPLAY
if (clockOn) {
  [ check current time every second
  if (clearStatusSeconds != elapsedSeconds) {
    if (realClock) {
      [ check realtime clock every second
      block(GET.TIME, &currentHour, &currentMinute, &currentSecond); [ get.time(vHOUR, vMINUTE, vSECOND)
    }
    [ update the stored seconds value
    clearStatusSeconds = elapsedSeconds;
  }
}

[ **************************************
[ DYNAMIC MENU CHECKS
[ **************************************
[ these checks need to be in logic 0, not in the game function logic

[ SOUND MENU ITEMS
if (controller(cToggleSound)) {
  if (soundOn && currentTrack > 0 && currentTrack < 128) {
    [ turning sound off pauses walkman
    currentTrack *= -1;
  }
  toggle(soundOn);
  [ update the config file
  call(lgc.SaveOptions);
}
if (controller(cSoundPC)) {
  [ if not already PC sound mode
  if (musicMode != PC_SOUND) {
    [ set musicmode to PC sound
    musicMode = PC_SOUND;
    [ if playing a sound or music
    if (currentTrack > 0 && currentTrack < 128) {
      stop.sound();
    }
    if (playSound) {
      reset(playSound);
      stop.sound();
    }
    
    [ set pc sound mode
    reset(4channelsound);
    reset(useMIDI);
    
    [ if playing cassette,
    if (currentTrack > 0 && currentTrack < 128) {
      set(noScript);
      work1 = &musicDone;
      call(lgc.SetSound);
      block(SND.V.FN, PLAY.SOUND.V, &currentTrack, &work1); [ play.sound(vSNDNUM, vDONEFLAG)
      reset(noScript);
    }
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cSoundFM)) {
  [ if not already in FM mode
  if (musicMode != FM_SOUND) {
    [ set musicmode to FM synth
    musicMode = FM_SOUND;
    [ if playing a sound or music
    if (currentTrack > 0 && currentTrack < 128) {
      stop.sound();
    }
    if (playSound) {
      reset(playSound);
      stop.sound();
    }
    [ if playing cassette,
    if (currentTrack > 0 && currentTrack < 128) {
      call(lgc.SetSound);
      work1 = &musicDone;
      block(SND.V.FN, PLAY.SOUND.V, &currentTrack, &work1); [ play.sound(vSNDNUM, vDONEFLAG)
    }
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cSoundMIDI)) {
  [ if not already in MIDI mode
  if (musicmode != MIDI_SOUND) {
    [ set musicmode to MIDI
    musicmode = MIDI_SOUND;
    [ if playing a sound or music
    if (currentTrack > 0 && currentTrack < 128) {
      stop.sound();
    }
    if (playSound) {
      reset(playSound);
      stop.sound();
    }
    [ if playing cassette,
    if (currentTrack > 0 && currentTrack < 128) {
      call(lgc.SetSound);
      work1 = &musicDone;
      block(SND.V.FN, PLAY.SOUND.V, &currentTrack, &work1); [ play.sound(vSNDNUM, vDONEFLAG)
    }
    [ update the config file
    call(lgc.SaveOptions);
  }
}

[ CLOCK MENU ITEMS
if (controller(cClock)) {
  [ toggle clock mode
  toggle(clockOn);
  if (clockOn) {
    if (realClock) {
      [ status bar checks realtime minutes
      set.cursor.char(" l29, v3, v7, v23, v99, v78, f9");
      [ force realtime clock update
      block(GET.TIME, &currentHour, &currentMinute, &currentSecond); [ get.time(vHOUR, vMINUTE, vSECOND)
    } else {
      [ status bar checks gametime seconds
      set.cursor.char(" l29, v3, v7, v23, v99, v11, f9");
    }
  } else {
    [ status bar doesn't check for time
    set.cursor.char(" l29, v3, v7, v23, v99, f9");
  }
  [ update the config file
  call(lgc.SaveOptions);
}
if (controller(cRealClock)) {
  if (!realClock) {
    set(realClock);
    [ status bar checks realtime minutes
    set.cursor.char(" l29, v3, v7, v23, v99, v78, f9");
    [ force realtime clock update
    block(GET.TIME, &currentHour, &currentMinute, &currentSecond); [ get.time(vHOUR, vMINUTE, vSECOND)
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cGameClock)) {
  if (realClock) {
    reset(realClock);
    [ status bar checks gametime seconds
    set.cursor.char(" l29, v3, v7, v23, v99, v11, f9");
    [ update the config file
    call(lgc.SaveOptions);
  }
}

[ SPEED MENU ITEMS
if ((controller(cSlow) || 
     said("slow") || 
     said("slow", "speed"))) {
  [ 4/20ths of a second delay between interpreter cycles
  if (animationInterval != SLOW_SPEED) {
    animationInterval = SLOW_SPEED;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if ((controller(cNormal) || 
     said("normal") || 
     said("normal", "speed"))) {
  [ 2/20ths of a second delay between interpreter cycles
  if (animationInterval != NORMAL_SPEED) {
    animationInterval = NORMAL_SPEED;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if ((controller(cFast) || 
     said("fast") || 
     said("fast", "speed"))) {
  [ 1/20th of a second delay between interpreter cycles
  if (animationInterval != FAST_SPEED) {
    animationInterval = FAST_SPEED;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if ((controller(cFastest) || 
     said("fastest") || 
     said("fastest", "speed"))) {
  [ no delay between interpreter cycles
  if (animationInterval != FASTEST_SPEED) {
    animationInterval = FASTEST_SPEED;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cSlower)) {
  if (animationInterval < SLOW_SPEED) {
    ++animationInterval;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cFaster)) {
  if (animationInterval > FASTEST_SPEED) {
    --animationInterval;
    [ update the config file
    call(lgc.SaveOptions);
  }
}

[ **************************************
[ NON-CONTROLLER CHECKS
[ **************************************

[ check for end of closet timer
if (closetTimerDone) {
  [ the door gets closed, and if ego is beyond the secret room, he's gonna get stuck
  reset(closetTimerStart);
  reset(closetTimerDone);
  reset(closetopen);
  if (currentRoom > 6) {
    print("%l90|9");
    set(trapped);
  }
}

[ check for ego death (usually happens a lot in AGI games...)
if (deathType > 0) {
  [ if this is first cycle since ego died
  if (deathType < 254) {
    [ disable most menu and keyboard shortcuts
    disable.item(cSave);
    disable.item(cPause);
    disable.item(cChooseItem);
    [ hide speed menu by setting it to a null string
    s23 = "";
    block(SET.MSG, 0, &mnu_msgSpeed, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
    
    [ load the death handler logic
    load.logics(lgc.Death);
  }
    
  [ call the death handler, where you update the screen
  [ and display a message to player about how ego died
  call(lgc.Death);
  
  [ don't process any other commands
  return();
}

[ save current ego position
get.posn(ego, egoX, egoY);
    
[ ROOM SPECIFIC CODE
[ (call BEFORE generic input checks)
call.v(currentRoom);

[ if debugging is active                
if (debugging) {
  [ call the debugging logic
  call(lgc.Debug);
}

[ WALKMAN MUSIC CHECK
if (musicDone) {
  reset(musicDone);
  [ only if cassette is playing AND not paused or at end of side
  if (cassetteLoaded && currentTrack > 0 && currentTrack < 128) {
    [ discard current sound
    set(noScript);
    block(SND.V.FN, DISCARD.SOUND.V, &currentTrack, 0); [ discard.sound.v(vSNDNUM)
    ++currentTrack;
    [ check if end of side is reached
    if ((currentTrack == 43 || currentTrack == 85)) {
      currentTrack = 0;
    } else {
      [ make sure no sound effects are playing
      stop.sound();
      [ play next track
      set(noScript);
      block(SND.V.FN, LOAD.SOUND.V, &currentTrack, 0); [ load.sound.v(vSNDNUM)
      call(lgc.SetSound);
      work1 = &musicDone;
      block(SND.V.FN, PLAY.SOUND.V, &currentTrack, &work1); [ play.sound.v(vSNDNUM, vDONEFLAG)
    }
    reset(noScript);
  }
}

[ SOUND EFFECTS CHECK
if (soundDone) {
  reset(soundDone);
  reset(playSound);
}

[ **************************************
[ GENERIC CONTROLLERS & TEXT INPUT
[ **************************************

[ only if not disabled!
if (!disableGameFunctions) {
  [ saving a cursor from ERIDOCC
  if (saveCursor) {
    reset(saveCursor);
    [ copy s16 into designated cursor msg value
    [ v227 is cursor index value in cp.ERIDOCC logic
    work1 = v227;
    work1 += 40;
    work2 = 16;
    block(SET.MSG, 1, &work1, &work2); [ set.msg(BYVAR, MSGOLD, STRNEW) 
    [ provide feedback
    print.at("Cursor saved.", 14, 19, 15);
    return();
  }
  [ restore a cursor from ERIDOCC
  if (restoreCursor) {
    reset(restoreCursor);
    [ set s12 to default of designated cursor
    work1 = &s12;
    work2 = v227;
    work2 += 30;
    block(SET.STRING.V, &work1, &work2, 0); [ set.string.v(vSTR, vMSG);
    [ format it
    block(STR.FORMAT, &s12, &s12, 0); [ str.format(sINPUT, sRESULT)
    [ now copy it to the current cursor msgnum
    work2 -= 10;
    block(SET.MSG, 1, &work2, &work1); [ set.msg(BYVAR, MSGOLD, STRNEW)
    [ force update by resetting the cursor index
    v227 = -1;
    [ provide feedback
    print.at("Cursor restored.", 14, 19, 17);
    return();
  }
  
  [ check common game functions, depending on current cursor
  if (cursormode < C_DISK) {
    call(lgc.GameFunctions);
  } else {
    [ if using an item, use different function call
    call(lgc.UseItem);
  }
  [ check for toolbar buttons click
  call(lgc.ToolbarFunctions);
}

[ UNKNOWN WORD CHECK
if (haveInput && !haveMatch && unknownWordNum > 0) {
  reset(haveInput);
  [copy word to a string
  if (unknownWordNum == 1) {
    word.to.string(unknownWord, w1);
  }
  if (unknownWordNum == 2) {
    word.to.string(unknownWord, w2);
  }
  if (unknownWordNum == 3) {
    word.to.string(unknownWord, w3);
  }
  if (unknownWordNum == 4) {
    word.to.string(unknownWord, w4);
  }
  if (unknownWordNum == 5) {
    word.to.string(unknownWord, w5);
  }
  if (unknownWordNum == 6) {
    word.to.string(unknownWord, w6);
  }
  if (unknownWordNum == 7) {
    word.to.string(unknownWord, w7);
  }
  if (unknownWordNum == 8) {
    word.to.string(unknownWord, w8);
  }
  if (unknownWordNum == 9) {
    word.to.string(unknownWord, w9);
  }
  if (unknownWordNum == 10) {
    word.to.string(unknownWord, w10);
  }
  [choose a random unknown word response
  random(17, 19, rndNum);
  print.v(rndNum);
}

[ finally, if there is input that hasn't 
[ been recognized yet
if (haveInput && !haveMatch) {
  print("I don't understand your request.");
  reset(haveInput);
}

[ save clock values for comparison purposes
oldSeconds = elapsedSeconds;
oldMinutes = elapsedMinutes;
oldHours = elapsedHours;
oldDays = elapsedDays;

return();

[ **************************************
[ DECLARED MESSAGES
[ **************************************

[ dynamic menu items (message numbers pre-assigned)
#message  1 "Examine Item  <F4>" 
#message  2 "Sound: On   <F2>"
#message  3 " PC Speaker     "
#message  4 " FM Synth       "
#message  5 " MIDI           "
#message  6 "Clock: Off  <F6>"
#message  7 " Game Time      "
#message  8 " Real Time      "
#message  9 "Speed"
#message 10 " Normal "
#message 11 " Slow   "
#message 12 " Fast   "
#message 13 " Fastest"
#message 14 "Speed"
#message 15 "Examine Item  <F4>"
#message 16 "Use Item      <F4>"

[#message xx "PPDemo"
[#message xx "About           "
[#message xx "Version  <Alt-V>"
[#message xx "Help        <F1>"
[#message xx "File"
[#message xx "Save     <F5>"
[#message xx "Restore  <F7>"
[#message xx "컴컴컴컴컴컴"
[#message xx "Restart  <F9>"
[#message xx "Quit  <Alt-Z>"
[#message xx "Action"
[#message xx "Examine Item  <F4>" or "Use Item       <F4>"
[#message xx "Inventory    <Tab>"
[#message xx "Sound"
[#message xx "Quieter         "
[#message xx "Louder          "
[#message xx "컴컴컴컴컴컴컴컴"
[#message xx "Sound: On   <F2>" or "Sound: Off   <F2>"
[#message xx " PC Speaker     "
[#message xx " FM Synth       "
[#message xx " MIDI           "
[#message xx "Time"
[#message xx "Clock: Off  <F6>" or "Clock: On   <F6>"
[#message xx " Game Time      "
[#message xx " Real Time      "
[#message xx "컴컴컴컴컴컴컴컴"
[#message xx "Pause      <Esc>"
[#message xx "Speed"
[#message xx "Slower  "
[#message xx "Faster  "
[#message xx "컴컴컴컴"
[#message xx " Normal "
[#message xx " Slow   "
[#message xx " Fast   "
[#message xx " Fastest"
#message 17 "I don't understand \"%s1\""
#message 18 "\"%s1\" is not in my vocabulary."
#message 19 "What is \"%s1\""

[ active cursors
#message 20 "0000FF3FFF1FFF0FFF07FF03FF01FF007F003F001F00FF01FF00FF307FF87FF8FFFC"
            "00000040006000700078007C007E007F807F007C006C00460006000300030000"
[ walk
#message 21 "040FFFF1FFE07FC07FC0FFE0FFF1FFE17FC03FC07FE0FFE1FFC1FF80FF087F183FBC"
            "0000000E001D001F000E0004000C0016801B0006000C001C0036006200430000"
[ look
#message 22 "0709FFFFFFFFFFFFFFFEEFF62DB40BD0024001808001018003C00FF03FFCFFFFFFFF"
            "000000000000000000000000C003F00F7C3E3E7C7C3EF00FC003000000000000"
[ talk
#message 23 "050E1FF807E0018000000000000000000000008001E007FC0FFE3FFC7FF8FFF9FFFF"
            "0000E007F81FFE7FFE7FFE7FFE7FFE7FFE1FF803F000C0008001000200000000"
[ use 
#message 24 "0803FFFFFFFF1FFE07F801F000F000F000F00090000000000000018001C003E007F0"
            "000000000000C000D806DA06DA06DA06DA06FA6FFE7FFE7FFC3FFC1FF80F0000"
[ wait 
#message 25 "0707018003C003C007E007E00FF01FF83FFC3FFC1FF80FF007E007E003C003C00180"
            "0000F81FF81F5005A00A40058002000180004003E007700E1008081000000000"
[ disk
#message 26 "0707FFFFFFFFFFFF0000000000000000000000000000000001000300FFFFFFFFFFFF"
            "0000000000000000EE77EE770E70FE7FFE7FFE7F1E78DC790000000000000000"
[ tape
#message 27 "0707FFFFFFFFFFFFFFFF01800000000000000000000000000000FFFFFFFFFFFFFFFF"
            "00000000000000000000FE7FF66FEA57F66F1E78EE7700000000000000000000"

[ default cursor pointers
#message 30 "%l90|1"
#message 31 "%l90|2"
#message 32 "%l90|3"
#message 33 "%l90|4"
#message 34 "%l90|5"
#message 35 "%l90|6"
#message 36 "%l90|7"
#message 37 "%l90|8"

[ debug menu items
#message 38 "Log Input:      Off"
#message 39 "Display Clicks: Off"
