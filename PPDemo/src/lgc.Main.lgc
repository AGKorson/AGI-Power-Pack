[ ********************************************************************
[
[ lgc.Main: Main logic
[
[ This logic runs in every interpreter cycle and calls
[ other logics as needed.
[
[
[ To better manage variables and flags, they are 
[ grouped into reserved, global, local, and dynamic:
[
[ reserved = reserved by the interpreter 
[     v0 - v26
[     f0 - f16, f20
[     s0, s1
[
[ global = usable and accessible by all logics
[     v27 - v219
[     f17 - f18, f21 - fShowClicks
[     s2 - s11
[
[ local = usable and accessible by single room
[     v220 - v239
[     f220 - f239
[     s12 - s19
[
[ dynamic = usable and accesible by a non-room logic
[     v240 - v255
[     f240 - f255
[     s20 - s23
[
[ Local and dynamic variables/flags are reset whenever a new room is
[ loaded.
[

[ ********************************************************************
[:wait
[if (!have.key()) {
[  goto(wait);
[}
[print("char: %v19");
[lastChar = 0;
[goto(wait);

[ **************************************
[ LOCAL DEFINES
[ **************************************
#define rndNum                     v255

#define mnu_msgUseItem              m1
#define mnu_msgSndToggle            m2
#define mnu_msgSoundPC              m3
#define mnu_msgSoundFM              m4
#define mnu_msgSoundMIDI            m5
#define mnu_msgClockToggle          m6
#define mnu_msgGameTime             m7
#define mnu_msgRealTime             m8
#define mnu_msgSpeed                m9
#define mnu_msgSpeedSlow           m10
#define mnu_msgSpeedNorm           m11
#define mnu_msgSpeedFast           m12
#define mnu_msgSpeedFastest        m13

[ **************************************
[ ERROR CHECK
[ **************************************

[ if one of the few trappable errors in AGI is encountered, the game
[ is probably not able to continue; make an announcement to the player
[ and quit
if (errorNumber > 0) {
  block(FADE.IN, 0, 0, BLACK); [ fade.in(BYVAR, DELAY, COLOR)
  call(lgc.Error); 
}

[ **************************************
[ GAME START
[ **************************************
[ when game begins, or restarts, there are a number
[ of setup activities to take care of
if (currentRoom == 0) {
  [ when the game starts, the current room is zero, so all the
  [ setup/initialization code goes here
  [
  [ restarting a game also sets currentRoom to zero, and also
  [ requires most of the same setup/initialization steps

  if (!gameRestarted) { 
    [ confirm platform is PC
    if (machineType != PC) {
      load.logics(lgc.Error);
      print("%l97|33");
      quit(1);
    }
          
    [ run the powerpack mod BEFORE DOING ANYTHING ELSE
    call(lgc.Version2Check);
    if (!IntVersion) {
      load.logics(lgc.Error);
      print("%l97|34");
      quit(1);
    }
    if ((IntVersion == VERSION_2089 || IntVersion == VERSION_2272)) {
      [ these versions not supported
      load.logics(lgc.Error);
      print("%l97|35");
      quit(1);
    }
    if (IntVersion == VERSION_2411) {
      call(lgc.mod2411);
      goto(continue);
    }
    if (IntVersion == VERSION_2425) {
      call(lgc.mod2425);
      goto(continue);
    }
    if (IntVersion == VERSION_2426) {
      call(lgc.mod2426);
      goto(continue);
    }
    if (IntVersion == VERSION_2435) {
      call(lgc.mod2435);
      goto(continue);
    }
    if (IntVersion == VERSION_2439) {
      call(lgc.mod2439);
      goto(continue);
    }
    if (IntVersion == VERSION_2440) {
      call(lgc.mod2440);
      goto(continue);
    }
    if (IntVersion == VERSION_2903) {
      call(lgc.mod2903);
      goto(continue);
    }
    if (IntVersion == VERSION_2911) {
      call(lgc.mod2911);
      goto(continue);
    }
    if (IntVersion == VERSION_2912) {
      call(lgc.mod2912);
      goto(continue);
    }
    if (IntVersion == VERSION_2915) {
      call(lgc.mod2915);
      goto(continue);
    }
    if (IntVersion == VERSION_2917) {
      call(lgc.mod2917);
      goto(continue);
    }
    if (IntVersion == VERSION_2936) {
      call(lgc.mod2936);
      goto(continue);
    }
    :continue
    [ confirm video, sound and mouse settings
    if (monitorType != EGA) {
      load.logics(lgc.Error);
      print("%l97|36");
      quit(1);
    }
    if (!enableDblClick) {
      load.logics(lgc.Error);
      print("%l97|37");
      quit(1);
    }
    if (numberOfVoices != 4) {
      load.logics(lgc.Error);
      print("%l97|38");
      quit(1);
    }
  }

  [ do start/restart initialization activities
  call(lgc.Init);       [ this sets up the game; assigns key controllers,
                        [ configures the screen and other startup activities
  [ copy custom instruments
  work1 = &m53;
  work2 = &s18;
  :setinst
  block(SET.MSG, 1, &work1, &work2); [ set.msg(BYVAR, MSGOLD, STRNEW)
  ++work1;
  ++work2;
  if (work1 < 58) {
    goto(setinst);
  }
  
  [ some start/restart actions have to be done within logic0
  if (gameRestarted) {
    [ make sure speed menu is enabled
    s23 = m14; [ "Speed"
    block(SET.MSG, 0, &mnu_msgSpeed, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
    [ go to first room here (skip Intro)
    new.room(rm.ParkingLot);
  } else {
    [ if NOT restarting (meaning this is very beginning, need to create 
    [ the menu; it can't be done in lgc.Init, it MUST be done from within 
    [ logic 0, so do that before going to start room
    set.menu("PPDemo");
    set.menu.item("About           ", cAbout);
    set.menu.item("Version  <Alt-V>", cVersion);
    set.menu.item("Help        <F1>", cHelp);
    set.menu("File");
    set.menu.item("Save     <F5>", cSave);
    set.menu.item("Restore  <F7>", cRestore);
    set.menu.item("컴컴컴컴컴컴", cDummy);
    set.menu.item("Restart  <F9>", cRestart);
    set.menu.item("Quit  <Alt-Z>", cQuit);
    set.menu("Action");
    set.menu.item("Inventory    <Tab>", cStatus);
    set.menu.item(mnu_msgUseItem, cChooseItem); [ "Examine Item  <F4>"
    set.menu("Sound");
    set.menu.item(mnu_msgSndToggle, cToggleSound); [ "Sound: On   <F2>"
    set.menu.item("Quieter         ", cDecrescendo);
    set.menu.item("Louder          ", cCrescendo);
    set.menu.item("컴컴컴컴컴컴컴컴", cDummy);
    set.menu.item(mnu_msgSoundPC, cSoundPC);    [ " PC Speaker     "
    set.menu.item(mnu_msgSoundFM, cSoundFM);    [ " FM Synth       "
    set.menu.item(mnu_msgSoundMIDI, cSoundMIDI);  [ " MIDI           "
    set.menu("Time");
    set.menu.item(mnu_msgClockToggle, cClock);  [ "Clock: Off  <F6>"
    set.menu.item(mnu_msgGameTime, cGameClock); [ " Game Time      "
    set.menu.item(mnu_msgRealTime, cRealClock); [ " Real Time      "
    set.menu.item("컴컴컴컴컴컴컴컴", cDummy);
    set.menu.item("Pause      <Esc>", cPause);
    set.menu(mnu_msgSpeed);  [ "Speed"
    set.menu.item( "Slower  ", cSlower);
    set.menu.item( "Faster  ", cFaster);
    set.menu.item( "컴컴컴컴", cDummy);
    set.menu.item(mnu_msgSpeedSlow, cSlow); [ " Slow   "
    set.menu.item(mnu_msgSpeedNorm, cNormal); [ " Normal "
    set.menu.item(mnu_msgSpeedFast, cFast); [ " Fast   "
    set.menu.item(mnu_msgSpeedFastest, cFastest); [ " Fastest"
    
[ temporary debug items
set.menu("Debug");
set.menu.item(m38, cLogInput);   [ "Log Input:      Off"
set.menu.item(m39, cShowClicks); [ "Display Clicks: Off"

    [ submit the menu (which makes it ready to use)
    submit.menu();
    [ disable the separator lines
    disable.item(cDummy);
    
    [ start the game with the title screen
    new.room(rm.Title);
  }
}

[ **************************************
[ EVERY CYCLE
[ **************************************

[!!!!!! BEGIN TEMPORARY DEBUG CODE
if (controller(cLogInput)) {
  [ toggle the message
  toggle(fLogInput);
  s23 = "Log Input:      %s22";
  if (fLogInput) {
    s22 = " On";    
  } else {
    s22 = "Off";
  }
  block(STR.FORMAT, &s23, &s23, 0); [ str.format(sINPUT, sRESULT)
  block(SET.MSG, 0, &m38, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
}
[ show click data
if (controller(cShowClicks)) {
  [ toggle the message
  toggle(fShowClicks);
  s23 = "Display Clicks: %s22";
  if (fShowClicks) {
    s22 = " On";
  } else {
    s22 = "Off";
  }
  block(STR.FORMAT, &s23, &s23, 0); [ str.format(sINPUT, sRESULT)
  block(SET.MSG, 0, &m39, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
}
if (fShowClicks) {
  [ used to assist in creating click statements and said statements
  if (controller(cLeftClick)  && currentRoom != 12 && currentRoom != 13) {
    get.posn(ego, work1, work2);
    display(4, 1, "left click: (%v27, %v28)  ego pos:  (%v46, %v47)        ");
  }
  [[ show the open closet door timer
  [ display(24, 0, "%v79|2:%v80|2");
  [ show remaining available memory
  display(24, 0, "mem pages: %v8  ");
}
if (fLogInput) {
  if (haveInput) {
    if (unknownWordNum > 0) {
      log("unknown word: %v9");
    } else {
      log("");
    }
  }
}
if (said("test", "get")) {
  get.num("add to score: ", work1);
  call(lgc.ScoreHandler);
}
if (said("test", "drop")) {
  get.num("sub from score: ", work1);
  work1 *= -1;
  call(lgc.ScoreHandler);
}
[!!!!!! END TEMPORARY DEBUG CODE

[ if a new room has just been loaded
if (newRoom) {
  [ First interpreter cycle in a new room
  [ Note: Everything other than logic 0 is discarded
  [ from memory when new.room is executed

  [ do basic room initialization
  call(lgc.RoomInit);
  
  if (!disableGameFunctions) {
    [ Load game specific functions logic into memory
    load.logics(lgc.GameFunctions);
    [ also toolbar functions
    load.logics(lgc.ToolbarFunctions);
    load.logics(lgc.UseItem);
  }
  [ if debugging is active
  if (debugging) {
    [ load debug logic into memory
    load.logics(lgc.Debug);
  }
  [ score handler (to allow score to go below zero)
  load.logics(lgc.ScoreHandler);
  
  [ always animate ego object when starting a new room
  animate.obj(ego);
  [ load and set view
  [ (for more complex games, this will probably need 
  [ to be moved into each room's logic)
  load.view(vw.Ego);
  set.view(ego, vw.Ego);
  
  [ force clock value to update, if time is visible
  clearStatusSeconds = -1; 
  
  [ check for closet door being left open
  if (closetopen && !closetTimerStart && currentRoom != rm.Hallway && 
      currentRoom != rm.Closet && currentRoom != rm.SecretRoom) {
    [ start a fresh timer
    set(closetTimerStart);
    timerMin = 0; [4;
    timerSec = 20; [0;
    block(START.TIMER, &timerMin, &timerSec, &closetTimerDone); [ start.timer(vMINUTES, vSECONDS, fDONE)
  } else {
    if (closetTimerStart) {
      [ stop the timer
      reset(closetTimerStart);
      block(TOGGLE.TIMER, 0, 0, 0); [ toggle.timer(STATE)
    }
  }
}

[ check for menu activation
if (!disableGameFunctions) {
  [ boolean trick to use single if statement
  if (!controller(cMenu) && (!controller(cLeftClick) || mouseY > 7)) {
  } else {
    [ check for click on sound bar
    if (mouseX > 137) {
      [ adjust sound based on clicked position
      work1 = mouseX;
      work1 -= 138;
      if (work1 >= 18) {
        [ set to max vol
        set(soundOn);
        attenuation = 0;
      } else {
        if (work1 < 2) {
          reset(soundOn);
        } else {
          set(soundOn);
          [ calculate new sound level from clicked value
          work1 /= 2;
          work1 *= -8;
          work1 += 68;
          if (!4channelSound) {
            work1 /= 4;
          }
          attenuation = work1;
        }
      [ update the config file
      call(lgc.SaveOptions);
      }
      return();
    }
    [ if not on sound bar, show menu
    menu.input();
    oldSeconds = -1;
    [ reset click event
    set.key(-1, -1, cLeftClick); [ clear.controller(cNUM)
    
    [ refresh dynamic menu items
    [ inventory menu item
    if (deathType < 254) {
      if (cursormode == C_USE) {
        [ enable 'use item'
        enable.item(cChooseItem);
        s23 = m16;
        block(SET.MSG, 0, &mnu_msgUseItem, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
      } else {
[        if (cursormode == C_LOOK) {
[          [ enable look if 'look' icon

[!!!! enable 'look item' for all other cursors
          enable.item(cChooseItem);
          s23 = m15;
          block(SET.MSG, 0, &mnu_msgUseItem, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
          
[        } else {
[          [ disable for all others
[          disable.item(cChooseItem);
[        }
      }
    } else {
      [ not enabled if dead
      disable.item(cChooseItem);
    }
    
    [ sound toggle and mode
    if (soundOn) {
      s23 = "On ";
      enable.item(cSoundPC);
      enable.item(cSoundFM);
      enable.item(cSoundMIDI);
      if (4channelSound) {
        work1 = 62;
      } else {
        work1 = 14;
      }
      if (attenuation > work1) {
        disable.item(cDecrescendo);
      } else {
        enable.item(cDecrescendo);
      }
      if (attenuation == 0) {
        disable.item(cCrescendo);
      } else {
        enable.item(cCrescendo);
      }
    } else {
      s23 = "Off";
      disable.item(cSoundPC);
      disable.item(cSoundFM);
      disable.item(cSoundMIDI);
      disable.item(cCrescendo);
      disable.item(cDecrescendo);
    }
    s22 = "Sound: %s23  <F2>";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSndToggle, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
  
    [ check the correct sound option, uncheck the rest
    if (!4channelsound) {
      s23 = "\x10";
    } else {
      s23 = " ";
    }
    s22 = "%s23PC Speaker     ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSoundPC, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    
    if (4channelsound && !useMIDI) {
      set.key(0, 0, SET.SNDMODE); [ set.sndmode(MODE)
      s23 = "\x10";
    } else {
      s23 = " ";
    }
    s22 = "%s23FM Synth       ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSoundFM, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    
    if (4channelsound && useMIDI) {
      set.key(1, 0, SET.SNDMODE); [ set.sndmode(MODE)
      s23 = "\x10";
    } else {
      s23 = " ";
    }
    s22 = "%s23MIDI           ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSoundMIDI, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)

    [ clock toggle and mode
    if (clockOn) {
      s23 = "On ";
      enable.item(cGameClock);
      enable.item(cRealClock);
    } else {
      s23 = "Off";
      disable.item(cGameClock);
      disable.item(cRealClock);
    }
    s22 = "Clock: %s23  <F6>"; 
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgClockToggle, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    if (realClock) {
      s21 = " ";
      s23 = "\x10";
    } else {
      s21 = "\x10";
      s23 = " ";
    }
    s22 = "%s21Game Time      ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgGameTime, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    s22 = "%s23Real Time      ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgRealTime, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)

    [ speed menu not available when dead
    s23 = mnu_msgSpeed;
    block(STR.LEN, &s23, &work1, 0); [ str.len(sINPUT, vRESULT)
    if (work1 == 0 && deathType != 254) {
      s23 = m14; [ "Speed"
      block(SET.MSG, 0, &mnu_msgSpeed, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
    }
    if (work1 !=0 && deathType == 254) {
      s23 = "";
      block(SET.MSG, 0, &mnu_msgSpeed, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
    }
    [ speed mode
    if (animationInterval == SLOW_SPEED) {
      disable.item(cSlower);
    } else {
      enable.item(cSlower);
    }
    if (animationInterval == FASTEST_SPEED) {
      disable.item(cFaster);
    } else {
      enable.item(cFaster);
    }
    [ slow (12) is 9 - 12
    if (animationInterval > 8) {
      s23 = "\x10";
    } else {
      s23 = " ";
    } 
    s22 = "%s23Slow   ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSpeedSlow, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    [ normal (6) is 5 - 8
    if (animationInterval > 4 && animationInterval < 9) {
      s23 = "\x10";
    } else {
      s23 = " ";
    }
    s22 = "%s23Normal ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSpeedNorm, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    [ fast (3) is 1 - 4 
    if (animationInterval > 0 && animationInterval < 5) {
      s23 = "\x10";
    } else {
      s23 = " ";
    } 
    s22 = "%s23Fast   ";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSpeedFast, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
    if (animationInterval == FASTEST_SPEED) {
      s23 = "\x10";
    } else {
      s23 = " ";
    } 
    s22 = "%s23Fastest";
    block(STR.FORMAT, &s22, &s22, 0); [ str.format(sINPUT, sRESULT)
    block(SET.MSG, 0, &mnu_msgSpeedFastest, &s22); [ set.msg(BYVAR, MSGOLD, STRNEW)
  }
}

[ check for end of closet timer
if (closetTimerDone) {
  [ the door gets closed, and if ego is beyond the secret room, he's gonna get stuck
  reset(closetTimerStart);
  reset(closetTimerDone);
  reset(closetopen);
  if (currentRoom > 6) {
    print("%l90|8");
    set(trapped);
  }
}

[ if this is first cycle since restore game executed
if (isset(gameRestored)) {
  [ make sure input area is cleared
  clear.lines(23, 24, 0);
  [ need to 're-disable menu separators)
  disable.item(cDummy);
  [ and redraw toolbar buttons
  call(lgc.InitToolbar);
}

[ if clock display is needed
if (clockOn) {
  [ check current time every second
  if (clearStatusSeconds != elapsedSeconds) {
    if (realClock) {
      [ check realtime clock every second, update if minute changes
      block(GET.TIME, &currentHour, &currentMinute, &currentSecond); [ get.time(vHOUR, vMINUTE, vSECOND)
    }
    [ update the stored seconds value
    clearStatusSeconds = elapsedSeconds;
  }
}

[ dynamic menu checks need to be in logic 0, not in the game function logic
[ sound options
if (controller(cToggleSound)) {
  toggle(soundOn);
  [ update the config file
  call(lgc.SaveOptions);
}
if (controller(cSoundPC)) {
  [ if not already in PC sound mode
  if (4channelsound) {
    reset(4channelsound);
    reset(useMIDI);
    [ convert attenuation
    attenuation /= 4;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cSoundFM)) {
  [ if not already in FM mode
  if ((!4channelsound || useMIDI)) {
    if (!4channelsound) {
      work1 = attenuation;
      work1 *= 4;
      if (attenuation > 15) {
        ++work1;
      }
      if (attenuation > 31) {
        ++work1;
      }
      if (attenuation > 47) {
        ++work1;
      }
      attenuation = work1;
    }
    set(4channelsound);
    reset(useMIDI);
    set.key(FM_MODE, 0, SET.SNDMODE); [ set.sndmode(MODE)
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cSoundMIDI)) {
  [ if not already in MIDI mode
  if ((!4channelsound || !useMIDI)) {
    if (!4channelsound) {
      work1 = attenuation;
      work1 *= 4;
      if (attenuation > 15) {
        ++work1;
      }
      if (attenuation > 31) {
        ++work1;
      }
      if (attenuation > 47) {
        ++work1;
      }
      attenuation = work1;
    }
    set(4channelsound);
    set(useMIDI);
    set.key(MIDI_MODE, 0, SET.SNDMODE); [ set.sndmode(MODE)
    [ update the config file
    call(lgc.SaveOptions);
  }
}

[ clock options
[ toggle clock
if (controller(cClock)) {
  toggle(clockOn);
  if (clockOn) {
    if (realClock) {
      [ status bar checks realtime minutes
      set.cursor.char(" l29, v3, v7, v78, v23, f9");
      [ force realtime clock update
      block(GET.TIME, &currentHour, &currentMinute, &currentSecond); [ get.time(vHOUR, vMINUTE, vSECOND)
    } else {
      [ status bar checks gametime seconds
      set.cursor.char(" l29, v3, v7, v11, v23, f9");
    }
  } else {
    [ status bar doesn't check for time
    set.cursor.char(" l29, v3, v7, v23, f9");
  }
  [ update the config file
  call(lgc.SaveOptions);
}
if (controller(cRealClock)) {
  if (!realClock) {
    set(realClock);
    [ status bar checks realtime minutes
    set.cursor.char(" l29, v3, v7, v78, v23, f9");
    [ force realtime clock update
    block(GET.TIME, &currentHour, &currentMinute, &currentSecond); [ get.time(vHOUR, vMINUTE, vSECOND)
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cGameClock)) {
  if (realClock) {
    reset(realClock);
    [ status bar checks gametime seconds
    set.cursor.char(" l29, v3, v7, v11, v23, f9");
    [ update the config file
    call(lgc.SaveOptions);
  }
}

[ speed controls
if ((controller(cSlow) || 
     said("slow") || 
     said("slow", "speed"))) {
  [ 4/20ths of a second delay between interpreter cycles
  if (animationInterval != SLOW_SPEED) {
    animationInterval = SLOW_SPEED;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if ((controller(cNormal) || 
     said("normal") || 
     said("normal", "speed"))) {
  [ 2/20ths of a second delay between interpreter cycles
  if (animationInterval != NORMAL_SPEED) {
    animationInterval = NORMAL_SPEED;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if ((controller(cFast) || 
     said("fast") || 
     said("fast", "speed"))) {
  [ 1/20th of a second delay between interpreter cycles
  if (animationInterval != FAST_SPEED) {
    animationInterval = FAST_SPEED;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if ((controller(cFastest) || 
     said("fastest") || 
     said("fastest", "speed"))) {
  [ no delay between interpreter cycles
  if (animationInterval != FASTEST_SPEED) {
    animationInterval = FASTEST_SPEED;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cSlower)) {
  if (animationInterval < SLOW_SPEED) {
    ++animationInterval;
    [ update the config file
    call(lgc.SaveOptions);
  }
}
if (controller(cFaster)) {
  if (animationInterval > FASTEST_SPEED) {
    --animationInterval;
    [ update the config file
    call(lgc.SaveOptions);
  }
}

[ check for ego death (usually happens a lot in AGI games...)
if (deathType > 0) {
  [ if this is first cycle since ego died
  if (deathType < 254) {
    [ disable most menu and keyboard shortcuts
    disable.item(cSave);
    disable.item(cPause);
    disable.item(cChooseItem);
    [ hide speed menu by setting it to a null string
    s23 = "";
    block(SET.MSG, 0, &mnu_msgSpeed, &s23); [ set.msg(BYVAR, MSGOLD, STRNEW)
    
    [ load the death handler logic
    load.logics(lgc.Death);
  }
    
  [ call the death handler, where you update the screen
  [ and display a message to player about how ego died
  call(lgc.Death);
  
  [ don't process any other commands
  return();
}

[ ***********************
[ CHECK CONTROLLER INPUT
[ *********************** 

[ if normal game functions have not been disabled
if (!disableGameFunctions) {
}
  
[ ***********************
[ NON-CONTROLLER CHECKS
[ *********************** 

[ save current ego position
get.posn(ego, egoX, egoY);
    
[ IMPORTANT: This calls the logic for the current room - this
[ is not done automatically by the interpreter so it has to be
[ called manually by logic 0.
call.v(currentRoom);

[ if debugging is active                
if (debugging) {
  [ call the debugging logic
  call(lgc.Debug);
}

[ run game specific functions only if they are not disabled
if (!disableGameFunctions) {
  [ saving a cursor
  if (saveCursor) {
    reset(saveCursor);
    [ copy s16 into designated cursor msg value
    [ v227 is cursor index value in cp.ERIDOCC logic
    work1 = v227;
    work1 += 40;
    work2 = 16;
    block(SET.MSG, 1, &work1, &work2); [ set.msg(BYVAR, MSGOLD, STRNEW) 
    [ provide feedback
    print.at("Cursor saved.", 14, 19, 15);
    return();
  }
  
  [ restore a cursor
  if (restoreCursor) {
    reset(restoreCursor);
    [ set s12 to default of designated cursor
    work1 = &s12;
    work2 = v227;
    work2 += 46;
    block(SET.STRING.V, &work1, &work2, 0); [ set.string.v(vSTR, vMSG);
    [ now copy it to the current cursor msgnum
    work2 -= 6;
    block(SET.MSG, 1, &work2, &work1); [ set.msg(BYVAR, MSGOLD, STRNEW)
    [ force update by resetting the cursor index
    v227 = -1;
    [ provide feedback
    print.at("Cursor restored.", 14, 19, 17);
    return();
  }
  
  [ check for instrument change
  if (saveCustomInst) {
    reset(saveCustomInst);
    work1 = 22;
    block(STR.LEFT, &s12, &s12, &work1); [ str.left(sINPUT, sRESULT, vLEN);
    work1 = v221; [ selinst in cp.CAISOCC
    work1 += 52; [convert to msg offset
    work2 = &s12; [ use string 12
    block(SET.MSG, 1, &work1, &work2); [set.msg(BYVAR, MSGNUM, STRNEW);
    [ update config file
    call(lgc.SaveOptions);
    return();
  }
  
  if (cursormode < C_DISK) {
    call(lgc.GameFunctions);
  } else {
    [ if using an item, use different function call
    call(lgc.UseItem);
  }
  call(lgc.ToolbarFunctions);
}
  
[ check player input for unknown words
if (haveInput && !haveMatch && unknownWordNum > 0) {
  reset(haveInput);
  [copy word to a string
  if (unknownWordNum == 1) {
    word.to.string(unknownWord, w1);
  }
  if (unknownWordNum == 2) {
    word.to.string(unknownWord, w2);
  }
  if (unknownWordNum == 3) {
    word.to.string(unknownWord, w3);
  }
  if (unknownWordNum == 4) {
    word.to.string(unknownWord, w4);
  }
  if (unknownWordNum == 5) {
    word.to.string(unknownWord, w5);
  }
  if (unknownWordNum == 6) {
    word.to.string(unknownWord, w6);
  }
  if (unknownWordNum == 7) {
    word.to.string(unknownWord, w7);
  }
  if (unknownWordNum == 8) {
    word.to.string(unknownWord, w8);
  }
  if (unknownWordNum == 9) {
    word.to.string(unknownWord, w9);
  }
  if (unknownWordNum == 10) {
    word.to.string(unknownWord, w10);
  }
  [choose a random unknown word response
  random(33, 35, rndNum);
  print.v(rndNum);
}
  
[ finally, if there is input that hasn't 
[ been recognized yet
if (haveInput && !haveMatch) {
  print("I don't understand your request.");
  reset(haveInput);
}

[ save clock values for comparison purposes
oldSeconds = elapsedSeconds;
oldMinutes = elapsedMinutes;
oldHours = elapsedHours;
oldDays = elapsedDays;

return();

[ **************************************
[ MESSAGES
[ **************************************
[ dynamic menu items (message numbers pre-assigned)
#message  1 "Examine Item  <F4>" 
#message  2 "Sound: On   <F2>"
#message  3 " PC Speaker     "
#message  4 " FM Synth       "
#message  5 " MIDI           "
#message  6 "Clock: Off  <F6>"
#message  7 " Game Time      "
#message  8 " Real Time      "
#message  9 "Speed"
#message 10 " Normal "
#message 11 " Slow   "
#message 12 " Fast   "
#message 13 " Fastest"
#message 14 "Speed"
#message 15 "Examine Item  <F4>"
#message 16 "Use Item      <F4>"

[#message xx "PPDemo"
[#message xx "About           "
[#message xx "Version  <Alt-V>"
[#message xx "Help        <F1>"
[#message xx "File"
[#message xx "Save     <F5>"
[#message xx "Restore  <F7>"
[#message xx "컴컴컴컴컴컴"
[#message xx "Restart  <F9>"
[#message xx "Quit  <Alt-Z>"
[#message xx "Action"
[#message xx "Examine Item  <F4>" or "Use Item       <F4>"
[#message xx "Inventory    <Tab>"
[#message xx "Sound"
[#message xx "Quieter         "
[#message xx "Louder          "
[#message xx "컴컴컴컴컴컴컴컴"
[#message xx "Sound: On   <F2>" or "Sound: Off   <F2>"
[#message xx " PC Speaker     "
[#message xx " FM Synth       "
[#message xx " MIDI           "
[#message xx "Time"
[#message xx "Clock: Off  <F6>" or "Clock: On   <F6>"
[#message xx " Game Time      "
[#message xx " Real Time      "
[#message xx "컴컴컴컴컴컴컴컴"
[#message xx "Pause      <Esc>"
[#message xx "Speed"
[#message xx "Slower  "
[#message xx "Faster  "
[#message xx "컴컴컴컴"
[#message xx " Normal "
[#message xx " Slow   "
[#message xx " Fast   "
[#message xx " Fastest"

[debug menu items
#message 38 "Log Input:      Off"
#message 39 "Display Clicks: Off"

 [ active cursors
#message 40 "0000FF3FFF1FFF0FFF07FF03FF01FF007F003F001F00FF01FF00FF307FF87FF8FFFC"
            "00000040006000700078007C007E007F807F007C006C00460006000300030000"
[ walk
#message 41 "040FFFF1FFE07FC07FC0FFE0FFF1FFE17FC03FC07FE0FFE1FFC1FF80FF087F183FBC"
            "0000000E001D001F000E0004000C0016801B0006000C001C0036006200430000"
[ look
#message 42 "0709FFFFFFFFFFFFFFFEEFF62DB40BD0024001808001018003C00FF03FFCFFFFFFFF"
            "000000000000000000000000C003F00F7C3E3E7C7C3EF00FC003000000000000"
[ talk
#message 43 "050E1FF807E0018000000000000000000000008001E007FC0FFE3FFC7FF8FFF9FFFF"
            "0000E007F81FFE7FFE7FFE7FFE7FFE7FFE1FF803F000C0008001000200000000"
[ use 
#message 44 "0803FFFFFFFF1FFE07F801F000F000F000F00090000000000000018001C003E007F0"
            "000000000000C000D806DA06DA06DA06DA06FA6FFE7FFE7FFC3FFC1FF80F0000"
[ wait 
#message 45 "0707018003C003C007E007E00FF01FF83FFC3FFC1FF80FF007E007E003C003C00180"
            "0000F81FF81F5005A00A40058002000180004003E007700E1008081000000000"
[ default cursors
#message 46 "0000FF3FFF1FFF0FFF07FF03FF01FF007F003F001F00FF01FF00FF307FF87FF8FFFC"
            "00000040006000700078007C007E007F807F007C006C00460006000300030000"
[ walk
#message 47 "040FFFF1FFE07FC07FC0FFE0FFF1FFE17FC03FC07FE0FFE1FFC1FF80FF087F183FBC"
            "0000000E001D001F000E0004000C0016801B0006000C001C0036006200430000"
[ look
#message 48 "0709FFFFFFFFFFFFFFFEEFF62DB40BD0024001808001018003C00FF03FFCFFFFFFFF"
            "000000000000000000000000C003F00F7C3E3E7C7C3EF00FC003000000000000"
[ talk
#message 49 "050E1FF807E0018000000000000000000000008001E007FC0FFE3FFC7FF8FFF9FFFF"
            "0000E007F81FFE7FFE7FFE7FFE7FFE7FFE1FF803F000C0008001000200000000"
[ use 
#message 50 "0803FFFFFFFF1FFE07F801F000F000F000F00090000000000000018001C003E007F0"
            "000000000000C000D806DA06DA06DA06DA06FA6FFE7FFE7FFC3FFC1FF80F0000"
[ wait
#message 51 "0707018003C003C007E007E00FF01FF83FFC3FFC1FF80FF007E007E003C003C00180"
            "0000F81FF81F5005A00A40058002000180004003E007700E1008081000000000"

#message 52 "%s16"
#message 53 "22215909FFFF030F020000"
#message 54 "22215909FFFF030F020000"
#message 55 "22215909FFFF030F020000"
#message 56 "22215909FFFF030F020000"
#message 57 "22215909FFFF030F020000"