[ ********************************************************************[[ lgc.Main: Main logic[[ This logic runs in every interpreter cycle and calls[ other logics as needed.[[[ To better manage variables and flags, they are [ grouped into reserved, global, local, and dynamic:[[ reserved = reserved by the interpreter [     v0 - v26[     f0 - f16, f20[     s0, s1[[ global = usable and accessible by all logics[     v27 - v219[     f17 - f19, f21 - f219[     s2 - s11[[ local = usable and accessible by single room[     v220 - v239[     f220 - f239[     s12 - s19[[ dynamic = usable and accesible by a non-room logic[     v240 - v255[     f240 - f255[     s20 - s23[[ Local and dynamic variables/flags are reset whenever a new room is[ loaded.[[ ********************************************************************[ **************************************[ LOCAL DEFINES[ **************************************#define rndNum                     v255[ **************************************[ ERROR CHECK[ **************************************[ if one of the few trappable errors in AGI is encountered, the game[ is probably not able to continue; make an announcement to the player[ and quitif (errorNumber > 0) {  call(lgc.Error); }[ **************************************[ GAME START[ **************************************[ when game begins, or restarts, there are a number[ of setup activities to take care ofif (currentRoom == 0) {  [ when the game starts, the current room is zero, so all the  [ setup/initialization code goes here  [  [ restarting a game also sets currentRoom to zero, and also  [ requires most of the same setup/initialization steps  if (!gameRestarted) {    [ run the powerpack mod BEFORE DOING ANYTHING ELSE    call(lgc.mod2089);    call(lgc.mod2272);    call(lgc.mod2411);    call(lgc.mod2425);    call(lgc.mod2426);    call(lgc.mod2435);    call(lgc.mod2439);    call(lgc.mod2440);    call(lgc.mod2903);    call(lgc.mod2911);    call(lgc.mod2912);    call(lgc.mod2915);    call(lgc.mod2917);    call(lgc.mod2936);        [ inform user of version    print("Version: %v30  âáÖÑÇ");  }    [ use these two lines to enable debugging; remove them  [ before distributing your game  set(debugging);       [ this line adds the debug menu and enables debugging                        [ when the game starts  set.key(0, 32, cDebug);   [ this command allows user to enter debug mode                            [ by pressing ALT+D    call(lgc.Init);       [ this sets up the game; assigns key controllers,                        [ configures the screen and other startup activities  [ if restarting  if (gameRestarted) {    [ for a restart, there are a few things that need to be reset    disable.item(cDummy);    set(enableMenu);    reset(disableGameFunctions);        [ go to first room here (skip Intro)    new.room(rm.Terminal);  } else {    [ if not an early version, set up the menus        [ if room is 0, and not restarting, it means    [ this is very beginning; need to create the menu    set.menu("AGI");    set.menu.item("About      ", cAbout);    set.menu.item("Help   <F1>", cHelp);    set.menu("File");    set.menu.item("Save ÄÅÇÉ<F5>", cSave);    set.menu.item("Restore  <F7>", cRestore);    set.menu.item("-------------", cDummy);    set.menu.item("Restart  <F9>", cRestart);    set.menu.item("Quit  <Alt-Z>", cQuit);    set.menu("Action");    set.menu.item("See Object  <F4>", cShowObj);    set.menu.item("Inventory  <Tab>", cStatus);    set.menu("Special");    set.menu.item("Sound On/Off      <F2>", cToggleSound);    if (machineType == PC && monitorType < 2) {      [ cga display can toggle monitor      set.menu.item("Color/BW      <Ctrl R>", cToggleMonitor);    }    set.menu.item("Clock On/Off      <F6>", cClock);    set.menu.item("Joystick      <Ctrl J>", cInitJoy);    set.menu.item("Pause            <Esc>", cPause);    set.menu("Speed");    set.menu.item("Normal ", cNormal);    set.menu.item("Slow   ", cSlow);    set.menu.item("Fast   ", cFast);    set.menu.item("Fastest", cFastest);    if (debugging) {      set.menu("Debug");      set.menu.item("Debug Help        ", cDebugHelp);      set.menu.item("Ego Info   <Alt-E>", cShowEgo);      set.menu.item("Pri Screen <Alt-P>", cShowPriority);      set.menu.item("Memory     <Alt-M>", cShowMem);      set.menu.item("Obj Info   <Alt-I>", cObjInfo);      set.menu.item("Coords     <Alt-X>", cXY);      set.menu.item("Get All           ", cGimme);    }    [ submit the menu (which makes it ready to use)    submit.menu();    [ disable the separator lines    disable.item(cDummy);    [ disable game functions at start; they will be re-enabled after title screen is done    set(disableGameFunctions);        [ save default msgbox colors    msgBoxBG = WHITE;    msgBoxFG = BLACK;    msgBoxBorder = RED;        [ start the game with the title screen    new.room(rm.Title);         [ intro/opening screen  }}[ **************************************[ EVERY CYCLE[ **************************************[ if a new room has just been loadedif (newRoom) {  [ First interpreter cycle in a new room  [ Note: Everything other than logic 0 is discarded  [ from memory when new.room is executed  [ Load game specific functions logic into memory  load.logics(lgc.GameFunctions);    [ if debugging is active  if (debugging) {    [ load debug logic into memory    load.logics(lgc.Debug);  }  [ always animate ego object when starting a new room  animate.obj(ego);  [ load and set view  [ (for more complex games, this will probably need   [ to be moved into each room's logic)  load.view.v(currentEgoView);  set.view.v(ego, currentEgoView);    [ force clock value to update, if time is visible  clearStatusSeconds = 255; }[ check for ego death (usually happens a lot in AGI games...)if (deathType > 0) {  [ if this is first cycle since ego died  if (deathType != 255) {    [ disable most menu and keyboard shortcuts    disable.item(cDebugHelp);    disable.item(cSave);    disable.item(cPause);    disable.item(cShowObj);    disable.item(cClock);    disable.item(cInitJoy);    disable.item(cNormal);    disable.item(cFastest);    disable.item(cFast);    disable.item(cSlow);    disable.item(cShowEgo);    disable.item(cShowPriority);    disable.item(cShowMem);    disable.item(cObjInfo);    disable.item(cXY);    disable.item(cGimme);        [ load the death handler logic    load.logics(lgc.Death);  }      [ call the death handler, where you update the screen  [ and display a message to player about how ego died  call(lgc.Death);    [ don't process any other commands  return();}[ ***********************[ CHECK CONTROLLER INPUT[ *********************** [!!!!!!!!!!!! need to disable game functions whenever showing a control panel![ if normal game functions have not been disabledif (!disableGameFunctions) {  [ if not on a control panel  if ((currentRoom < cp.MsgBox || currentRoom > cp.Paint)) {    [ check for menu activation    if (controller(cMenu)) {      menu.input();    }  }    [ now check for any controllers that may have been activated  if (controller(cAbout)) {    print(gameAboutMsg);  }  if ((controller(cFastest) ||        said("fastest") ||        said("fastest", "speed"))) {    [ no delay between interpreter cycles    animationInterval = FASTEST_SPEED;  }    if ((controller(cFast) ||        said("fast") ||        said("fast", "speed"))) {    [ 1/20th of a second delay between interpreter cycles    animationInterval = FAST_SPEED;  }    if ((controller(cNormal) ||        said("normal") ||        said("normal", "speed"))) {    [ 2/20ths of a second delay between interpreter cycles    animationInterval = NORMAL_SPEED;  }  if ((controller(cSlow) ||        said("slow") ||        said("slow", "speed"))) {    [ 4/20ths of a second delay between interpreter cycles    animationInterval = SLOW_SPEED;  }    [ remember that sound controls only have an effect on non-PC systems  if (controller(cCrescendo) && attenuation > 0) {    [ to increase volume, lower sound attenuation variable    --attenuation;  }  if (controller(cDecrescendo) && attenuation < 15) {    [ to decrease volume, raise sound attenuation variable    ++attenuation;  }    [ toggle sound onn/off  if (controller(cToggleSound)) {    toggle(soundOn);  }      [ toggle monitor mode  if (controller(cToggleMonitor)) {    toggle.monitor();  }  [ if debug mode is requested  if ((said("debug") || controller(cDebug))) {    [ if not in debug mode yet    if (!debugging) {      [ activate it      set(debugging);      [ display the game-about message      print(gameVersionMsg);      [ and interpreter version      version();      [ load debug logic into memory      load.logics(lgc.Debug);    }  }  [ save game  if ((controller(cSave) ||        said("save", "game") ||        said("save"))) {    save.game();  }  [ restore game  if ((controller(cRestore) ||        said("restore", "game") ||        said("restore"))) {    restore.game();  }  [ restart game  if ((controller(cRestart) ||        said("restart", "game") ||        said("restart"))) {    restart.game();  }  [ ask for help  if ((controller(cHelp) ||        said("help"))) {    call(lgc.GameHelp);  }  [ echo line draws previous input on input line  if (controller(cEchoLine)) {    echo.line();  }  [ clear the input line  if (controller(cCancelLine)) {    cancel.line();  }  [ initialize the joystick  if (controller(cInitJoy)) {    init.joy();  }  [ pause game (showing menu is another   [ way to pause the game)  if ((controller(cPause) ||        said("pause", "game") ||        said("pause"))) {    pause();  }  [ check player's current inventory  if ((controller(cStatus) ||        said("inventory"))) {    status();  }  [ examine an object in player's inventory  if ((controller(cShowObj) ||        said("look", "inventory"))) {    [ enable section of inventory items    set(enableItemSelect);    [ show inventory screen    status();        [ selectedItem is set to 255 if ESC is pressed    [ in the inventory screen    if (selectedItem > 0 && selectedItem != 255) {      [ player has chosen an object (value of SelectedItem)      [ we now display this object      if (selectedItem == 1) {        show.obj(vw.Inv.TestItem);      }      [ If you have several objects, it is easier to give      [ them consecutive view numbers. Then you can do the      [ following (view numbers start at 220 for this      [ example):      [   v255 = selectedItem; v255 += 219;      [   show.obj.v(v255);      [ If you do this, you don't have to have separate statements for each      [ object.    }          [ disable selection of inventory items    reset(enableItemSelect);  }  [ quit the game  if ((controller(cQuit) ||        said("quit", "game") ||        said("quit"))) {    stop.sound();    quit(0);  }  [ toggle clock feature  if ((said("clock") || controller(cClock))) {    toggle(clockOn);    [ if clock is now off    if (!clockOn) {      [ force status line to redraw which       [ removes clock text from status line      status.line.on();       } else {      [ force clock to update this cycle      clearStatusSeconds = 255;     }  }}  [ ***********************[ NON-CONTROLLER CHECKS[ *********************** [ saving a cursorif (saveCursor) {  reset(saveCursor);  [ copy s16 into designated cursor msg value  [ v227 is cursor index value in cp.Mouse logic  work1 = v227;  work1 += 40;  work2 = 16;  block(SET.MSG, 1, &work1, &work2); [ set.msg(BYVAR, MSGOLD, STRNEW)   [ provide feedback  print.at("Cursor saved.", 14, 19, 15);}[ restore a cursorif (restoreCursor) {  reset(restoreCursor);  [ copy default of designated cursor into current designated cursor  set.string(s12, "%m");  work1 = v227;  work1 += 46;  set.string(s13, "%v46");  block(STR.FORMAT, &s13, &s13, 0); [ str.format(sINPUT, sRESULT)  block(STR.CONCAT, &s12, &s13, 0); [ sINPUT, sADD)  block(STR.FORMAT, &s12, &s12, 0); [ str.format(sINPUT, sRESULT)  [ now copy it to the current cursor msgnum  work1 -= 6;  work2 = 12;  block(SET.MSG, 1, &work1, &work2); [ set.msg(BYVAR, MSGOLD, STRNEW)  [ force update by resetting the cursor index  v227 = -1;  [ provide feedback  print.at("Cursor restored.", 14, 19, 17);}[ if clock display is neededif (clockOn && !disableGameFunctions) {  [ update the displayed clock whenever  [ the second value changes  if (clearStatusSeconds != elapsedSeconds) {    [ need to set correct color values    set.text.attribute(BLACK, WHITE);    [ update the clock    display(0, 18, " %v13:%v12|2:%v11|2 ");    [ restore default colors    set.text.attribute(WHITE, BLACK);    [ update the stored seconds value    clearStatusSeconds = elapsedSeconds;  }}[ if this is first cycle since restore game executedif (isset(gameRestored)) {  [ make sure input area is cleared  clear.lines(23, 24, 0);  [ debugging off by default  reset(debugging);  [ need to 're-disable menu separators)  disable.item(cLeftDblClick);}[ IMPORTANT: This calls the logic for the current room - this[ is not done automatically by the interpreter so it has to be[ called manually by logic 0.call.v(currentRoom);[ if debugging is active                if (debugging) {  [ call the debugging logic  call(lgc.Debug);}[ run game specific functions only if they are not disabledif (!disableGameFunctions) {  call(lgc.GameFunctions); }  [check player input for unknown wordsif (haveInput && !haveMatch && unknownWordNum > 0) {  reset(haveInput);  [copy word to a string  if (unknownWordNum == 1) {    word.to.string(unknownWord, w1);  }  if (unknownWordNum == 2) {    word.to.string(unknownWord, w2);  }  if (unknownWordNum == 3) {    word.to.string(unknownWord, w3);  }  if (unknownWordNum == 4) {    word.to.string(unknownWord, w4);  }  if (unknownWordNum == 5) {    word.to.string(unknownWord, w5);  }  if (unknownWordNum == 6) {    word.to.string(unknownWord, w6);  }  if (unknownWordNum == 7) {    word.to.string(unknownWord, w7);  }  if (unknownWordNum == 8) {    word.to.string(unknownWord, w8);  }  if (unknownWordNum == 9) {    word.to.string(unknownWord, w9);  }  if (unknownWordNum == 10) {    word.to.string(unknownWord, w10);  }  [choose a random unknown word response  random(33, 35, rndNum);  print.v(rndNum);}  [ finally, if there is input that hasn't [ been recognized yetif (haveInput && !haveMatch) {  print("I don't understand your request.");  reset(haveInput);}[ save clock values for comparison purposesoldSeconds = elapsedSeconds;oldMinutes = elapsedMinutes;oldHours = elapsedHours;oldDays = elapsedDays;return();[ **************************************[ MESSAGES[ **************************************#message 1 "AGI"#message 2 "About      "#message 3 "Help   <F1>"#message 4 "Debug Help "#message 5 "File"#message 6 "Save     <F5>"#message 7 "Restore  <F7>"#message 8 "-------------"#message 9 "Restart  <F9>"#message 10 "Quit  <Alt-Z>"#message 11 "Action"#message 12 "See Object  <F4>"#message 13 "Inventory  <Tab>"#message 14 "Special"#message 15 "Sound On/Off      <F2>"#message 16 "Color/BW      <Ctrl R>"#message 17 "Clock On/Off      <F6>"#message 18 "Joystick      <Ctrl J>"#message 19 "Pause            <Esc>"#message 20 "Speed"#message 21 "Normal "#message 22 "Slow   "#message 23 "Fast   "#message 24 "Fastest"#message 25 "Debug"#message 26 "Ego Info   <Alt-E>"#message 27 "Pri Screen <Alt-P>"#message 28 "Memory     <Alt-M>"#message 29 "Obj Info   <Alt-I>"#message 30 "Coords     <Alt-X>"#message 31 "Get All           "#message 32 " %v13:%v12|2:%v11|2 "#message 33 "I don't understand \"%s2\""#message 34 "\"%s2\" is not in my vocabulary."#message 35 "What is \"%s2\""#message 36 "I don't understand your request."#message 37 "Debug Help        "#message 38 gameAboutMsg#message 39 gameVersionMsg[ active cursors#message 40 "0000FF3FFF1FFF0FFF07FF03FF01FF007F003F001F00FF01FF00FF307FF87FF8FFFC"            "00000040006000700078007C007E007F807F007C006C00460006000300030000"[ walk#message 41 "040FFFF1FFE07FC07FC0FFE0FFF1FFE17FC03FC07FE0FFE1FFC1FF80FF087F183FBC"            "0000000E001D001F000E0004000C0016801B0006000C001C0036006200430000"[ look#message 42 "0709FFFFFFFFFFFFFFFEEFF62DB40BD0024001808001018003C00FF03FFCFFFFFFFF"            "000000000000000000000000C003F00F7C3E3E7C7C3EF00FC003000000000000"[ talk#message 43 "050E1FF807E0018000000000000000000000008001E007FC0FFE3FFC7FF8FFF9FFFF"            "0000E007F81FFE7FFE7FFE7FFE7FFE7FFE1FF803F000C0008001000200000000"[ use #message 44 "0706FFFFFFFF1FFE07F801F000F000F000F00090000000000000018001C003E007F0"            "000000000000C000D806DA06DA06DA06DA06FA6FFE7FFE7FFC3FFC1FF80F0000"[ wait #message 45 "0707018003C003C007E007E00FF01FF83FFC3FFC1FF80FF007E007E003C003C00180"            "0000F81FF81F5005A00A40058002000180004003E007700E1008081000000000"[ default cursors#message 46 "0000FF3FFF1FFF0FFF07FF03FF01FF007F003F001F00FF01FF00FF307FF87FF8FFFC"            "00000040006000700078007C007E007F807F007C006C00460006000300030000"[ walk#message 47 "040FFFF1FFE07FC07FC0FFE0FFF1FFE17FC03FC07FE0FFE1FFC1FF80FF087F183FBC"            "0000000E001D001F000E0004000C0016801B0006000C001C0036006200430000"[ look#message 48 "0709FFFFFFFFFFFFFFFEEFF62DB40BD0024001808001018003C00FF03FFCFFFFFFFF"            "000000000000000000000000C003F00F7C3E3E7C7C3EF00FC003000000000000"[ talk#message 49 "050E1FF807E0018000000000000000000000008001E007FC0FFE3FFC7FF8FFF9FFFF"            "0000E007F81FFE7FFE7FFE7FFE7FFE7FFE1FF803F000C0008001000200000000"[ use #message 50 "0707FFFFFFFF1FFE07F801F000F000F000F00090000000000000018001C003E007F0"            "000000000000C000D806DA06DA06DA06DA06FA6FFE7FFE7FFC3FFC1FF80F0000"[ wait#message 51 "0707018003C003C007E007E00FF01FF83FFC3FFC1FF80FF007E007E003C003C00180"            "0000F81FF81F5005A00A40058002000180004003E007700E1008081000000000"            #message 52 "%s16"#message 53 "02021703F1F30181000000"#message 54 "02021703F1F30181000000"#message 55 "02021703F1F30181000000"#message 56 "02021703F1F30181000000"#message 57 "02021703F1F30181000000"