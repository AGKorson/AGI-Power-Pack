[*********************************************************************
[
[ cp.ERIDOCC
[
[ Emulated Rodent Input Device Option Control Console
[
[ This console lets the player modify the cursors used in the game. 
[ There are six different cursors that can be edited:
[  - normal
[  - walk
[  - look
[  - use
[  - talk
[  - hourglass
[
[ When editing, use left-click to set a pixel, right-click to clear a
[ pixel (or press SPACEBAR to toggle the currently selected pixel).
[
[ Cursors can be saved to a file so you can easily imort them into 
[ another Power Pack enabled game. Open the file in a hex editor and
[ copy the hex string for your cursor. (The cursor name is included
[ to help identify it.)
[
[*********************************************************************

[ power pack support
#include "powerpack.txt"

[***************************************
[ LOCAL DEFINES
[***************************************
#define oCursorB       o1  [ need four objects for cursor otherwise
#define oCursorT       o2  [ text gets erased
#define oCursorL       o3
#define oCursorR       o4
#define optCursor      o5
#define gridCursor     o6

[ loop values assigned to cursor objects
#define LP_OPT      0 [ option button states
#define LP_CF_OPT   1 [ cursor frame for mouse/keyb option buttons
#define LP_CF_CMD   2 [    "     "    "  OK, cancel, etc. command buttons
#define LP_CF_IDX   3 [    "     "    "  index buttons
#define LP_CF_TXT   4 [    "     "    "  textboxes

#define cursorpos    v220
#define newpos       v221
#define    CP_MOUSE   1
#define    CP_KEYB    2
#define    CP_IDX_DN  3
#define    CP_IDX_UP  4
#define    CP_PREVIEW 5
#define    CP_SAVE    6
#define    CP_RESTORE 7
#define    CP_EXPORT  8
#define    CP_EXIT    9
#define    CP_GRID   10
#define    CP_HOTX   11
#define    CP_HOTY   12
#define gridX        v222
#define gridY        v223
#define gridmode     v224
#define tmpX         v225
#define tmpY         v226
#define cIndex       v227
#define newIndex     v228
#define cursorX      v229  [ location of selected button/grid item
#define cursorY      v230
#define btnAction    v231
#define    B_IDX_UP   1
#define    B_IDX_DN   2
#define    B_PREVIEW  3
#define    B_SAVE     4
#define    B_RESTORE  5
#define    B_EXPORT   6
#define    B_EXIT     7
#define    B_SETGRID  8
#define    B_RSTGRID  9
#define    B_HOTX    10
#define    B_HOTY    11
#define egoPrevX     v232
#define egoPrevY     v233
#define egoPrevDir   v234
#define vView        v235
#define vLoop        v236
#define vCel         v237
#define vPri         v238
#define vMgn         v239
#define byteval      v240
#define bitctr       v241
#define strctr       v242
#define hotX         v243
#define hotY         v244
#define hotXraw      v245
#define hotYraw      v246
#define oldHotval    v247
#define tmpRow       v248
#define tmpCol       v249
#define oldSpeed     v250

#define update       f220
#define cursormode   f221
#define refresh      f222 [ used to redraw text on screen when the screen is first displayed
#define updategrid   f223
#define fOnGrid      f224
#define fChgCursor   f225
#define tmpFlag      f226
#define flipbyte     f227
#define maskgrid     f228
#define prevcursor   f229

#define sTemp         s12 [ uses s12, s13, s14, s15
#define sCursor       s16 [ uses s16, s17, s18, s19
#define sByte         s20 [ contains byte currently being modified
#define sHotspot      s21 [ used to help set/display cursor hotspot


#define sFilename     s21 [ re-use hotspot string
#define sBadChars     s22
#define sTempFile     s23

[***************************************
[ ERROR CHECK
[***************************************
[ if this control panel is not enabled show error screen
if (!enableERIDOCC) {
  if (newRoom) {
    work1 = pic.cp.Error;
    load.pic(work1);
    draw.pic(work1);
    discard.pic(work1);
    show.pic();
    set.text.attribute(PUSH.ATTRIBUTES, 0); [ push.attributes()
    set.text.attribute(GREEN, BLACK);
    display(1, 1, "> subsystem error");
    set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
    block(FADE.IN, BYNUM, FADECOUNT, BLACK); [ fade.in(FN_MODE, DELAY, COLOR)
    lastChar = 0;
  }
  [ any key, or any mouse-click to exit
  if ((have.key() || controller(cLeftClick) || controller(cRightClick))) {
    [ fade out 
    block(FADE.OUT, BYNUM, FADECOUNT, BLACK);  [ fade.out(FN_MODE, DELAY, COLOR)
    new.room(rm.ControlRoom); [ ##LE001##
  }
  return();
}

[***************************************
[ FIRST CYCLE ONLY
[***************************************
if (newRoom) {
  [ if first time, score it
  work1 = cpusage;
  block(BIT.AND, BYNUM, &work1, 32); [ bit.and(FN_MODE, VAR, MASK)
  if (work1 == 0) {
    work1 = 5;
    call(lgc.ScoreHandler);
    block(BIT.OR, BYNUM, &cpusage, 32); [ bit.or(FN_MODE, VAR, MASK)
  }
  
  load.pic(currentRoom);
  draw.pic(currentRoom);
  discard.pic(currentRoom);
  
  load.logics(lgc.GameFunctions);
  
  [ this view has all the art for cursors and buttons
  load.view(vw.cp.ERIDOCC);

  [ option button that determines input mode; mouse or keyboard
  animate.obj(optCursor);
  set.view(optCursor, vw.cp.ERIDOCC);
  set.loop(optCursor, LP_OPT);
  set.cel(optCursor, 0);
  stop.cycling(optCursor);
  position(optCursor, 8, 65);
  draw(optCursor);
  
  [ cursor is in four parts; used to highlight command buttons
  [ and option buttons
  animate.obj(oCursorB);
  ignore.objs(oCursorB);
  set.view(oCursorB, vw.cp.ERIDOCC);
  set.loop(oCursorB, LP_CF_OPT);
  set.cel(oCursorB, 0);
  stop.cycling(oCursorB);
  set.priority(oCursorB, 15);
  position(oCursorB, 30, 65);
  
  animate.obj(oCursorT);
  ignore.objs(oCursorT);
  set.view(oCursorT, vw.cp.ERIDOCC);
  set.loop(oCursorT, LP_CF_OPT);
  set.cel(oCursorT, 0);
  stop.cycling(oCursorT);
  set.priority(oCursorT, 15);
  position(oCursorT, 30, 54);
  
  animate.obj(oCursorL);
  ignore.objs(oCursorL);
  set.view(oCursorL, vw.cp.ERIDOCC);
  set.loop(oCursorL, LP_CF_OPT);
  set.cel(oCursorL, 1);
  stop.cycling(oCursorL);
  set.priority(oCursorL, 15);
  position(oCursorL, 30, 64);
  
  animate.obj(oCursorR);
  ignore.objs(oCursorR);
  set.view(oCursorR, vw.cp.ERIDOCC);
  set.loop(oCursorR, LP_CF_OPT);
  set.cel(oCursorR, 1);
  stop.cycling(oCursorR);
  set.priority(oCursorR, 15);
  position(oCursorR, 47, 65);
  
  [ default cursorpos is keyboard option button
  cursorpos = 2;
  newpos = 2;
  
  [ grid cursor object
  animate.obj(gridCursor);
  set.priority(gridCursor, 15);
  position(gridCursor, 57, 44);
  set.view(gridCursor, vw.cp.ERIDOCC);
  set.loop(gridCursor, 5);
  work1 = 2;
  cycle.time(gridCursor, work1);
  
  [ no text input in this room
  prevent.input();
  lastChar = 0;
  [ arrow keys control cursor here
  egoDir = 0;
  
  [ mouse is enabled, but not cursor
  reset(cursormode);
  btnAction = 0;
  
  [ no ego in this room, but cache ego movement parameters 
  [ (to be restored when returning to the control room)
  egoPrevX = egoX;
  egoPrevY = egoY;
  egoPrevDir = egoDir;
  
  [ set speed to fast for best mouse performance
  oldSpeed = animationInterval;
  animationInterval = FAST_SPEED;

  [ blank out end of export string (39 spaces, one null char)
  s19 = "                                       ";
  
  [ need to show the pic before text can be added
  show.pic();
  
  [ disable scripting for rest of activity in this room
  set(noScript);
  
  [ setup for hotspot add.to.pic
  vView = vw.cp.ERIDOCC;
  vLoop = 6;
  vPri = 14; 
  vMgn = 4;
}

[***************************************
[ MAIN CODE BLOCK 
[***************************************

[ check for preview mode
if (prevcursor) {
  if ((controller(cLeftClick) || have.key())) {
    reset(prevcursor);
    if (cursormode) {
      [ hide the mouse
      disable.item(mouse);
    } else {
      [ force cusor to update
      set(fChgCursor);
    }
  }
  return();
}

[ if room is being drawn or redrawn, need to add text
if ((newRoom || refresh)) {
  [ push display colors
  set.text.attribute(PUSH.ATTRIBUTES, 0); [ push.attributes()
  
  [ add button text
  set.text.attribute(BLACK, WHITE);
  display(12, 1, "Preview");
  display(14, 1, " Save  ");
  display(16, 1, "Restore");
  display(18, 1, "Export ");
  display(20, 1, " Exit  ");
  display(4, 22, "\x11");
  display(4, 32, "\x10");
  
  set.text.attribute(BLACK, LT_GRAY);
  display(6, 2, "   Mode");
  display(8, 4, "Ms");
  display(8, 10, "Kb");
  
  display(15, 9, "GRID");
  display(16, 9, "X:");
  display(17, 9, "Y:");
  
  display(20, 11, "HOTSPOT");
  display(20, 19, "X:");
  display(20, 29, "Y:");
  
  display(3, 24, "CURSOR:");
  [ default cursor starts
  display(4, 24, "default");
  [ pop display colors
  set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
  
  if (newroom) {
    [ force cursor update
    cIndex = -1;
    newIndex = 0;
    goto(checkindex);
  } else {
    reset(refresh);
  }
  return();
}

[ is cursor in text mode?
if (cursormode) {
  [ check for direction arrow keypress
  if (egoDir != STOPPED) {
    [ cursor up
    if (egoDir == UP) {
      if (cursorpos == CP_PREVIEW) {
        newpos = CP_MOUSE;
      }
      if (cursorpos > CP_PREVIEW && cursorpos <= CP_EXIT) {
        --newpos;
      }
      if (cursorpos == CP_GRID) {
        if (gridY == 0) {
          if (gridmode == 0) {
            newpos = CP_IDX_DN;
          } else {
            newpos = CP_IDX_UP;
          }
        } else {
          --gridY;
          set(updateGrid);
        }
      }
      
      if (cursorpos == CP_HOTX) {
        newpos = CP_GRID;
        gridmode = 0;
        gridX = 13;
        gridY = 15;
        set(updategrid);
      }
      
      if (cursorpos == CP_HOTY) {
        newpos = CP_GRID;
        gridmode = 1;
        gridX = 8;
        gridY = 15;
        set(updategrid);
      }
    }
    
    [ cursor right
    if (egoDir == RIGHT) {
      if (cursorpos == CP_MOUSE) {
        newpos = CP_KEYB;
      }
      
      if (cursorpos == CP_KEYB) {
        newpos = CP_GRID;
        gridmode = 0;
        gridX = 0;
        gridY = 3;
         set(updateGrid);
      }       
      
      if (cursorpos == CP_IDX_DN) {
        newpos = CP_IDX_UP;
      }
      
      if (cursorpos > CP_IDX_UP && cursorpos < CP_EXPORT) {
        newpos = CP_GRID;
        gridmode = 0;
        gridX = 0;
        if (cursorpos == CP_PREVIEW) {
          gridY = 8;
        }
        if (cursorpos == CP_SAVE) {
          gridY = 11;
        }
        if (cursorpos == CP_RESTORE) {
          gridY = 14;
        }
        set(updateGrid);
      }
      
      if ((cursorpos == CP_EXIT || cursorpos == CP_EXPORT)) {
        newpos = CP_HOTX;
      }
      
      if (cursorpos == CP_HOTX) {
        newpos = CP_HOTY;
      }
       
      if (cursorpos == CP_GRID) {
        if (gridmode == 0) {
          ++gridX;
          if (gridX == 16) {
            gridmode = 1;
            gridX = 0;
          }
          set(updategrid);
        } else {
          if (gridX < 15) {
            ++gridX;
            set(updategrid);
          }
        }
      }
    } [ right
    
    [ cursor down
    if (egoDir == DOWN) {
      if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {
        newpos = CP_PREVIEW;
      }
      
      if (cursorpos == CP_IDX_DN) {
        newpos = CP_GRID;
        gridmode = 0;
        gridX = 10;
        gridY = 0;
        set(updategrid);
      }
      if (cursorpos == CP_IDX_UP) {
        newpos = CP_GRID;
        gridmode = 1;
        gridX = 6;
        gridY = 0;
        set(updategrid);
      }
      
      if (cursorpos > CP_IDX_UP && cursorpos < CP_EXIT) {
        ++newpos;
      }
      
      if (cursorpos == CP_GRID) {
        if (gridY == 15) {
          if (gridmode) {
            newpos = CP_HOTY;
          } else {
            newpos = CP_HOTX;
          }
        }
        if (gridY < 15) {
          ++gridY;
          set(updategrid);
        }
      }
    } [ down
    
    [ cursor left
    if (egoDir == LEFT) {
      if (cursorpos == CP_KEYB) {
        newpos = CP_MOUSE;
      }
      
      if (cursorpos == CP_IDX_UP) {
        newpos = CP_IDX_DN;
      }
      
      if (cursorpos == CP_HOTX) {
        newpos = CP_EXIT;
      }
      
      if (cursorpos == CP_HOTY) {
        newpos = CP_HOTX;
      }
      
      if (cursorpos == CP_GRID) {
        if (gridmode == 0) {
          if (gridX > 0) {
            --gridX;
            set(updategrid);
          } else {
            if (gridY < 6) {
              newpos = CP_KEYB;
            } else {
              if (gridY < 10) {
                newpos = CP_PREVIEW;
              } else {
                if (gridY < 13) {
                  newpos = CP_SAVE;
                } else {
                  newpos = CP_RESTORE;
                }
              }
            }
          }
        } else {
          if (gridX > 0) {
            --gridX;
          } else {
            gridmode = 0;
            gridX = 15;
          }
          set(updategrid);
        }
      } [ grid
    } [ left
    
    [ always reset dir so another keypress can be detected
    egoDir = 0;
    
    [ check for new cursor position
    if (cursorpos != newpos) {
      [ if moving FROM grid to some other button
      if (cursorpos == CP_GRID && newpos != CP_GRID) {
        [ remove coordinates display
        set.text.attribute(PUSH.ATTRIBUTES, 0); [ push.attributes()
        set.text.attribute(BLACK, LT_GRAY);
        display(16, 12, "  ");
        display(17, 12, "  ");
        set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
      }
      
      [ update the position
      cursorpos = newpos;
      [ depending on where cursor is, set the position and size/shape

      [ option buttons
      if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {
        set.loop(oCursorB, LP_CF_OPT);
        set.loop(oCursorT, LP_CF_OPT);
        set.loop(oCursorL, LP_CF_OPT);
        set.loop(oCursorR, LP_CF_OPT);
        
        cursorY = 65;
        if (cursorpos == CP_MOUSE) {
          cursorX = 7;
        } else {
          cursorX = 31;
        }
      }
      
      [ index up/down buttons
      if ((cursorpos == CP_IDX_DN || cursorpos == CP_IDX_UP)) {
        set.loop(oCursorB, LP_CF_IDX);
        set.loop(oCursorT, LP_CF_IDX);
        set.loop(oCursorL, LP_CF_IDX);
        set.loop(oCursorR, LP_CF_IDX);
        cursorY = 32;
        cursorX = cursorpos;
        cursorX -= 3;
        cursorX *= 40;
        cursorX += 87;
      }
      
      [ Preview, Save, Restore, Exit, Cancel buttons
      if (cursorpos >= CP_PREVIEW && cursorpos <= CP_EXIT) {
        set.loop(oCursorB, LP_CF_CMD);
        set.loop(oCursorT, LP_CF_CMD);
        set.loop(oCursorL, LP_CF_CMD);
        set.loop(oCursorR, LP_CF_CMD);
        
        cursorX = 3;
        [ convert cursorpos into desired y value
        cursorY = cursorpos;
        cursorY -= 5;
        cursorY *= 16;
        cursorY += 96;
      }
      
      [ hotspot text boxes
      if ((cursorpos == CP_HOTX || cursorpos == CP_HOTY)) {
        set.loop(oCursorB, LP_CF_TXT);
        set.loop(oCursorT, LP_CF_TXT);
        set.loop(oCursorL, LP_CF_TXT);
        set.loop(oCursorR, LP_CF_TXT);
        cursorY = 161;
        cursorX = cursorpos;
        cursorX -= 11;
        cursorX *= 40;
        cursorX += 86;
      }
      
      [ to move cursor, erase it first, otherwise, it will
      [ clear any text that is present anywhere between the
      [ new position and the old position
      erase(oCursorB);
      erase(oCursorL);
      erase(oCursorT);
      erase(oCursorR);
      
      [ if not on grid, draw the cursor frame
      if (cursorpos != CP_GRID) {
        [ hide grid cursor
        erase(gridCursor);
        [ reposition the four-part cursor frame and show it
        position.v(oCursorB, cursorX, cursorY);
        draw(oCursorB);
        --cursorY;
        [ save ypos to restore it later
        work1 = cursorY;
        position.v(oCursorL, cursorX, cursorY);
        draw(oCursorL);
        [ adjust for height (depends on button type)
        if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {
          cursorY -= 10;
        }
        if (cursorpos > CP_KEYB && cursorpos < CP_GRID) {
          cursorY -= 8;
        } 
        if ((cursorpos == CP_HOTX || cursorpos == CP_HOTY)) {
            cursorY -= 10;
        }
        position.v(oCursorT, cursorX, cursorY);
        draw(oCursorT);
        [ reset y
        cursorY = work1;
        [ adjust for width
        if (cursorpos < CP_IDX_DN) {
          cursorX += 17;
        } 
        if ((cursorpos == CP_IDX_DN || cursorpos == CP_IDX_UP)) {
          cursorX += 5;
        }
        if (cursorpos > CP_IDX_UP && cursorpos < CP_GRID) {
          cursorX += 29;
        }
        if (cursorpos > CP_GRID) {
          cursorX += 19;
        }
        position.v(oCursorR, cursorX, cursorY);
        draw(oCursorR);
      } else {
        [ draw the grid cursor
        draw(gridCursor);
      }
    }
    
    [ did grid cursor move?
    if (updategrid) {
      reset(updategrid);
      tmpX = gridX;
      tmpX *= 3;
      tmpX += 57;
      if (gridmode == 1) {
        tmpX += 53;
      }
      tmpY = gridY;
      tmpY *= 6;
      tmpY += 44;
      reposition.to.v(gridcursor, tmpX, tmpY);
      
      [ update coordinate display
      set.text.attribute(PUSH.ATTRIBUTES, 0); [ push.attributes()
      set.text.attribute(BLACK, LT_GRAY);
      if (gridX < 10) {
        display(16, 12, " %v222");
      } else {
        display(16, 12, "%v222");
      }
      if (gridY < 10) {
        display(17, 12, " %v223");
      } else {
        display(17, 12, "%v223");
      }
      set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
    }
  }
  
  [ check for selection (space/enter for button, space/bkspc for grid
  if (have.key()) {
    [ space and grid
    if (lastChar == 32 && cursorpos == CP_GRID) {
      btnAction = B_SETGRID;
    }
    [ bkspc and grid
    if (lastChar == 8 && cursorpos == CP_GRID) {
      btnAction = B_RSTGRID;
    }
    
    [ space/enter
    if ((lastChar == 32 || lastChar == 13 || lastChar == 10)) {
      [
      if (cursorpos  == CP_MOUSE) {
        [ switch to mouse control
        reset(cursormode);
        enable.item(mouse);
        erase(optCursor);
        position(optCursor, 8, 65);
        draw(optCursor);
        [ erase the cursor objects
        erase(oCursorB);
        erase(oCursorT);
        erase(oCursorL);
        erase(oCursorR);
      }
      
      if (cursorpos  >= CP_PREVIEW && cursorpos <= CP_EXIT) {
        btnAction = cursorpos;
        btnAction -= 2;
      }
      if (cursorpos == CP_IDX_DN && cIndex > 0) {
        btnAction = B_IDX_DN;
      }
      if (cursorpos == CP_IDX_UP && cIndex < 5) {
        btnAction = B_IDX_UP;
      }
      
      if (cursorpos == CP_HOTX) {
        btnAction = B_HOTX;
      }
      if (cursorpos == CP_HOTY) {
        btnAction = B_HOTY;
      }
      
      if (cursorpos == CP_GRID) {
        btnAction = B_SETGRID;
      }
    }
  }
} else {
  [ mouse is active
  
  [ first determine if cursor is over the grid
  reset(tmpFlag);
  if (mouseX > 56 && mouseX < 105 && mouseY > 38 && mouseY < 135) {
    set(tmpFlag);
  }
  if (mouseX > 109 && mouseX < 158 && mouseY > 38 && mouseY < 135) {
    set(tmpFlag);
  }
  [ tmpFlag is set when cursor is over the grid
  if (tmpFlag) {
    [ if the ongrid flag is clear (last cycle was OFF grid)  
    if (!fOnGrid) {
      [ cursor needs to be changed
      set(fChgCursor);
      set(fOnGrid);
    }
  }
  else {
    [ if ongrid flag is set (last cycle was ON grid)
    if (fOnGrid) {
      [ cursor needs to be changed)
      set(fChgCursor);
      reset(fOnGrid);
    }
  }
  
  [ if cursor needs to be changed (going FROM or TO grid)
  if (fChgCursor) {
    reset(fChgCursor);
    if (fOnGrid) {
      sTemp = "%m1";
    }
    else {
      sTemp = "%g30";
      [ also remove coordinates display
      set.text.attribute(PUSH.ATTRIBUTES, 0); [ push.attributes()
      set.text.attribute(BLACK, LT_GRAY);
      display(16, 12, "  ");
      display(17, 12, "  ");
      set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
    }
    [ change the cursor
    set.key(BYNUM, &m2, mouse); [ set.cursor(FN_MODE, mCURSOR)
  }
  
  [ if on grid, determine gridx/gridy/gridmode
  if (fOnGrid) {
    tmpY = mouseY;
    tmpY -= 39;
    tmpY /= 6;
    [ x is a bit more complicated
    tmpX = mouseX;
    if (tmpX > 109) {
      [ on mask grid
      gridmode = 1;
      [ adjust x
      tmpX -= 53;
    } else {
      gridmode = 0;
    }
    tmpX -= 57;
    tmpX /= 3;
    [ if different from current x/y
    if ((tmpX != gridX || tmpY != gridY)) {
      [ update coordinate display
      set.text.attribute(PUSH.ATTRIBUTES, 0); [ push.attributes()
      set.text.attribute(BLACK, LT_GRAY);
      if (tmpX < 10) {
        display(16, 12, " %v225");
      } else {
        display(16, 12, "%v225");
      }
      if (tmpY < 10) {
        display(17, 12, " %v226");
      } else {
        display(17, 12, "%v226");
      }
      set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
    }
    gridX = tmpX;
    gridY = tmpY;
  } else {
    [ clear grid values
    gridX = -1;
    gridY = -1;
  }
  
  
  [ check for mouse clicks 
  
  if (fOnGrid) {
    [ right-click on grid
    if (controller(cRightClick)) {
      [ if on grid, reset the pixel
      btnAction = B_RSTGRID;
    }
    [ left-click on grid
    if (controller(cLeftClick)) {
      [ if on grid, set the pixel
      btnAction = B_SETGRID;
    }  
  } else {
    [ not on grid - check other buttons
    
    [dbl-click on hotspot text
    if (controller(cLeftDblClick)) {
      [ hotX
      if (mouseX > 86 && mouseX < 105 && mouseY > 150 && mouseY < 161) {
        btnAction = B_HOTX;
      }
      [ hotY
      if (mouseX > 126 && mouseX < 145 && mouseY > 150 && mouseY < 161) {
        btnAction = B_HOTY;
      }
    }
    [ left click on all other buttons
    if (controller(cLeftClick)) {
      [ over cursor type keyboard option  54-65
      if (mouseX > 30 && mouseX < 38 && mouseY > 55 && mouseY < 64) {
        [ switch to keyboard cursor
        set(cursormode);
        disable.item(mouse);
        erase(optCursor);
        position(optCursor, 32, 65);
        draw(optCursor);
        [ show the cursor object
        cursorpos = 2;
        newpos = 2;
        position(oCursorB, 31, 65);
        draw(oCursorB);
        position(oCursorT, 31, 54);
        draw(oCursorT);
        position(oCursorL, 31, 64);
        draw(oCursorL);
        position(oCursorR, 48, 64);
        draw(oCursorR);
      }

      [ over PREVIEW button [2, 102 - 33, 129]
      if (mouseX > 2 && mouseX < 33 && mouseY > 86 && mouseY < 97) {
        btnAction = B_PREVIEW;
      }
        
      [ over SAVE button [2, 102 - 33, 113]
      if (mouseX > 2 && mouseX < 33 && mouseY > 102 && mouseY < 113) {
        btnAction = B_SAVE;
      }
        
      [ over RESTORE button [2, 118 - 33, 129]
      if (mouseX > 2 && mouseX < 33 && mouseY > 118 && mouseY < 129) {
        btnAction = B_RESTORE;
      }
        
      [ over EXPORT button [2, 134 - 33, 145]
      if (mouseX > 2 && mouseX < 33 && mouseY > 134 && mouseY < 145) {
        btnAction = B_EXPORT;
      }
      
      [ over EXIT button [2, 150 - 33, 161]
      if (mouseX > 2 && mouseX < 33 && mouseY > 150 && mouseY < 161) {
        btnAction = B_EXIT;
      }
    
      [ over IDX_DN button [86, 22 - 93, 33]
      if (mouseX > 86 && mouseX < 93 && mouseY > 22 && mouseY < 33) {
        if (cIndex > 0) {
          btnAction = B_IDX_DN;
        }
      }
      
      [ over IDX_DN button [126, 22 - 133, 33]
      if (mouseX > 126 && mouseX < 133 && mouseY > 22 && mouseY < 33) {
        if (cIndex < 5) {
          btnAction = B_IDX_UP;
        }
      }
    }
  }
}

[ check for button actions:
if (btnAction == 0) {
  return();
}

[ set/reset a grid pixel
if ((btnAction == B_SETGRID || btnAction == B_RSTGRID)) {

  [ convert grid x/y into byte offset/bit offset
  strctr = gridY;
  strctr *= 4;
  if (gridmode) {
    strctr += 64;
  }
  if (gridX > 7) {
    bitctr = 15;
  } else {
    strctr += 2;
    bitctr = 7;
  }
  bitctr -= gridX;
  work1 = 126;
  work1 -= strctr;
  [ copy right portion of updated cursor to sTemp
  block(STR.RIGHT, &sCursor, &sTemp, &work1); [ str.right(sINPUT, sRESULT, vLEN)
  [ add offsets for hotspot(4) and the target byte(2)
  strctr += 6;
  [ strip off the right portion
  block(STR.LEFT, &sCursor, &sCursor, &strctr); [ str.left(sINPUT, sRESULT, vLEN)
  [ save the byte of interest to a temp string
  work1 = 2;
  block(STR.RIGHT, &sCursor, &sByte, &work1); [ str.right(sINPUT, sRESULT, vLEN)
  [ convert the hex string to a number
  block(HEX2BYTE, &sByte, &work2, 0); [ hex2byte(sINPUT, vRESULT)
  [ then remove that byte
  strctr -= 2;
  block(STR.LEFT, &sCursor, &sCursor, &strctr); [ str.left(sINPUT, sRESULT, vLEN)
  
  [ setup the bitmask
  work1 = 1;
  block(BIT.SHL, BYVAR, &work1, &bitctr); [ bit.shl(FN_MODE, VAR, SHIFT)
  [ convert gridx/y to screen coordinates for add.to.pic
  tmpX = gridX;
  tmpX *= 3;
  tmpX += 57;
  if (gridmode) {
    tmpX += 53;
  }
  tmpY = gridY;
  tmpY *= 6;
  tmpY += 44;
  
  [ set or clear the pixel as needed
  if (btnAction == B_SETGRID) {
    [ set the desired bit in designated byte
    [ combine it with current byte
    block(BIT.OR, BYVAR, &work2, &work1); [ bit.OR(FN_MODE, VAR, MASK)
    [ set cel to add new block to the grid
    vCel = 0;
  } else {
    [ clear the desired bit in the designated byte
    [ invert the mask
    block(BIT.NOT, 0, &work1, 0); [ bit.not(VAR)
    [ combine it with current byte
    block(BIT.AND, BYVAR, &work2, &work1); [ bit.and(FN_MODE, VAR, MASK)
    [ set cel to add new block to the grid
    vCel = 2;
  }
  [ if on hotspot and in first gridbox, show it 
  if (gridX == hotXraw && gridY == hotYraw && !gridmode) {
   ++vCel;
  }
  [ rebuild the string
  block(BYTE2HEX, &sByte, &work2, 0); [ byte2hex(sRESULT, vINPUT)
  block(STR.CONCAT, &sCursor, &sByte, 0); [ str.concat(sINPUT, sADD)
  block(STR.CONCAT, &sCursor, &sTemp, 0); [ str.concat(sINPUT, sADD)
  
  [ update grid
  add.to.pic.v(vView, vLoop, vCel, tmpX, tmpY, vPri, vMgn);
}

if (btnAction == B_EXIT) {
  [ restore ego movement parameters
  egoX = egoPrevX;
  egoY = egoPrevY;
  egoDir = egoPrevDir;
  
  [ restore speed
  animationInterval = oldSpeed;
  
  [ restore scripting
  reset(noScript);
  
  [ fade out 
  block(FADE.OUT, BYNUM, FADECOUNT, BLACK);  [ fade.out(FN_MODE, DELAY, COLOR)
  
  [ go back to previous room
  new.room.v(previousRoom); 
}

if (btnAction == B_PREVIEW) {
  [ change current cursor, wait for any mouse press
  set(prevcursor);
  sTemp = "%s16";
  set.key(BYNUM, &m2, mouse); [ set.cursor(FN_MODE, mCURSOR)
  [ if in text mode, temporarily enable the mouse
  if (cursormode) {
    enable.item(mouse);
  }
  [ make sure key buffer is clear
  lastChar = 0;
}

if (btnAction == B_SAVE) {
  [ to modify (save) the cursor, code must be run
  [ from logic 0
  set(saveCursor);
}

if (btnAction == B_RESTORE) {
  [ load default cursor, overwriting any changes made
  [ (also must be run from logic 0)
  set(restoreCursor);
}

if (btnAction == B_EXPORT) {
  [ build cursor name label
  work1 = cIndex;
  work1 += 14;
  sTemp = "%m";
  s13 = "%v46";
  block(STR.FORMAT, &s13, &s13, 0); [ str.format(sINPUT, sRESULT)
  block(STR.CONCAT, &sTemp, &s13, 0); [ str.concat(sINPUT, sADD)
  block(STR.FORMAT, &sTemp, &sTemp, 0); [ str.format(sINPUT, sRESULT)
  work1 = TRIM_ALL;
  block(STR.TRIM, &sTemp, &sTemp, &work1); [ str.trim(sINPUT, sRESULT, vMODE)
  
  [ get a filename (limit to 12 characters (8.3 format))
  :getfile
  get.string(sFilename, "Enter export file name: ", 22, 0, 12);
  [ clear input line
  prevent.input();
  accept.input();
  
  [ validate it's an 8.3 DOS filename; if not, allow player to try again
  block(STR.LEN, &sFilename, &work1, 0); [ str.len(sINPUT, vRESULT)
  [ if nothing, consider it a cancel
  if (work1 == 0) {
    goto(donesave);
  }
  [ check for single period
  work2 = 46;
  work3 = 0;
  block(INSTR, &sFilename, &work2, &work3); [ instr(sINPUT, vCHAR, vPOS)
  if (work3 > 0) {
    [ must be no further than position 8
    if (work3 > 8) {
      print.at("Invalid filename1: %s20", 14, 19, 16);
      goto(getfile);
    }
    [ only one allowed
    ++work3;
    block(INSTR, &sFilename, &work2, &work3); [ instr(sINPUT, vCHAR, vPOS)
    if (work3 != -1) {
      print.at("Invalid filename: %s20", 14, 19, 16);
      goto(getfile);
    }
  } else {
    [ no period; length can't be more than 8
    if (work1 > 8) {
      print.at("Invalid filename: %s20", 14, 19, 16);
      goto(getfile);
    }
  }
  [ confirm no invalid characters \/:*?"<>|
  sBadChars = "\\/:*?\"<>|";
  block(STR.COPY, &sFilename, &sTempFile, 0); [ str.copy(sINPUT, sRESULT)
  :checkname
    block(STR.RIGHT, &sTempFile, &sTempFile, &work1); [ str.right(sINPUT, sRESULT, vCOUNT)
    [ get 1st char value
    block(CHAR2BYTE, &sTempFile, &work2, 0); [ char2byte(sCHAR, vRESULT)
    work3 = 0;
    block(INSTR, &sBadChars, &work2, &work3); [ instr(sINPUT, vCHAR, vPOS)
    if (work3 != -1) {
      print.at("Invalid filename: %s20", 14, 19, 16);
      goto(getfile);
    }
    --work1;
  if (work1 > 0) {
    goto(checkname);
  }
  
  [ no check for existing file; it's not easy to do; could try reading from the file
  [ -if it returns error might mean it's not there; but error will also happen if
  [ the file exists but it's unable to read all 40 bytes of a string 

  [ checks complete! - createfile, with space for label as first string
  work1 = 15;
  work2 = 19;
  block(NEW.FILE, &sFilename, &work1, &work2); [ new.file(sFILENAME, vSTART, vEND)
  if (errorParameter != 0) {
    print.at("Unkown error- file not saved.", 14, 19, 16);
    errorParameter = 0;
    goto(donesave);
  } 
  [ blank out first string (39 spaces, one null char)
  s15 = "                                       ";
  [ copy label
  block(STR.COPY, &sTemp, &s15, 0); [ str.copy(sINPUT, sRESULT)
  [ now save label at first position
  work1 = 0;
  work2 = &s15;
  block(SAVE.STRING, &sFilename, &work1, &work2); [ save.string(sFILENAME, vINDEX, vSTROUT)
  [ provide feedback
  print.at("Cursor data exported to game directory as '%s21'", 14, 19, 19);
  :donesave
  prevent.input();
}

if (btnAction == B_IDX_DN) {
  --newIndex;
  tmpX = 4;
  tmpY = 24;
  work1 = newIndex;
  work1 += 14;
  set.text.attribute(BLACK, LT_GRAY);
  display.v(tmpX, tmpY, work1);
  [ pop display colors
  set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
}

if (btnAction == B_IDX_UP) {
  ++newIndex;
  tmpX = 4;
  tmpY = 24;
  work1 = newIndex;
  work1 += 14;
  set.text.attribute(BLACK, LT_GRAY);
  display.v(tmpX, tmpY, work1);
  [ pop display colors
  set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
}

[ textboxes
if ((btnAction == B_HOTX || btnAction == B_HOTY)) {

  [ invert the current value to indicate it is selected
  set.text.attribute(PUSH.ATTRIBUTES, 0); [ push.attributes()
  set.text.attribute(WHITE, BLACK);
  tmpRow = 20;
  tmpCol = 22;
  
  [ get temp copy of hotspot value being edited
  if (btnAction == B_HOTX) {
    byteval = hotXraw;
  } else {
    byteval = hotYraw;
    tmpCol += 10;
  }
  oldHotval = byteval;
  
  sByte = " ";
  sHotspot = " %v240";
  
  block(STR.FORMAT, &sHotspot, &sHotspot, 0); [ str.format(sINPUT, sRESULT)
  block(STR.LEN, &sHotspot, &work1, 0); [ str.len(sINPUT, vRESULT)
  work2 = work1;
  [ discount leading space
  --work2;
  [ pad the string to be 4 chars long
  :checkLen
  if (work1 < 4) {
    block(STR.CONCAT, &sHotspot, &sByte, 0); [ str.concat(sINPUT, sADD)
    block(STR.LEN, &sHotspot, &work1, 0); [ str.len(sINPUT, vRESULT)
    goto(checkLen);
  }
  work1 = &m24;
  display.v(tmpRow, tmpCol, work1);
  [ adjust current column to end of text
  tmpCol += work2;
  ++tmpCol;
  [ allow player to press number keys, bkspc/enter/esc/minus;
  [ up to two digits, 0-15
  :getChar
  lastChar = 0;
  if (!have.key()) {
    goto(getChar);
  }
  [ check for number press
  if (lastChar > 47 && lastChar < 58) {
    [ is current value 0 or 1? (OK to add another digit)
    if (byteval < 2) {
      [ if value is 1, OR pressing something OTHER THAN 0
      if ((byteval > 0 || lastChar > 48)) {
        [ if already a 1, limit next digit to 5
        if (byteval == 1 && lastChar > 53) {
          lastChar = 53;
        }
        [ convert the pressed char into a string
        block(BYTE2CHAR, &sByte, &lastChar, 0); [ byte2char(sRESULT, vCHAR)
        [ if an actual zero is displayed (value of zero, len=1)
        if (byteval == 0 && work2 > 0) {
          [ replace the zero with whatever is typed -
          [ back up column, decrement length
          --tmpCol;
          --work2;
        }
        [ display the char
        work1 = &m49;
        display.v(tmpRow, tmpCol, work1);
        [ update cursorpos and length
        ++tmpCol;
        ++work2;
        [ recalculate the value
        byteval *= 10;
        byteval += lastChar;
        byteval -= 48;
      } else {
        [value = 0 and char=0; ignore unless line is completely
        [ blank (length =0)
        if (work2 == 0) {
          block(BYTE2CHAR, &sByte, &lastChar, 0); [ byte2char(sRESULT, vCHAR)
          work1 = &m49;
          display.v(tmpRow, tmpCol, work1);
          ++tmpCol;
          ++work2;
        }
      }
    }
    goto(getChar);
    
  } else {
    [ check for backspace, escape, enter
    if ((lastChar == 8 || lastChar == 13 || lastChar == 27)) {
      if (lastChar == 8) {
        [ backspace
        if (work2 > 0) {
          if (byteval > 0) {
            byteval /= 10;
          }
          --work2;
          --tmpCol;
          work1 = &m43;
          display.v(tmpRow, tmpCol, work1);
        }
        goto(getChar);
      }
  
      if (lastChar == 13) {
        [ limit value to 0 to +15 
        if (byteval > 15) {
          byteval = 15;
        }

        [ rebuild hotspot value
        sByte = " ";
        sHotspot = " %v240";
        block(STR.FORMAT, &sHotspot, &sHotspot, 0); [ str.format(sINPUT, sRESULT)
        block(STR.LEN, &sHotspot, &work1, 0); [ str.len(sINPUT, vRESULT)
        :checkLen2
        if (work1 < 4) {
          block(STR.CONCAT, &sHotspot, &sByte, 0); [ str.concat(sINPUT, sADD)
          block(STR.LEN, &sHotspot, &work1, 0); [ str.len(sINPUT, vRESULT)
          goto(checkLen2);
        }
        
        [ if value hasn't changed, do nothing
        if (byteval != oldHotval) {
        
          [ unmark old:
          [ convert hot x/y into byte offset/bit offset
          strctr = hotYraw;
          strctr *= 4;
          if (hotXraw > 7) {
            bitctr = 15;
          } else {
            strctr += 2;
            bitctr = 7;
          }
          bitctr -= hotXraw;
          strctr += 4;
          work1 = 2;
          [ copy cursor to sTemp
          block(STR.COPY, &sCursor, &sTemp, 0); [ str.copy(sINPUT, sRESULT)
          [ get byte of interest
          block(STR.MID, &sTemp, &strctr, &work1); [ str.mid(sINPUT, vPOS, vLEN)
          [ convert the hex string to a number
          block(HEX2BYTE, &sTemp, &work3, 0); [ hex2byte(sINPUT, vRESULT)
  
          [ setup the bitmask
          work1 = 1;
          block(BIT.SHL, BYVAR, &work1, &bitctr); [ bit.shl(FN_MODE, VAR, SHIFT)
          [ apply bitmask to byte of interest
          block(BIT.AND, BYVAR, &work3, &work1); [ bit.and(FN_MODE, VAR, MASK)
          
          [ convert hotx/y to screen coordinates for add.to.pic
          tmpX = hotXraw;
          tmpX *= 3;
          tmpX += 57;
          tmpY = hotYraw;
          tmpY *= 6;
          tmpY += 44;
          
          [ set or clear the pixel as needed
          if (work3) {
            [ set the desired bit in designated byte
            vCel = 0;
          } else {
            vCel = 2;
          }
          
          [ update grid
          add.to.pic.v(vView, vLoop, vCel, tmpX, tmpY, vPri, vMgn);
          
          [ update the changed value
          if (btnAction == B_HOTX) {
            hotXraw = byteval;
          } else {  
            hotYraw = byteval;
          }

          [ rebuild the cursor string
          block(BYTE2HEX, &sByte, &hotXraw, 0); [ byte2hex(sRESULT, vINPUT)
          block(BYTE2HEX, &sTemp, &hotYraw, 0); [ byte2hex(sRESULT, vINPUT)
          block(STR.CONCAT, &sByte, &sTemp, 0); [ str.concat(sINPUT, sADD)
          work1 = 128;
          block(STR.RIGHT, &sCursor, &sTemp, &work1); [ str.right(sINPUT, sRESULT, vLEN)
          block(STR.COPY, &sByte, &sCursor, 0); [ str.copy(sINPUT, sRESULT)
          block(STR.CONCAT, &sCursor, &sTemp, 0); [ str.concat(sINPUT, sADD)

          [ add mark for new hotspot:
          [ convert hot x/y into byte offset/bit offset
          strctr = hotYraw;
          strctr *= 4;
          if (hotXraw > 7) {
            bitctr = 15;
          } else {
            strctr += 2;
            bitctr = 7;
          }
          bitctr -= hotXraw;
          strctr += 4;
          work1 = 2;
          [ copy cursor to sTemp
          block(STR.COPY, &sCursor, &sTemp, 0); [ str.copy(sINPUT, sRESULT)
          [ get byte of interest
          block(STR.MID, &sTemp, &strctr, &work1); [ str.mid(sINPUT, vPOS, vLEN)
          [ convert the hex string to a number
          block(HEX2BYTE, &sTemp, &work3, 0); [ hex2byte(sINPUT, vRESULT)
  
          [ setup the bitmask
          work1 = 1;
          block(BIT.SHL, BYVAR, &work1, &bitctr); [ bit.shl(FN_MODE, VAR, SHIFT)
          [ apply bitmask to byte of interest
          block(BIT.AND, BYVAR, &work3, &work1); [ bit.and(FN_MODE, VAR, MASK)
          
          [ convert hotx/y to screen coordinates for add.to.pic
          tmpX = hotXraw;
          tmpX *= 3;
          tmpX += 57;
          tmpY = hotYraw;
          tmpY *= 6;
          tmpY += 44;
          
          [ set or clear the pixel as needed
          if (work3) {
            [ set the desired bit in designated byte
            vCel = 1;
          } else {
            vCel = 3;
          }
          
          [ update grid
          add.to.pic.v(vView, vLoop, vCel, tmpX, tmpY, vPri, vMgn);
        }
      }
      
      if (lastChar == 27) {
        [ if esc pressed, exit without changing
      }
      
    } else {
      [ ignore all others
      goto(getChar);
    }
  }
  
  [ always restore hs textbox
  set.text.attribute(BLACK, WHITE);
  work1 = &m24;
  tmpCol -= work2;
  [ adjust backward to account for trailing space
  --tmpCol;
  display.v(tmpRow, tmpCol, work1);
  set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
}

[ always reset button action
btnAction = 0;
lastChar = 0;

:checkindex
[ if index has changed, draw a new cursor
if (newIndex != cIndex) {
  cIndex = newIndex;
  cIndex += 30;
  sCursor = "%g";
  s17 = "%v227";
  block(STR.FORMAT, &s17, &s17, 0); [ str.format(sINPUT, sRESULT)
  block(STR.CONCAT, &sCursor, &s17, 0); [ str.concat(sINPUT, sADD)
  block(STR.FORMAT, &sCursor, &sCursor, 0); [ str.format(sINPUT, sRESULT)
  [ extract out hotspot coordinates
  work1 = 4;
  block(STR.LEFT, &sCursor, &sHotspot, &work1); [ str.left(sINPUT, sRESULT, vLEN)
  block(HEX2BYTE, &sHotspot, &hotX, 0); [ hex2byte(sINPUT, vRESULT)
  work1 = 2;
  block(STR.RIGHT, &sHotspot, &sHotspot, &work1); [ str.right(sINPUT, sRESULT, vLEN)
  block(HEX2BYTE, &sHotspot, &hotY, 0); [ hex2byte(sINPUT, vRESULT)
  [ update hotspot coordinate display
  set.text.attribute(PUSH.ATTRIBUTES, 0); [ push.attributes()
  set.text.attribute(BLACK, WHITE);
  if (hotX > 15) {
    [ limit to 15
    hotX = 15;
  } 
  hotXraw = hotX;
  display(20, 22, " %v243 ");
  
  if (hotY > 15) {
    [ limit to 15
    hotY = 15;
  }
  hotYraw = hotY;
  display(20, 32, " %v244 ");
  set.text.attribute(0, POP.ATTRIBUTES); [ pop.attributes()
  [ convert to grid offsets
  [ to be able to compare when adding cels
  hotX *= 3;
  hotX += 57;
  hotY *= 6;
  hotY += 44;
  
  [ step through one bit at a time to determine if pixels are set or clear
  strctr = 128;
  tmpY = 44;
  reset(maskgrid);
:nextbyte
  block(STR.RIGHT, &sCursor, &sTemp, &strctr); [ str.right(sINPUT, sRESULT, vLEN)
  [ get the next byte value
  block(HEX2BYTE, &sTemp, &byteval, 0); [ hex2byte(sINPUT, vRESULT)
  
  work1 = strctr;
  work1 /= 4;
  work1 *= 4;
  if (work1 == strctr) {
    set(flipbyte);
  } else {
    reset(flipbyte);
  }
  
  [ adjust column based on flipbyte value and mask being drawn
  if (maskgrid) {
    tmpX = 110;
  } else {
    tmpX = 57;
  }
  if (flipbyte) {
    tmpX += 24;
  }
  
  [ step through all eight bits
  bitctr = 128;
:nextbit
  work1 = byteval;
  block(BIT.AND, BYVAR, &work1, &bitctr); [ bit.and(FN_MODE, VAR, MASK)
  
  if (work1) {
    [ draw a block
    vCel = 0;
  } else {
    [ clear the block
    vCel = 2;
  }
  if (tmpX == hotX && tmpY == hotY) {
    ++vCel;
  }
  add.to.pic.v(vView, vLoop, vCel, tmpX, tmpY, vPri, vMgn);
  
  bitctr /= 2;
  if (bitctr) {
    tmpX += 3;
    goto(nextbit);
  }
  
  [ load next byte
  strctr -= 2;
  if (strctr > 0) {
    if (!flipbyte) {
      [ set correct row
      tmpY += 6;
      if (tmpY == 140) {
        tmpY = 44;
        set(maskgrid);
      }
    }
    goto(nextbyte);
  }

  cIndex = newIndex;
  
  if (newroom) {
    [ remember to fade in to be able to see the screen again
    block(FADE.IN, BYNUM, FADECOUNT, BLACK); [ fade.in(FN_MODE, DELAY, COLOR)
  }
}

return();

[***************************************
[ DECLARED MESSAGES
[***************************************
#message 1 "07077FFE3FFC3FFC3FFC3FFC3FFC01808001800101803FFC3FFC3FFC3FFC3FFC7FFE00008001800180018001800180017E7E7E7E8001800180018001800180010000"
#message 2 "%s12"
#message 14 "default"
#message 15 " walk  "
#message 16 " look  "
#message 17 " talk  "
#message 18 "  use  "
#message 19 " wait  "
