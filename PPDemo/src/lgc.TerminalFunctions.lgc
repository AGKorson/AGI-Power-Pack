[ 
[ lgc.TerminalFunctions
[ 

[1234567890123456789012345678901234567890
[ valid commands:
[AMOS       Provides access to AMOS sub- 
[           systems and configuration
[CLS        Clears the screen.
[CD/CHDIR   Changes the current
[           directory.
[CHKDSK     Checks a disk and displays a
[           status report
[DIR        Displays a list of files in 
[           a directory.
[COPY       Copies files to another
[           location.
[DEL/ERASE  Deletes files.
[EXIT       Quits and restarts AMOS 
[FORMAT     Formats a disk.
[HELP       Displays a list of AMOS 
[           commands.
[LOGOFF     Logs a user off AMOS.
[MD/MKDIR   Creates a directory.
[RD/RMDIR   Removes a directory.
[REN/RENAME Renames a file or files.
[SUDO       Runs AMOS commands with admin
[           privileges. 
[TYPE       Displays the contents of a
[           text file.
[VER        Displays AMOS version.
[VOL        Displays a disk volume label
[           and serial number.

#define cursor_row    v240
#define cursor_col    v241
#define cursor_char   v242
#define cursor_toggle v243
#define inputmode     v244
  #define IM_USERID    0 [ wait for userid
  #define IM_PASSWORD  1 [ wait for pw
  #define IM_CMDLINE   2 [ wait for commandline
  #define IM_ARGINPUT  3 [ wait for additional args/input
#define terminalfn    v245
  #define LINEFEED     1
  #define DELAY        2
  #define DELAY_LF     3
  #define ADDLINE      4
  #define ADDLINE_LF   5
  #define CLS          6
  #define DELAY_ADD    7
  #define NO_ACCESS    8
  #define SHOW_DIR     9
  #define CHKDSK_A    10
  #define CHKDSK_C    11
  #define FORMAT_A    12
#define outputvar     v246
#define tmpCounter1   v247
#define tmpCounter2   v248
#define PWfunction    v249
  #define PW_LOGON     0
  #define PW_BADASS    1
  #define PW_CAISOCC   2
  #define PW_ERIDOCC   3
  #define PW_ESADOCC   4
  #define PW_ICAPOCC   5
  #define PW_OFROCC    6
  #define PW_RANDOCC   7
#define vCurDir       v250
  #define C_ROOT    0 [ c:\
  #define C_USERS   1 [ c:\USERS\
  #define C_KW001   2 [ c:\USERS\KW001
  #define A_ROOT    3 [ a:

#define cursorstate   f241
#define loggedon      f242

#define input          s12
#define char           s13
#define output         s14
#define userid         s15
#define sCmd           s16
#define sTemp2         s17

#define charmsg         m3
#define outputmsg       m4

#define TOPROW         4
#define BTMROW        18
#define LEFTCOL        9
#define RIGHTCOL      48

[ linefeed
:addlinefeed
if (terminalfn == LINEFEED) {
  [ moves to next line, and clears input
  if (cursor_row < BTMROW) {
    ++cursor_row;
  } else {
    [ scroll up
    clear.text.rect(TOPROW, LEFTCOL, BTMROW, RIGHTCOL, -1);
  }
  cursor_col = LEFTCOL;
  return();
}

[ .75 sec delay with or without linefeed
:delay1
if ((terminalfn == DELAY || terminalfn == DELAY_LF)) {
  work2 = 250;
  cycle.time(o254, work2); [ delay(vDELAY);
  cycle.time(o254, work2); [ delay(vDELAY);
  cycle.time(o254, work2); [ delay(vDELAY);
  if (terminalfn == DELAY_LF) {
    terminalfn = LINEFEED;
    goto(addlinefeed);
  }
}

if ((terminalfn == ADDLINE || terminalfn == ADDLINE_LF || terminalfn == DELAY_ADD)) {
[ TODO: need to add check for multiple line output
[ if more than one line, or if it extends past 
[ edge, need to break up the displayline
[  OR - just make sure calls to DISPLAYLINE already
[ have that figured out...
  outputvar = &outputmsg;
  display.v(cursor_row, cursor_col, outputvar);
  if (terminalfn == ADDLINE_LF) {
    terminalfn = LINEFEED;
    goto(addlinefeed);
  } else {
    [ adjust cursor column
    block(STR.FORMAT, &output, &output, 0); [ str.format(sINPUT, sRESULT)
    block(STR.LEN, &output, &work1, 0); [ str.len(sINPUT, vRESULT)
    cursor_col += work1;
    if (terminalfn == DELAY_ADD) {
      terminalfn = DELAY;
      goto(delay1);
    }
  }
  return();
}

if (terminalfn == CLS) {
  clear.text.rect(TOPROW, LEFTCOL, BTMROW, RIGHTCOL, BLACK);
  cursor_col = LEFTCOL;
  cursor_row = TOPROW;
}

if (terminalfn == NO_ACCESS) {
  output = "requires access level 3 or higher:";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "  access denied";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
}

if (terminalfn == SHOW_DIR) {
  tmpCounter1 = &output;
  if (vCurDir == C_ROOT) {
    tmpCounter2 = 6;
    :nextfile1
      block(SET.STRING.V, &tmpCounter1, &tmpCounter2, 0); [ set.string.v(vSTR, vMSG)
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      ++tmpCounter2;
    if (tmpCounter2 < 21) {
      goto(nextfile1);
    }
  }
  if (vCurDir == C_USERS) {
    tmpCounter2 = 21;
    :nextfile2
      block(SET.STRING.V, &tmpCounter1, &tmpCounter2, 0); [ set.string.v(vSTR, vMSG)
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      ++tmpCounter2;
    if (tmpCounter2 < 33) {
      goto(nextfile2);
    }
  }
  if (vCurDir == C_KW001) {
    tmpCounter2 = 33;
    :nextfile3
      block(SET.STRING.V, &tmpCounter1, &tmpCounter2, 0); [ set.string.v(vSTR, vMSG)
      terminalfn = ADDLINE_LF;
      call(lgc.TerminalFunctions);
      ++tmpCounter2;
    if (tmpCounter2 < 35) {
      goto(nextfile3);
    }
  }
  if (vCurDir == A_ROOT) {
    [ depends on whether floppy is inserted, formatted, copied
  }
}

if (terminalfn == CHKDSK_A) {
  output = "File system: FAT16";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "Volume label: %m35";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "Checking sectors: 0"; [ 720 512 B sectors
  terminalfn = ADDLINE;
  call(lgc.TerminalFunctions);

  --cursor_col;
  work1 = 0;
  work2 = 0;
  work3 = &m35;
  :fmta_loop
    ++work1;
    if (work1 == 10) {
      work1 = 0;
      ++work2;
    }
    display.v(cursor_row, cursor_col, work3);
  if (work2 < 72) {
    goto(fmta_loop);
  }
  terminalfn = LINEFEED;
  call(lgc.TerminalFunctions);
  output = "    360 KB total disk space";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  if (floppyfiles == 0) {
    work1 = 0;
    sTemp2 = "  0";
  } else {
    if (floppyfiles == 1) {
      work1 = 1;
      sTemp2 = "  1";
    } else {
      if (floppyfiles == 2) {
        work1 = 2;
        sTemp2 = "300";
      } else {
        work1 = 2;
        sTemp2 = "301";
      }
    }
  }
  output = "    %s17 KB in %v46 files";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "      0 KB in bad sectors";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);    
}

if (terminalfn == CHKDSK_C) {
  output = "File system: FAT16";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "Volume label: AMOSDISK";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  sTemp2 = "0";
  output = "Checking sectors: 0"; [ 76,800 4 KB sectors
  terminalfn = ADDLINE;
  call(lgc.TerminalFunctions);
  
  --cursor_col;
  work1 = 0;
  work2 = 0;
  tmpCounter1 = 0;
  work3 = &m35;
  :fmtc_loop
    ++work1;
    work1 += 3;
    if (work1 > 9) {
      work1 -= 10;
      ++work2;
      if (work2 == 100) {
        work2 = 0;
        ++tmpCounter1;
      }
    }
    if (tmpCounter1 > 0) {
      work3 = &m36;
    }
    display.v(cursor_row, cursor_col, work3);
  if ((tmpCounter1 < 76 || work2 < 80)) { [tmC=76 wk2=80
    goto(fmtc_loop);
  }
  terminalfn = LINEFEED;
  call(lgc.TerminalFunctions);
  
  output = "307,200 KB total disk space";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "184,392 KB in 7,325 files";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = " 72,996 KB in bad sectors";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
}

if (terminalfn == FORMAT_A) {
[ TODO: finalize formatting output

  output = " The new file system is FAT.";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = " Formatting 0K";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
[ TODO: add counting loop here

  output = " Initializing the File Allocation";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = " Table (FAT)...";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
[ slight pause here

  output = " Volume label (11 characters, ENTER";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = " for none)? ";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
[ get label here (limit to 11 chars, valid name chars only)

  output = " Format complete.";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "      360.0 KB total disk space.";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "      360.0 KB are available.";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "  512 bytes in each allocation unit.";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "  720 allocation units available on";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
  output = "  disk.";
  terminalfn = ADDLINE_LF;
  call(lgc.TerminalFunctions);
}

return();


[ **************************************
[ DECLARED MESSAGES
[ **************************************
#message 1 "_"
#message 2 " "
#message 3 "%s13"
#message 4 "%s14"
#message 5 "*"

[ DIR C:
#message 6 "07/16/89 09:12AM     438  AMOS.BAT"
#message 7 "08/06/89 09:11AM  42,445  AMOS.EXE"
#message 8 "07/14/89 05:31PM  18,518  AMOS.SYS"
#message 9 "11/30/85 03:42PM   6,732  MEM.SYS"
#message 10 "03/20/88 04:23PM   3,243  MOUSE.CPL"
#message 11 "03/18/88 02:40PM   6,781  MOUSE.DRV"
#message 12 "04/16/88 01:37PM  <DIR>   BADASS"
#message 13 "04/16/88 01:42PM  <DIR>   CAISOCC"
#message 14 "04/19/88 07:19PM  <DIR>   ERIDOCC"
#message 15 "05/09/88 08:16AM  <DIR>   ESADOCC"
#message 16 "04/23/88 05:00PM  <DIR>   ICAPOCC"
#message 17 "04/23/88 03:22PM  <DIR>   OFROCC"
#message 18 "05/08/88 08:09PM  <DIR>   RANDOCC"
#message 19 "04/16/88 01:37PM  <DIR>   SYSTEM"
#message 20 "04/16/88 01:38PM  <DIR>   USERS"

[ DIR C:\USERS:
#message 21 "04/16/88 01:47PM  <DIR>   ADMIN"
#message 22 "04/16/88 01:47PM  <DIR>   AK083"
#message 23 "10/22/88 09:13AM  <DIR>   AL014"
#message 24 "10/22/88 09:14AM  <DIR>   DM073"
#message 25 "10/22/88 09:22AM  <DIR>   JS132"
#message 26 "04/16/88 01:49PM  <DIR>   JW005"
#message 27 "04/16/88 01:49PM  <DIR>   KD101"
#message 28 "10/22/88 09:13AM  <DIR>   KM066"
#message 29 "08/11/89 09:02AM  <DIR>   KW001"
#message 30 "10/22/88 09:13AM  <DIR>   MC048"
#message 31 "08/11/89 09:02AM  <DIR>   RW002"
#message 32 "10/22/88 09:15AM  <DIR>   SM037"

[ DIR C:\USERS\KW001
#message 33 "08/24/89 07:37AM     438  PWRPACK.TXT"
#message 34 "08/24/89 07:32AM 307,887  PWRPACK.ZIP"

[ disk sector counter
#message 35 "%v47%v46"
#message 36 "%v247,%v47|2%v46"