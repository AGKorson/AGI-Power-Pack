[ ********************************************************************
[
[ cp.ICAPOCC
[
[ Indexed Chromatic Association Properties Options Control Console
[ ICAPOCC
[
[ ********************************************************************

#define oCursorB       o1  [ need four objects for cursor otherwise
#define oCursorT       o2  [ text gets erased
#define oCursorL       o3
#define oCursorR       o4
#define optCursor      o5
#define oSliderRed     o6
#define oSliderGreen   o7
#define oSliderBlue    o8

[ loop values assigned to cursor objects
#define LP_OPT      0 [ option button states
#define LP_CF_OPT   1 [ cursor frame for mouse/keyb option buttons
#define LP_CF_CMD1  2 [    "     "    "  OK, Cancel, Restore, Set, Reset command buttons
#define LP_CF_CMD2  3 [    "     "    "  Preview Palette command button
#define LP_CF_IDX   4 [    "     "    "  Index up/down buttons
#define LP_SLIDER   5 [ slider button states

#define colorindex   v220
#define newindex     v221
#define tmpRow       v222
#define tmpCol       v223
#define tmpVal       v224
#define redpos       v225
#define greenpos     v226
#define bluepos      v227
#define sliding      v228
#define cursorpos    v229
#define    CP_MOUSE  1
#define    CP_KEYB   2
#define    CP_IDX_DN 3
#define    CP_IDX_UP 4
#define    CP_RED    5
#define    CP_GREEN  6
#define    CP_BLUE   7
#define    CP_OK     8
#define    CP_CANCEL 9
#define    CP_RESET 10
#define    CP_PREVP 11
#define    CP_SET   12
#define    CP_RESTORE 13
#define newpos       v230
#define cursorX      v231
#define cursorY      v232
#define btnAction    v233
#define    B_OK       1
#define    B_CANCEL   2
#define    B_RESET    3
#define    B_IDX_DN   4
#define    B_IDX_UP   5
#define    B_PREV_PAL 6
#define    B_SET_COL  7
#define    B_RESTORE  8
#define egoPrevX     v234
#define egoPrevY     v235
#define egoPrevDir   v236
#define slideoffset  v237
#define oldSpeed     v238

#define update       f220
#define cursormode   f221
#define refresh      f222 [ used to redraw text on screen when the screen is first displayed

#define defColHex     s12  [ default hex value of color being edited 
#define curColHex     s13  [ current hex value of color being edited
#define editPal       s14  [ holds the palette currently being edited
                           [ (uses s14, s15, s16)
#define copyPal       s17  [ temp copy of edit palette, used when changing color values
                           [ (uses s17, s18, s19)
#define strTemp       s20

#define displayPal    m20  [ formatted text that holds the special room palette used to
                           [ display the current color being edited
#define prevPal       m21  [ formatted text that points to the edit palette
#define defaultPal    m22  [ default AGI palette

[if this control panel is not enabled show error screen
if (!enableICAPOCC) {
  if (newRoom) {
    work1 = pic.cp.Error;
    load.pic(work1);
    draw.pic(work1);
    discard.pic(work1);
    show.pic();
    set.text.attribute(-1, 0);
    set.text.attribute(GREEN, BLACK);
    display(1, 1, "> subsystem error");
    set.text.attribute(0, -1);
    block(FADE.IN, 0, FADECOUNT, BLACK); [ fade.in(BYVAR, DELAY, COLOR);
    lastChar = 0;
  }
  [ any key, or any mouse-click to exit
  if ((have.key() || controller(cLeftClick) || controller(cRightClick))) {
    [ fade out 
    block(FADE.OUT, 0, FADECOUNT, BLACK);  [ fade.out(BYVAR, DELAY, COLOR);
    new.room.v(previousRoom); [ ##LE001##
  }
  return();
}

[ **************************************
[ FIRST CYCLE ONLY
[ **************************************
if(newRoom) {
  [ this is the first cycle through this room
  [ load, draw and discard the picture resource for the current room

  [ if first time, score it
  work1 = cpusage;
  block(BIT.AND, 0, &work1, 4); [ bit.and(BYVAL, VAR, MASK)
  if (work1 == 4) {
    work1 = 5;
    call(lgc.ScoreHandler);
    block(BIT.OR, 0, &cpusage, 4); [ bit.or(BYVAL, VAR, MASK)
  }
  
  load.pic(currentRoom);
  draw.pic(currentRoom);
  discard.pic(currentRoom);
  
  [ this view has all the art for cursors and buttons
  load.view(vw.cp.ICAPOCC);
  
  [ option button that determines input mode; mouse or keyboard
  animate.obj(optCursor);
  set.view(optCursor, vw.cp.ICAPOCC);
  set.loop(optCursor, LP_OPT);
  set.cel(optCursor, 0);
  stop.cycling(optCursor);
  position(optCursor, 8, 97);
  draw(optCursor);
  
  [ sliders to change RGB values
  animate.obj(oSliderRed);
  ignore.horizon(oSliderRed);
  set.view(oSliderRed, vw.cp.ICAPOCC);
  set.loop(oSliderRed, LP_SLIDER);
  set.cel(oSliderRed, 0);
  stop.cycling(oSliderRed);
  animate.obj(oSliderGreen);
  ignore.horizon(oSliderGreen);
  set.view(oSliderGreen, vw.cp.ICAPOCC);
  set.loop(oSliderGreen, LP_SLIDER);
  set.cel(oSliderGreen, 0);
  stop.cycling(oSliderGreen);
  animate.obj(oSliderBlue);
  ignore.horizon(oSliderBlue);
  set.view(oSliderBlue, vw.cp.ICAPOCC);
  set.loop(oSliderBlue, LP_SLIDER);
  set.cel(oSliderBlue, 0);
  stop.cycling(oSliderBlue);
  
  [ cursor is in four parts; used to highlight command buttons
  [ and option buttons
  animate.obj(oCursorB);
  ignore.objs(oCursorB);
  set.view(oCursorB, vw.cp.ICAPOCC);
  set.loop(oCursorB, LP_CF_OPT);
  set.cel(oCursorB, 0);
  stop.cycling(oCursorB);
  position(oCursorB, 30, 97);
  
  animate.obj(oCursorT);
  ignore.objs(oCursorT);
  set.view(oCursorT, vw.cp.ICAPOCC);
  set.loop(oCursorT, LP_CF_OPT);
  set.cel(oCursorT, 0);
  stop.cycling(oCursorT);
  position(oCursorT, 30, 86);
  
  animate.obj(oCursorL);
  ignore.objs(oCursorL);
  set.view(oCursorL, vw.cp.ICAPOCC);
  set.loop(oCursorL, LP_CF_OPT);
  set.cel(oCursorL, 1);
  stop.cycling(oCursorL);
  position(oCursorL, 30, 96);
  
  animate.obj(oCursorR);
  ignore.objs(oCursorR);
  set.view(oCursorR, vw.cp.ICAPOCC);
  set.loop(oCursorR, LP_CF_OPT);
  set.cel(oCursorR, 1);
  stop.cycling(oCursorR);
  position(oCursorR, 47, 97);
  
  cursorpos = 2;
  newpos = 2;
  
  [ no text input in this room
  prevent.input();
  lastChar = 0;
  [ arrow keys control cursor here
  egoDir = 0;
  
  [ mouse is enabled, not cursor
  enable.item(mouse);
  reset(cursormode);
  btnAction = 0;
  
  [ To display all sixteen colors on a control panel that doesn't change
  [ its background colors, a special palette is used. Only two colors,
  [ the default value of the color being edited, and the current value
  [ of the color being edited will change. Color indices 1 and 2 (blue
  [ and green) are used for this, which means they can't be used anywhere
  [ else in the background picture). 
  [ When a color is selected, the palette will be updated so that colors
  [ 1 and 2 will show the values for the selected color index.
  
  [ The full palette of the edited colors is stored in a temporary string.
  [ When the changes are saved, this full temporary palette is copied to
  [ the global game palette string.
  
  [ copy the current palette to a temporary string
  block(STR.COPY, &palette, &editPal, 0); [ str.copy(sINPUT, sRESULT);
  
  [ get hex value of color zero (first six characters of the temp palette)
  work1 = 6;
  block(STR.LEFT, &editPal, &defColHex, &work1); [ str.left(sINPUT, sRESULT, vLEN);
  [ copy it to curColHex
  block(STR.COPY, &defColHex, &curColHex, 0); [ str.copy(sINPUT, sRESULT);
  
  [ need to show the pic before text can be added
  show.pic();
  
  [ set to colorindex zero value as default starting point
  colorindex = 0;
  [ and set sliders to match
  set.text.attribute(-1, 0);
  set.text.attribute(BLACK, WHITE);
  [ extract the red value
  tmpRow = 20;
  tmpCol = 29;
  work1 = 2;
  block(STR.LEFT, &curColHex, &strTemp, &work1); [ str.left(sINPUT, sRESULT, vLEN);
  block(HEX2BYTE, &strTemp, &work1, 0); [ hex2byte(sINPUT, vRESULT);
  redpos = work1;
  tmpVal = &m1;
  display.v(tmpRow, tmpCol, tmpVal);
  [ position the slider
  work1 *= -2;
  work1 += 149;
  tmpCol = 115;
  position.v(oSliderRed, tmpCol, work1);
  [ extract the green value
  tmpCol = 33;
  work1 = 4;
  block(STR.RIGHT, &curColHex, &strTemp, &work1); [ strRight(sINPUT, sRESULT, vLEN);
  work1 = 2;
  block(STR.LEFT, &strTemp, &strTemp, &work1); [ str.left(sINPUT, sRESULT, vLEN);
  block(HEX2BYTE, &strTemp, &work1, 0); [ hex2byte(sINPUT, vRESULT);
  greenpos = work1;
  display.v(tmpRow, tmpCol, tmpVal);
  [ position the slider
  work1 *= -2;
  work1 += 149;
  tmpCol = 131;
  position.v(oSliderGreen, tmpCol, work1);
  [ extract the blue value
  tmpCol = 37;
  work1 = 2;
  block(STR.RIGHT, &curColHex, &strTemp, &work1); [ strRight(sINPUT, sRESULT, vLEN);
  block(HEX2BYTE, &strTemp, &work1, 0); [ hex2byte(sINPUT, vRESULT);
  bluepos = work1;
  display.v(tmpRow, tmpCol, tmpVal);
  [ position the slider
  work1 *= -2;
  work1 += 149;
  tmpCol = 147;
  position.v(oSliderBlue, tmpCol, work1);
  [ restore attributes
  draw(oSliderRed);
  draw(oSliderGreen);
  draw(oSliderBlue);
  [ update panel
  display(7, 20, "00");
  [ original color name
  set.text.attribute(BLACK, LT_GRAY);
  display(14, 16, "  BLACK   "); 
  set.text.attribute(0, -1);
  
  [ load this palette, but don't set it yet
  block(SET.PALETTE, 0, &displayPal, 1); [ set.palette(BYVAR, mPALETTE, LOADONLY);
  
  [ cache ego movement parameters (to be restored
  [ when returning to the control room)
  egoPrevX = egoX;
  egoPrevY = egoY;
  egoPrevDir = egoDir;
  
  [ set speed to fast for best mouse performance
  oldSpeed = animationInterval;
  animationInterval = FAST_SPEED;

}

[ if room is being drawn or redrawn, need to add text
if ((newRoom || refresh)) {
  [ push display colors
  set.text.attribute(-1, 0);
  
  [ add button text
  set.text.attribute(BLACK, WHITE);
  display(16, 1, "  OK");

  display(18, 1, " Cancel");
  display(20, 1, " Reset");
  
  display(16, 10, "Preview");
  display(17, 10, "Palette");
  
  display(16, 19, "  Set");
  display(18, 19, "Restore");
  
  display(7, 17, "\x11");
  display(7, 24, "\x10");

  set.text.attribute(BLACK, LT_GRAY);
  display(10, 2, "  Cursor");
  display(12, 4, "Ms");
  display(12, 10, "Kb");
  
  display(2, 29, "RD");
  display(2, 33, "GR");
  display(2, 37, "BL");
  
  [ pop display colors
  set.text.attribute(0, -1);
  
  [ if first time through
  if (newroom) {
    [ load the palette
    block(SET.PALETTE, 0, &displayPal, 1); [ set.palette(BYVAR, mPALETTE, LOADONLY);
    [ then fade it in
    block(FADE.IN, 0, FADECOUNT, BLACK); [ fade.in(BYVAR, DELAY, COLOR)
  } else {
    [ refreshing - reset the flag
    reset(refresh);
    [ force color update
    colorindex = -1;
  }
  return();
}

[ **************************************
[ EVERY CYCLE
[ **************************************

[ is cursor in text mode?
if (cursormode) {
  [ check for direction arrow keypress
  if (egoDir != STOPPED) {
    [ cursor up
    if (egoDir == UP) {
      if (cursorpos == CP_OK) {
        newpos = CP_MOUSE;
      }
      if (cursorpos == CP_PREVP) {
        newpos = CP_KEYB;
      }
      if (cursorpos == CP_SET) {
        newpos = CP_IDX_UP;
      }
        
      if ((cursorpos == CP_CANCEL || cursorpos == CP_RESET || cursorpos == CP_RESTORE)) {
        --newpos;
      } 
      if (cursorpos == CP_RED) {
        [ adjust red value up one
        if (redpos < 63) {
          ++redpos;
          set(update);
          work1 = redpos;
          tmpVal = 1;
          tmpRow = 20;
          tmpCol = 29;
          set.text.attribute(-1, 0);
          set.text.attribute(BLACK, WHITE);
          display.v(tmpRow, tmpCol, tmpVal);
          set.text.attribute(0, -1);
          work1 *= -2;
          work1 += 149;
          tmpCol = 115;
          reposition.to.v(oSliderRed, tmpCol, work1);
        }
      }
      if (cursorpos == CP_GREEN) {
        [ adjust green value up one
        if (greenpos < 63) {
          ++greenpos;
          set(update);
          work1 = greenpos;
          tmpVal = 1;
          tmpRow = 20;
          tmpCol = 33;
          set.text.attribute(-1, 0);
          set.text.attribute(BLACK, WHITE);
          display.v(tmpRow, tmpCol, tmpVal);
          set.text.attribute(0, -1);
          work1 *= -2;
          work1 += 149;
          tmpCol = 131;
          reposition.to.v(oSliderGreen, tmpCol, work1);
        }
      }
      if (cursorpos == CP_BLUE) {
        [ adjust blue value up one
        if (bluepos < 63) {
          ++bluepos;
          set(update);
          work1 = bluepos;
          tmpVal = 1;
          tmpRow = 20;
          tmpCol = 37;
          set.text.attribute(-1, 0);
          set.text.attribute(BLACK, WHITE);
          display.v(tmpRow, tmpCol, tmpVal);
          set.text.attribute(0, -1);
          work1 *= -2;
          work1 += 149;
          tmpCol = 147;
          reposition.to.v(oSliderBlue, tmpCol, work1);
        }
      }
    }
    
    [ cursor right
    if (egoDir == RIGHT) {
      if (cursorpos < CP_BLUE) {
        ++newpos;
      }
      if ((cursorpos == CP_OK || cursorpos == CP_CANCEL)) {
        newpos = CP_PREVP;
      }
      if (cursorpos == CP_PREVP) {
        newpos = CP_SET;
      }
      if (cursorpos > CP_PREVP) {
        newpos = CP_RED;
      }
    }
    
    [ cursor down
    if (egoDir == DOWN) {
      if (cursorpos == CP_MOUSE) {
        newpos = CP_OK;
      }
      if (cursorpos == CP_KEYB) {
        newpos = CP_PREVP;
      }
      if (cursorpos == CP_IDX_DN) {
        newpos = CP_PREVP;
      }
      if (cursorpos == CP_IDX_UP) {
        newpos = CP_SET;
      }
      if (cursorpos == CP_RED) {
        [ adjust red value down one
        if (redpos > 0) {
          --redpos;
          set(update);
          work1 = redpos;
          tmpVal = 1;
          tmpRow = 20;
          tmpCol = 29;
          set.text.attribute(-1, 0);
          set.text.attribute(BLACK, WHITE);
          display.v(tmpRow, tmpCol, tmpVal);
          set.text.attribute(0, -1);
          work1 *= -2;
          work1 += 149;
          tmpCol = 115;
          reposition.to.v(oSliderRed, tmpCol, work1);
        }
      }
      if (cursorpos == CP_GREEN) {
        [ adjust green value down one
        if (greenpos > 0) {
          --greenpos;
          set(update);
          work1 = greenpos;
          tmpVal = 1;
          tmpRow = 20;
          tmpCol = 33;
          set.text.attribute(-1, 0);
          set.text.attribute(BLACK, WHITE);
          display.v(tmpRow, tmpCol, tmpVal);
          set.text.attribute(0, -1);
          work1 *= -2;
          work1 += 149;
          tmpCol = 131;
          reposition.to.v(oSliderGreen, tmpCol, work1);
        }
      }
      if (cursorpos == CP_BLUE) {
        [ adjust blue value down one
        if (bluepos > 0) {
          --bluepos;
          set(update);
          work1 = bluepos;
          tmpVal = 1;
          tmpRow = 20;
          tmpCol = 37;
          set.text.attribute(-1, 0);
          set.text.attribute(BLACK, WHITE);
          display.v(tmpRow, tmpCol, tmpVal);
          set.text.attribute(0, -1);
          work1 *= -2;
          work1 += 149;
          tmpCol = 147;
          reposition.to.v(oSliderBlue, tmpCol, work1);
        }
      }
      if ((cursorpos == CP_OK || cursorpos == CP_CANCEL || cursorpos == CP_SET)) {
        newpos += 1;
      }
    }
    
    [ cursor left
    if (egoDir == LEFT) {
      if (cursorpos > CP_MOUSE && cursorpos < CP_OK) {
        newpos -= 1;
      }
      if (cursorpos == CP_PREVP) {
        newpos = CP_OK;
      }
      if ((cursorpos == CP_SET || cursorpos == CP_RESTORE)) {
        newpos = CP_PREVP;
      }
    }
    
    [ always reset dir so another keypress can be detected
    egoDir = 0;
    
    [ check for new cursor position
    if (cursorpos != newpos) {
      [ update the position
      cursorpos = newpos;
      [ depending on where cursor is, set the position and size/shape

      [ option buttons
      if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {
        set.loop(oCursorB, LP_CF_OPT);
        set.loop(oCursorT, LP_CF_OPT);
        set.loop(oCursorL, LP_CF_OPT);
        set.loop(oCursorR, LP_CF_OPT);
        
        cursorY = 97;
        if (cursorpos == CP_MOUSE) {
          cursorX = 7;
        } else {
          cursorX = 31;
        }
      }
      
      [ index up/down buttons
      if ((cursorpos == CP_IDX_DN || cursorpos == CP_IDX_UP)) {
        set.loop(oCursorB, LP_CF_IDX);
        set.loop(oCursorT, LP_CF_IDX);
        set.loop(oCursorL, LP_CF_IDX);
        set.loop(oCursorR, LP_CF_IDX);
        
        cursorY = 56;
        if (cursorpos == CP_IDX_DN) {
          cursorX = 67;
        }
        if (cursorpos == CP_IDX_UP) {
          cursorX = 95;
        }
      }
      
      [ OK, Cancel, and Restore buttons
      if (cursorpos > CP_BLUE && cursorpos < CP_PREVP) {
        set.loop(oCursorB, LP_CF_CMD1);
        set.loop(oCursorT, LP_CF_CMD1);
        set.loop(oCursorL, LP_CF_CMD1);
        set.loop(oCursorR, LP_CF_CMD1);
        
        cursorX = 3;
        [ convert cursorpos into desired y value
        cursorY = cursorpos;
        cursorY -= 8;
        cursorY *= 16;
        cursorY += 128;
      }
      
      [ preview palette button
      if (cursorpos == CP_PREVP) {
        set.loop(oCursorB, LP_CF_CMD2);
        set.loop(oCursorT, LP_CF_CMD2);
        set.loop(oCursorL, LP_CF_CMD2);
        set.loop(oCursorR, LP_CF_CMD2);
        
        cursorX = 39;
        cursorY = 136;
      }
      
      [ color set/reset buttons
      if ((cursorpos == CP_SET || cursorpos == CP_RESTORE)) {
        set.loop(oCursorB, LP_CF_CMD1);
        set.loop(oCursorT, LP_CF_CMD1);
        set.loop(oCursorL, LP_CF_CMD1);
        set.loop(oCursorR, LP_CF_CMD1);
        
        cursorX = 75;
        [ convert cursorpos into desired y value
        cursorY = cursorpos;
        cursorY -= 12;
        cursorY *= 16;
        cursorY += 128;
      }
      
      [ color sliders
      set.cel(oSliderRed, 0);
      set.cel(oSliderBlue, 0);
      set.cel(oSliderGreen, 0);
      if (cursorpos == CP_RED) {
        set.cel(oSliderRed, 1);
      }
      if (cursorpos == CP_GREEN) {
        set.cel(oSliderGreen, 1);
      }
      if (cursorpos == CP_BLUE) {
        set.cel(oSliderBlue, 1);
      }
      
      [ to move cursor, erase it first, otherwise, it will
      [ clear any text that is present anywhere between the
      [ new position and the old position
      erase(oCursorB);
      erase(oCursorL);
      erase(oCursorT);
      erase(oCursorR);
      
      [ if NOT a slider, reposition the four-part cursor and 
      [ show it
      if ((cursorpos < CP_RED || cursorpos > CP_BLUE)) {
        position.v(oCursorB, cursorX, cursorY);
        draw(oCursorB);
        --cursorY;
        [ save ypos to restore it later
        work1 = cursorY;
        position.v(oCursorL, cursorX, cursorY);
        draw(oCursorL);
        [ adjust for height (depends on button type)
        if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {
          cursorY -= 10;
        }
        if ((cursorpos == CP_IDX_DN || cursorpos == CP_IDX_UP ||
             cursorpos == CP_OK || cursorpos == CP_CANCEL ||
             cursorpos == CP_RESET || cursorpos == CP_SET || 
             cursorpos == CP_RESTORE)) {
            cursorY -= 8;
        }
        if (cursorpos == CP_PREVP) {
          cursorY -= 16;
        }
        position.v(oCursorT, cursorX, cursorY);
        draw(oCursorT);
        [ reset y
        cursorY = work1;
        [ adjust for width
        if (cursorpos < CP_IDX_DN) {
          cursorX += 17;
        } else {
          if ((cursorpos == CP_IDX_DN || cursorpos == CP_IDX_UP)) {
            cursorX += 5;
          } else {
            cursorX += 29;
          }
        }
        position.v(oCursorR, cursorX, cursorY);
        draw(oCursorR);
      }
    }
  }
  
  [ check for selection (space/enter for button)
  if (have.key()) {
    [ space/enter
    if ((lastChar == 32 || lastChar == 13 || lastChar == 10)) {
      if (cursorpos  == CP_MOUSE) {
        [ switch to mouse control
        reset(cursormode);
        enable.item(mouse);
        erase(optCursor);
        position(optCursor, 8, 97);
        draw(optCursor);
        [ erase the cursor objects
        erase(oCursorB);
        erase(oCursorT);
        erase(oCursorL);
        erase(oCursorR);
      }
      if (cursorpos  == CP_OK) {
        btnAction = B_OK;
      }
      if (cursorpos  == CP_CANCEL) {
        btnAction = B_CANCEL;
      }
      if (cursorpos  == CP_RESET) {
        btnAction = B_RESET;
      }
      if (cursorpos == CP_IDX_DN) {
        btnAction = B_IDX_DN;
      }
      if (cursorpos == CP_IDX_UP) {
        btnAction = B_IDX_UP;
      }
      if (cursorpos == CP_SET) {
        btnAction = B_SET_COL;
      }
      if (cursorpos == CP_RESTORE) {
        btnAction = B_RESTORE;
      }
      if (cursorpos == CP_PREVP) {
        btnAction = B_PREV_PAL;
      }
    }
  }
} else {
  [ mouse is active: check for mouse actions
  
  [ check for mouse clicks
  if (controller(cLeftClick)) {
    [ over cursor type keyboard option 
    if (mouseX > 30 && mouseX < 38 && mouseY > 87 && mouseY < 96) {
      [ switch to keyboard cursor
      set(cursormode);
      disable.item(mouse);
      erase(optCursor);
      position(optCursor, 32, 97);
      draw(optCursor);
      [ show the cursor object
      cursorpos = 2;
      newpos = 2;
      position(oCursorB, 31, 97);
      draw(oCursorB);
      position(oCursorT, 31, 86);
      draw(oCursorT);
      position(oCursorL, 31, 96);
      draw(oCursorL);
      position(oCursorR, 48, 96);
      draw(oCursorR);
    }

    [ over OK button [2, 118 - 33, 129]
    if (mouseX > 2 && mouseX < 33 && mouseY > 118 && mouseY < 129) {
      btnAction = B_OK;
    }
      
    [ over Cancel button [2, 134 - 33, 145]
    if (mouseX > 2 && mouseX < 33 && mouseY > 134 && mouseY < 145) {
      btnAction = B_CANCEL;
    }
    
    [ over Reset button [2, 150 - 33, 161]
    if (mouseX > 2 && mouseX < 33 && mouseY > 150 && mouseY < 161) {
      btnAction = B_RESET;
    }
    
    [ over IndexDn button [66, 46 - 73, 57]
    if (mouseX > 66 && mouseX < 73 && mouseY > 46 && mouseY < 57) {
      btnAction = B_IDX_DN;
    }
    
    [ over IndexUp button [94, 46 - 101, 57]
    if (mouseX > 94 && mouseX < 101 && mouseY > 46 && mouseY < 57) {
      btnAction = B_IDX_UP;
    }
    
    [ over SetColor button [74, 118 - 105, 129]
    if (mouseX > 74 && mouseX < 105 && mouseY > 118 && mouseY < 129) {
      btnAction = B_SET_COL;
    }
    
    [ over RestoreColor button [74, 134 - 105, 145]
    if (mouseX > 74 && mouseX < 105 && mouseY > 134 && mouseY < 145) {
      btnAction = B_RESTORE;
    }
    [ over PreviewPalette button [38, 118 - 69, 137]
    if (mouseX > 38 && mouseX < 69 && mouseY > 118 && mouseY < 137) {
      btnAction = B_PREV_PAL;
    }
    
    [ over red slider zone
    if (mouseX >= 115 && mouseX <= 124) {
      get.posn(oSliderRed, tmpCol, tmpRow);
      [ adjust for button height
      tmpCol = tmpRow;
      tmpCol -= 7;
      [ is mouse is on the button?
      if (mouseY >= tmpCol && mouseY <= tmpRow) {
        [ start slide action for red
        sliding = 1;
        [ calculate offset from actual object position
        [ to mouse position (ofst = posy - mY)
        slideoffset = tmpRow;
        slideoffset -= mouseY;
      }
    }
    
    [ over green slider zone
    if (mouseX >= 131 && mouseX <= 140) {
      get.posn(oSliderGreen, tmpCol, tmpRow);
      [ adjust for button height
      tmpCol = tmpRow;
      tmpCol -= 7;
      [ is mouse is on the button?
      if (mouseY >= tmpCol && mouseY <= tmpRow) {
        [ start slide action for green
        sliding = 2;
        [ calculate offset from actual object position
        [ to mouse position (ofst = posy - mY)
        slideoffset = tmpRow;
        slideoffset -= mouseY;
      }
    }
    
    [ over blue slider zone
    if (mouseX >= 147 && mouseX <= 156) {
      get.posn(oSliderBlue, tmpCol, tmpRow);
      [ adjust for button height
      tmpCol = tmpRow;
      tmpCol -= 7;
      [ is mouse is on the button?
      if (mouseY >= tmpCol && mouseY <= tmpRow) {
        [ start slide action for blue
        sliding = 3;
        [ calculate offset from actual object position
        [ to mouse position (ofst = posy - mY)
        slideoffset = tmpRow;
        slideoffset -= mouseY;
      }
    }
  }

  [ check for mouse up, to clear slider movement
  if (mouseBtn != 1) {
    [ cancel slide operation
    sliding = 0;
  }
  
  if (sliding > 0) {
    [ convert mousepos to a slider position
    [ (slideY = mouseY + offset)
    work1 = mouseY;
    work1 += slideoffset;
    [ limit to valid range (149 - 23)
    if (work1 > 149) {
      work1 = 149;
    }
    if (work1 < 23) {
      work1 = 23;
    }
    [ limit to odd values since the slider has
    [ a scale factor of two
    work1 /= 2;
    work1 *= 2;
    ++work1;
    
    [ red slider
    if (sliding == 1) {
      [ reposition the slider
      tmpCol = 115; [ x value
      reposition.to.v(oSliderRed, tmpCol, work1);
      [ now convert position to a color value
      [ (redpos = (149 - slideY)/ 2)
      work1 *= -1;
      work1 += 149;
      work1 /= 2;
      [ if it changed, update the color
      if (work1 != redpos) {
        redpos = work1;
        set(update);
      }
    }
    
    [ green slider
    if (sliding == 2) {
      [ reposition the slider
      tmpCol = 131; [ x value
      reposition.to.v(oSliderGreen, tmpCol, work1);
      [ now convert position to a color value
      [ (greenpos = (149 - slideY)/ 2)
      work1 *= -1;
      work1 += 149;
      work1 /= 2;
      [ if it changed, update the color
      if (work1 != greenpos) {
        greenpos = work1;
        set(update);
      }
    }

    [ blue slider
    if (sliding == 3) {
      [ reposition the slider
      tmpCol = 147; [ x value
      reposition.to.v(oSliderBlue, tmpCol, work1);
      [ now convert position to a color value
      [ (bluepos = (149 - slideY)/ 2)
      work1 *= -1;
      work1 += 149;
      work1 /= 2;
      [ if it changed, update the color
      if (work1 != bluepos) {
        bluepos = work1;
        set(update);
      }
    }
  }
}

[ check for button actions

if ((btnAction == B_OK || btnAction == B_CANCEL)) {
  
  if (btnAction == B_OK) {
    [ save the palette
    block(STR.COPY, &editPal, &palette, 0); [ str.copy(sINPUT, sRESULT);
  }

  [ restore ego movement parameters
  egoX = egoPrevX;
  egoY = egoPrevY;
  egoDir = egoPrevDir;
  [ fade out
  block(FADE.OUT, 0, FADECOUNT, BLACK); [ fade.out(BYVAR, DELAY, COLOR);
  [ change to temporary palette, load but don't display it
  block(SET.PALETTE, 0, &prevPal, 1); [ set.palette(BYVAR, PALETTE, LOADONLY);

  [ restore speed
  animationInterval = oldSpeed;
  
  [ go back to previous room
  new.room.v(previousRoom); 
}

if (btnAction == B_RESET) {
  [ change to default palette
  editPal = defaultPal;
  [ force refresh
  colorindex = -1;
}

if (btnAction == B_IDX_DN) {
  [ move down one index level
  --newindex;

}

if (btnAction == B_IDX_UP) {
  [ move up one index level
  if (newindex < 15) {
    ++newindex;
  }
}

if (btnAction == B_SET_COL) {
  [ set a new value for this color
  
  [ make a copy of editPal
  block(STR.COPY, &editPal, &copyPal, 0); [ str.copy(sINPUT, sRESULT);
  work1 = colorindex;
  work1 *= 6;
  [ trim palette at insertion point
  block(STR.LEFT, &editPal, &editPal, &work1); [ strRight(sINPUT, sRESULT, vLEN);
  [ get palette data following insertion point
  work1 *= -1;
  work1 += 90;
  block(STR.RIGHT, &copyPal, &copyPal, &work1); [ strRight(sINPUT, sRESULT, vLEN);
  [ add new color
  block(STR.CONCAT, &editPal, &curColHex, 0); [ sINPUT, sADD);
  [ add rest of palette
  block(STR.CONCAT, &editPal, &copyPal, 0); [ sINPUT, sADD);
  [ copy current color string to default string
  block(STR.COPY, &curColHex, &defColHex, 0); [ str.copy(sINPUT, sRESULT);
  [ refresh the display palette
  block(SET.PALETTE, 0, &displayPal, 0); [ set.palette(BYVAR, PALETTE, LOADONLY);  
}

if (btnAction == B_RESTORE) {
  [ TODO: restore default value for this color
  [ (this returns to whatever it was edited to; NOT the default
  [ AGI color; maybe rename this 'cancel edit'?
  [ by forcing an index value refresh
  colorindex = -1;
}

if (btnAction == B_PREV_PAL) {
  [ let user choose a room number; preview that picture
  get.num("Room # to preview (1 - 10):", work1);
  if (work1 > 0 && work1 < 11) {
    [ fade to black, 2msec fade value
    block(FADE.OUT, 0, 2, BLACK);
    [ change to temporary palette, load but don't display it
    block(SET.PALETTE, 0, &prevPal, 1);
  
    [ load the test picture
    set(noScript);
    load.pic(work1);
    draw.pic(work1);
    discard.pic(work1);
    show.pic();
  
    [ fade in from black, 2msec fade value
    block(FADE.IN, 0, 2, BLACK);
  
    [ wait for a keypress
    lastChar = 0;
    :loop4
    if (!have.key()) {
      goto(loop4);
    }
  
    [ fade to black, 2msec fade value
    block(FADE.OUT, 0, 2, BLACK);
    [ restore room palette (but don't update it yet)
    block(SET.PALETTE, 0, &displayPal, 1);
    
    [ restore room picture
    load.pic(currentRoom);
    draw.pic(currentRoom);
    discard.pic(currentRoom);
    show.pic();
    [ redraw button text by recursing
    set(refresh);
    call(cp.ICAPOCC);
    
    [ fade in from black, 2msec fade value
    block(FADE.IN, 0, 2, BLACK);
    
    [ force index update
    colorindex = -1;
    
    reset(noScript);
  }
}

[ always reset button action
btnAction = 0;
  
[ check for index change
if (newindex != colorindex) {
  [ push display colors
  set.text.attribute(-1, 0);
  
  [ update panel
  set.text.attribute(BLACK, WHITE);
  tmpRow = 7;
  tmpCol = 20;
  tmpVal = 1;
  work1 = newindex;
  display.v(tmpRow, tmpCol, tmpVal);
  [ original color name
  set.text.attribute(BLACK, LT_GRAY);  
  tmpRow = 14;
  tmpCol = 16;
  work1 += 2;
  display.v(tmpRow, tmpCol, work1);
  
  [ get the component colors for this color from editPal
  [ and set the slider position and label values
  set.text.attribute(BLACK, WHITE);
  
  [ extract the color hex string
  colorindex = newindex;
  colorindex *= 6;
  block(STR.COPY, &editPal, &copyPal, 0); [ str.copy(sINPUT, sRESULT);
  work1 = 6;
  block(STR.MID, &copyPal, &colorindex, &work1); [ str.mid(sINPUT, vPOS, vLEN);
  [ copy it to current color string
  block(STR.COPY, &copyPal, &curColHex, 0); [ str.copy(sINPUT, sRESULT);
  
  [ extract the red value
  tmpRow = 20;
  tmpCol = 29;
  work1 = 2;
  block(STR.LEFT, &curColHex, &defColHex, &work1); [ str.left(sINPUT, sRESULT, vLEN);
  block(HEX2BYTE, &defColHex, &work1, 0); [ hex2byte(sINPUT, vRESULT);
  
  redpos = work1;
  tmpVal = 1;
  display.v(tmpRow, tmpCol, tmpVal);
  [ position the slider
  work1 *= -2;
  work1 += 149;
  tmpCol = 115;
  reposition.to.v(oSliderRed, tmpCol, work1);
  
  [ extract the green value
  tmpCol = 33;
  work1 = 4;
  block(STR.RIGHT, &curColHex, &defColHex, &work1); [ strRight(sINPUT, sRESULT, vLEN);
  work1 = 2;
  block(STR.LEFT, &defColHex, &defColHex, &work1); [ str.left(sINPUT, sRESULT, vLEN);
  block(HEX2BYTE, &defColHex, &work1, 0); [ hex2byte(sINPUT, vRESULT);
  greenpos = work1;
  display.v(tmpRow, tmpCol, tmpVal);
  [ position the slider
  work1 *= -2;
  work1 += 149;
  tmpCol = 131;
  reposition.to.v(oSliderGreen, tmpCol, work1);
  
  [ blue
  tmpCol = 37;
  work1 = 2;
  block(STR.RIGHT, &curColHex, &defColHex, &work1); [ strRight(sINPUT, sRESULT, vLEN);
  block(HEX2BYTE, &defColHex, &work1, 0); [ hex2byte(sINPUT, vRESULT);
  bluepos = work1;
  display.v(tmpRow, tmpCol, tmpVal);
  [ position the slider
  work1 *= -2;
  work1 += 149;
  tmpCol = 147;
  reposition.to.v(oSliderBlue, tmpCol, work1);
  
  [ restore attributes
  set.text.attribute(0, -1);
  
  [ copy color hex text to default string
  block(STR.COPY, &curColHex, &defColHex, 0); [ str.copy(sINPUT, sRESULT);
  [ switch the palette immediately
  block(SET.PALETTE, 0, &displayPal, 0); [ set.palette(BYVAR, mPALETTE, LOADONLY);
  [ update index value
  colorindex = newindex;
}

[ if color variables have changed, update the palette and text displays
if (update) {
  [ recalculate the new color value and adjust palette
  block(BYTE2HEX, &curColHex, &redpos, 0); [ byte2hex(sRESULT, vINPUT);
  block(BYTE2HEX, &copyPal, &greenpos, 0); [ byte2hex(sRESULT, vINPUT);
  block(STR.CONCAT, &curColHex, &copyPal, 0); [ sINPUT, sADD);
  block(BYTE2HEX, &copyPal, &bluepos, 0); [ byte2hex(sRESULT, vINPUT);
  block(STR.CONCAT, &curColHex, &copyPal, 0); [ sINPUT, sADD);

  [ update the palette
  block(SET.PALETTE, 0, 20, 0); [ set.palette(BYVAR, PALETTE, LOADONLY);
  reset(update);
  
  [ update color value text fields
  set.text.attribute(-1, 0);
  set.text.attribute(BLACK, WHITE);
  tmpRow = 20;
  tmpVal = 1;
  [ red
  tmpCol = 29;
  work1 = redpos;
  display.v(tmpRow, tmpCol, tmpVal);
  [ green
  tmpCol = 33;
  work1 = greenpos;
  display.v(tmpRow, tmpCol, tmpVal);
  [ blue
  tmpCol = 37;
  work1 = bluepos;
  display.v(tmpRow, tmpCol, tmpVal);
  set.text.attribute(0, -1);
}

:done
return();

[ **************************************
[ DECLARED MESSAGES
[ **************************************
#message 1 "%v46|2"
#message 2  "  BLACK   "
#message 3  "   BLUE   "
#message 4  "  GREEN   "
#message 5  "   CYAN   "
#message 6  "   RED    "
#message 7  " MAGENTA  "
#message 8  "  BROWN   "
#message 9  " LT GRAY  "
#message 10 " DK GRAY  "
#message 11 " LT BLUE  "
#message 12 " LT GREEN "
#message 13 " LT CYAN  "
#message 14 "  LT RED  "
#message 15 "LT MAGENTA"
#message 16 "  YELLOW  "
#message 17 "  WHITE   "
#message 18 "000000"
#message 19 "002A2A2A00002A002A2A15002A2A2A15151515153F153F15153F3F3F15153F153F3F3F153F3F3F"
#message 20 "%m18%s12%s13%m19"
#message 21 "%s14"
#message 22 "00000000002A002A00002A2A2A00002A002A2A15002A2A2A15151515153F153F15153F3F3F15153F153F3F3F153F3F3F"

  