[ ********************************************************************[[ cp.Sound[[ Electronic Synthesized Audio Data Options Control Console[ [ ESADOCC[ toggle between pc speaker and 4chan[ allow instrument selection for each channel[ test button - play a short song[[ 4channelsound flag gets changed during editing; it has to be[ restored on cancel; instrument values don't; temp values are used[[ ********************************************************************#define oCursorB       o1  [ need four objects for cursor otherwise#define oCursorT       o2  [ text gets erased#define oCursorL       o3#define oCursorR       o4#define oMode          o5#define oChannels      o6#define oCheck         o7#define oTest          o8#define oScrlBox       o9#define oScrlBkgd     o10#define oVolSlider     o11#define currentInst   v220#define cursorpos     v221#define    CP_MOUSE   1#define    CP_KEYB    2#define    CP_1CHAN   3#define    CP_4CHAN   4#define    CP_OK      5#define    CP_CANCEL  6#define    CP_TESTALL 7#define    CP_TEST0   8#define    CP_TEST1   9#define    CP_TEST2  10#define    CP_TEST3  11#define    CP_TEST4  12#define    CP_INST0  13#define    CP_INST1  14#define    CP_INST2  15#define    CP_INST3  16#define    CP_INST4  17#define    CP_VOLUME 18#define newpos       v222#define cursorX      v223 [used byref!!!#define cursorY      v224#define btnAction    v225#define    B_1CHAN    1#define    B_4CHAN    2#define    B_OK       3#define    B_CANCEL   4#define    B_TESTALL  5#define    B_TEST0    6#define    B_TEST1    7#define    B_TEST2    8#define    B_TEST3    9#define    B_TEST4   10#define    B_INST0   11#define    B_INST1   12#define    B_INST2   13#define    B_INST3   14#define    B_INST4   15#define    B_VOLUME  16#define    B_UNSEL   17#define    SC_UP     18#define    SC_DOWN   19#define    SC_PGUP   20#define    SC_PGDN   21#define egoPrevX     v226#define egoPrevY     v227#define egoPrevDir   v228#define tmpInst0     v229#define tmpInst1     v230#define tmpInst2     v231#define tmpInst3     v232#define tmpInst4     v233#define dropmode     v234#define    NODROP     0#define    DROPDOWN   1#define    CHOOSING   2#define    DROPUP     3#define listindex    v235#define selinst      v236 [ instrument index of selected instrument#define selrow       v237 [ text row of selected instrument#define offsetinst   v238 [ instrument index of top row of listbox#define offsetrow    v239 [ top row of listbox[ a few more variable are needed than normally assigned to rooms[ the dynamic variables (240-255) can be safely used here#define tmpAttn      v240#define slideoffset  v241#define update       f220#define old4chan     f221#define cursormode   f222#define sndTest      f223#define sndDone      f224#define redrawList   f225#define sliding      f226[ **************************************[ FIRST CYCLE ONLY[ **************************************if(newRoom) {  [ this is the first cycle through this room  [ load, draw and discard the picture resource for the current room  load.pic(currentRoom);  draw.pic(currentRoom);  discard.pic(currentRoom);  [ do basic room initialization  call(lgc.RoomInit);  [ disable game functions  set(disableGameFunctions);    [ this view has all the art for cursors and buttons  load.view(vw.cp.Sound);    set.horizon(0);    [ load the test sounds  load.sound(m.Theme);  load.sound(s.InstTest);  load.sound(s.NoiseTest1);  load.sound(s.NoiseTest2);     [ option button that determines input mode; mouse or keyboard  animate.obj(oMode);  set.view(oMode, vw.cp.Sound);  set.loop(oMode, 0);  set.cel(oMode, 0);  stop.cycling(oMode);  position(oMode, 8, 65);  draw(oMode);    [ option button for channel count  animate.obj(oChannels);  set.view(oChannels, vw.cp.Sound);  set.loop(oChannels, 0);  set.cel(oChannels, 0);  stop.cycling(oChannels);  if (4channelsound) {    position(oChannels, 8, 105);  } else {    position(oChannels, 8, 89);  }  draw(oChannels);    [ cursor, in four parts, default to keyboard option position  animate.obj(oCursorB);  ignore.objs(oCursorB);  set.view(oCursorB, vw.cp.Sound);  set.loop(oCursorB, 1);  set.cel(oCursorB, 0);  stop.cycling(oCursorB);    animate.obj(oCursorL);  ignore.objs(oCursorL);  set.view(oCursorL, vw.cp.Sound);  set.loop(oCursorL, 1);  set.cel(oCursorL, 6);  stop.cycling(oCursorL);    animate.obj(oCursorT);  ignore.objs(oCursorT);  set.view(oCursorT, vw.cp.Sound);  set.loop(oCursorT, 1);  set.cel(oCursorT, 0);  stop.cycling(oCursorT);    animate.obj(oCursorR);  ignore.objs(oCursorR);  set.view(oCursorR, vw.cp.Sound);  set.loop(oCursorR, 1);  set.cel(oCursorR, 6);  stop.cycling(oCursorR);    [ cursor starts on keyboard option button  cursorpos = CP_KEYB;  newpos = CP_KEYB;  [ don't draw it yet though    [ scrollbar background  animate.obj(oScrlBkgd);  ignore.objs(oScrlBkgd);  set.view(oScrlBkgd, vw.cp.Sound);  set.loop(oScrlBkgd, 2);  set.cel(oScrlBkgd, 2);  stop.cycling(oScrlBkgd);  set.priority(oScrlBkgd, 14);    [ scrollbar box  animate.obj(oScrlBox);  ignore.objs(oScrlBox);  set.view(oScrlBox, vw.cp.Sound);  set.loop(oScrlBox, 2);  set.cel(oScrlBox, 0);  stop.cycling(oScrlBox);  set.priority(oScrlBox, 15);    [ volume slider button  animate.obj(oVolSlider);  ignore.objs(oVolSlider);  set.view(oVolSlider, vw.cp.Sound);  set.loop(oVolSlider, 3);  set.cel(oVolSlider, 0);  stop.cycling(oVolSlider);  set.priority(oVolSlider, 15);  [ position depends on current sound attenuation  tmpAttn = attenuation;  work1 = attenuation;  work1 *= -1;  work1 += 144;  work2 = 166;  position.v(oVolSlider, work1, work2);  [ (not used if 1chan)  if (4channelsound) {    draw(oVolSlider);  }    [ make copy of current mode  if (4channelsound) {    set(old4chan);  } else {    reset(old4chan);  }    [ instrument values  tmpInst0 = instrument0;  tmpInst1 = instrument1;  tmpInst2 = instrument2;  tmpInst3 = instrument3;  tmpInst4 = instrument4;  [ need to adjust by one to allow access to msgs  ++tmpInst0;  ++tmpInst1;  ++tmpInst2;  ++tmpInst3;  ++tmpInst4;    [ no instrument listbox is currently being edited  currentInst = -1;    [ copy the custom instrument values from lgc.Main  s12 = "%g53";  block(STR.FORMAT, 12, 12, 0); [ str.format(sINPUT, sRESULT)  block(SET.MSG, 0, 144, 12); [ set.msg(BYVAR, MSGOLD, STRNEW)  s12 = "%g54";  block(STR.FORMAT, 12, 12, 0); [ str.format(sINPUT, sRESULT)  block(SET.MSG, 0, 145, 12); [ set.msg(BYVAR, MSGOLD, STRNEW)  s12 = "%g55";  block(STR.FORMAT, 12, 12, 0); [ str.format(sINPUT, sRESULT)  block(SET.MSG, 0, 146, 12); [ set.msg(BYVAR, MSGOLD, STRNEW)  s12 = "%g56";  block(STR.FORMAT, 12, 12, 0); [ str.format(sINPUT, sRESULT)  block(SET.MSG, 0, 147, 12); [ set.msg(BYVAR, MSGOLD, STRNEW)  s12 = "%g57";  block(STR.FORMAT, 12, 12, 0); [ str.format(sINPUT, sRESULT)  block(SET.MSG, 0, 148, 12); [ set.msg(BYVAR, MSGOLD, STRNEW)    [ no text input in this room  prevent.input();  lastChar = 0;  [ arrow keys control cursor here  egoDir = 0;    [ mouse is enabled, not cursor; no button active  enable.item(mouse);  reset(cursormode);  btnAction = 0;  [ cache ego movement parameters (to be restored  [ when returning to the control room)  egoPrevX = egoX;  egoPrevY = egoY;  egoPrevDir = egoDir;    [ display the picture on screen  show.pic();  [ add a line below picture to 'extend' it  clear.lines(22, 22, LT_GRAY);    [ add label text  set.text.attribute(-1, 0);  set.text.attribute(BLACK, LT_GRAY);  display(6, 5, "Mode");  display(8, 4, "Ms");  display(8, 10, "Kb");  display(11, 4, "1chan PC");  display(13, 4, "4chan SB");  set.text.attribute(DK_GRAY, LT_GRAY);  display(22, 19, "min");  display(22, 35, "max");    [ button text  set.text.attribute(BLACK, WHITE);  display(17, 3, "OK");  display(19, 1, "Cancel");  display(18, 9, "Test");    [ force update of channel buttons and text boxes  set(update);  }[ **************************************[ EVERY CYCLE[ **************************************if (update) {  [ set text color based on mode  if (4channelsound) {   work1 = BLACK;  } else {    work1 = LT_GRAY;  }  cursorX = WHITE;  [ colors byvar  toggle.monitor();  set.text.attribute(&work1, &cursorX);  display(6, 16, "\x0E");  display(9, 16, "\x0E");  display(12, 16, "\x0E");  display(15, 16, "\x0E");  display(18, 16, "\x0E");  [ current instruments  cursorY = 19;  cursorX = 6;  display.v(cursorX, cursorY, tmpInst0);  cursorX += 3;  display.v(cursorX, cursorY, tmpInst1);  cursorX += 3;  display.v(cursorX, cursorY, tmpInst2);  cursorX += 3;  display.v(cursorX, cursorY, tmpInst3);  cursorX += 3;  display.v(cursorX, cursorY, tmpInst4);      [ volume slider  if (4channelsound) {    set.text.attribute(BLACK, LT_GRAY);    draw(oVolSlider);  } else {    set.text.attribute(DK_GRAY, LT_GRAY);    erase(oVolSlider);  }  display(22, 26, "Volume");    set.text.attribute(0, -1);    reset(update);    [ cancel drop mode  if (dropmode == DROPUP) {    dropmode = NODROP;  }}[ display dropdown listif (dropmode == DROPDOWN) {  [ clear area for dropdown (can't do byvar)  if (currentInst == 0) {    clear.text.rect(4, 19, 8, 38, WHITE);  }  if (currentInst == 1) {    clear.text.rect(7, 19, 11, 38, WHITE);  }  if (currentInst == 2) {    clear.text.rect(10, 19, 14, 38, WHITE);  }  if (currentInst == 3) {    clear.text.rect(13, 19, 17, 38, WHITE);  }  if (currentInst == 4) {    clear.text.rect(16, 19, 20, 38, WHITE);  }  [ determine row offset (row value of listbox top)  work1 = currentInst;  work1 *= 3;  work1 += 4;  offsetrow = work1;  [ column is always 19  work2 = 19;  [ instrument index offset (index of top item in list)  work3 = currentInst;  work3 += &tmpInst0;  work3 = *work3;  [ save this as the current selected instrument  selinst = work3;  work3 -= 2;  [ check for start/end of list  if ((work3 == 0 || work3 == 255)) {    work3 = 1;  }  if (work3 > 132) {    work3 = 132;  }  offsetinst = work3;    [ use a loop to draw the instrument text  cursorX = 0;  set.text.attribute(-1, 0);  :PrintInst    if (work3 == selinst) {      set.text.attribute(WHITE, BLACK);      listindex = cursorX;    } else {      set.text.attribute(BLACK, WHITE);    }    display.v(work1, work2, work3);    ++work1;    ++work3;    ++cursorX;  if (cursorX < 5) {    goto(PrintInst);  }  [ row of selected inst = offsetrow+listindex  selrow = offsetrow;  selrow += listindex;    [position cursor to draw the box frame  erase(oCursorB);  erase(oCursorT);  erase(oCursorL);  erase(oCursorR);  cursorX = 75;  cursorY = currentInst;  cursorY *= 24;  cursorY += 64;  set.cel(oCursorB, 8);  position.v(oCursorB, cursorX, cursorY);  --cursorY;  set.cel(oCursorL, 9);  position.v(oCursorL, cursorX, cursorY);  cursorY -= 40;  set.cel(oCursorT, 8);  position.v(oCursorT, cursorX, cursorY);  cursorX += 81;  cursorY += 40;  set.cel(oCursorR, 9);  position.v(oCursorR, cursorX, cursorY);    draw(oCursorB);  draw(oCursorL);  draw(oCursorT);  draw(oCursorR);    [ add arrows  set.text.attribute(BLACK, LT_GRAY);  work1 = offsetrow;  work2 = 38;  work3 = &m137;  display.v(work1, work2, work3);  work1 += 4;  work3 = &m138;  display.v(work1, work2, work3);    [ show scrollbar background  work1 = 152;  work2 = currentInst;  work2 *= 24;  work2 += 56;  erase(oScrlBkgd);  position.v(oScrlBkgd, work1, work2);  draw(oScrlBkgd);    [ position the scrollbar box  work2 -= 26;  work3 = selinst;  work3 /= 3;  work3 *= 4;  work3 /= 7;  if (work3 > 25) {    work3 = 25;  }  work2 += work3;  erase(oScrlBox);  set.cel(oScrlBox, 0);  position.v(oScrlBox, work1, work2);  draw(oScrlBox);    set.text.attribute(0, -1);    [ begin choosing  dropmode = CHOOSING;}[ if choosing a new instrumentif (dropmode == CHOOSING) {  [ check for direction arrow keypress  if (egoDir != STOPPED) {    [ cursor up    if (egoDir == UP) {      [ it index not at top      if (listindex > 0) {        --listindex;        --selrow;        --selinst;        set(redrawList);      } else {        if (offsetinst > 0) {          btnAction = SC_UP;        }      }    }    [ cursor down    if (egoDir == DOWN) {      [ if index not at bottom      if (listindex < 4) {        ++listindex;        ++selrow;        ++selinst;        set(redrawList);      } else {        if (offsetinst < 132) {          btnAction = SC_DOWN;        }      }    }    [ page up    if (egoDir == UP_RIGHT) {      btnAction = SC_PGUP;    }    [ page down    if (egoDir == DOWN_RIGHT) {      btnAction = SC_PGDN;    }        [ always reset egodir    egoDir = 0;  }    [ escape cancels the selection  if (controller(cMenu)) {    [ dropup to hide the list    dropmode = DROPUP;  }    [ keyboard works regardless of mode for listboxes  [ return to select  if (have.key()) {    if ((lastChar == 13 || lastChar == 10)) {      lastChar = 0;      [ make the selection      work1 = &tmpInst0;      work1 += currentInst;      *work1 = selinst;            [ dropup to hide the list      dropmode = DROPUP;    }  }    [ check for right-click  if (controller(cRightClick)) {    [ dropup to hide the list    dropmode = DROPUP;  }    [ if mouse x value is over the listbox text  if (mouseX > 75 && mouseX < 152) {    [ check for left click    if (controller(cLeftClick)) {      [ convert yvalue to index      work1 = mouseY;      work1 /= 8;      work1 -= offsetrow;      [ is it a valid offset?      if (work1 < 5 && work1 != listindex) {        [ deselect old        cursorY = selrow;        cursorX = 19;        set.text.attribute(-1, 0);        set.text.attribute(BLACK, WHITE);        display.v(cursorY, cursorX, selinst);                [ select new        listindex = work1;        selrow = offsetrow;        selrow += listindex;        selinst = offsetinst;        selinst += listindex;        cursorY = selrow;        cursorX = 19;        set.text.attribute(WHITE, BLACK);        display.v(cursorY, cursorX, selinst);        set.text.attribute(0, -1);      }    }          [ check for dbl click    if (controller(cLeftDblClick)) {      [ make the selection      work1 = &tmpInst0;      work1 += currentInst;      *work1 = selinst;            [ dropup to hide the list      dropmode = DROPUP;    }  }    [ if over the scrollbar  if (mouseX > 151 && mouseX < 156) {    [ check for click OR dblclick    if ((controller(cLeftClick) || controller(cLeftDblClick))) {      [ convert offset row to y value      work1 = offsetrow;      work1 *= 8;      --work1;      [ bottom of up arrow      work2 = work1;      work2 += 8;      [ if on up arrow, scroll up      if (mouseY > work1 && mouseY < work2) {        btnAction = SC_UP;        goto(donemouse);      }            [ adjust compare values to bottom arrow      work1 += 33;      work2 += 33;      [ if on down arrow, scroll down      if (mouseY > work1 && mouseY < work2) {        btnAction = SC_DOWN;        goto(donemouse);      }            [ adjust compare values to top of scroll      [ window and scrollbox position      work1 -= 26;      get.posn(oScrlBox, work3, work2);      work2 += 8;      [ if above scrollbox, page up      if (mouseY > work1 && mouseY < work2) {        btnAction = SC_PGUP;        goto(donemouse);      }            [ adjust compare values to scrollbox position      [ and bottom of scroll window      work2 = work1;      work2 += 27;      get.posn(oScrlBox, work3, work1);      work1 += 8;      [ if below scrollbox, page down      if (mouseY > work1 && mouseY < work2) {        btnAction = SC_PGDN;      }      :donemouse    }  }    [ check for scroll actions  if (btnAction == SC_UP) {    [ if not at top of list    if (offsetinst > 1) {      --offsetinst;      [ selection stays the same, so adjust      [ listindex to match      ++listindex;      ++selrow;      [ unless it's off screen      if (listindex > 4) {        [ reset it to bottom        listindex = 4;        --selinst;        --selrow;      }      [ redraw listbox text      set(redrawList);    }  }  if (btnAction == SC_DOWN) {    [ if not at bottom of list    if (offsetinst < 132) {      ++offsetinst;      [ selection stays the same, so adjust      [ listindex to match      listindex -= 1; [ (can't use decrement, because it doesn't wrap around)      --selrow;      [ unless it's off screen      if (listindex == -1) {        [ reset it to top        listindex = 0;        ++selinst;        ++selrow;      }      [ redraw listbox text      set(redrawList);    }  }  if (btnAction == SC_PGUP) {    [ if not at top of list    if (offsetinst > 1) {      offsetinst -= 5;      if ((offsetinst == 0 || offsetinst > 250)) {        offsetinst = 1;      }      [ reset selection to bottom      listindex = 4;      selinst = offsetinst;      selinst += 4;      selrow = offsetrow;      selrow += 4;      [ redraw listbox text      set(redrawList);    }  }  if (btnAction == SC_PGDN) {    [ if not at bottom of list    if (offsetinst < 132) {      offsetinst += 5;      if (offsetinst > 132) {        offsetinst = 132;      }      [ reset selection to top      listindex = 0;      selinst = offsetinst;      selrow = offsetrow;      [ redraw listbox text      set(redrawList);    }  }    [ always reset button action  btnAction = 0;    }[ redraw textif (redrawList) {  [ use a loop to draw the instrument text  cursorX = 0;  work1 = offsetrow;  work2 = 19;  work3 = offsetinst;    set.text.attribute(-1, 0);  :redrawloop    if (work3 == selinst) {      set.text.attribute(WHITE, BLACK);    } else {      set.text.attribute(BLACK, WHITE);    }    display.v(work1, work2, work3);    ++work1;    ++work3;    ++cursorX;  if (cursorX < 5) {    goto(redrawloop);  }  set.text.attribute(0, -1);    [ position the scrollbar box  work1 = 152;  work2 = currentInst;  work2 *= 24;  work2 += 30; [ scroll arrow is not full eight characters tall  work3 = selinst;  work3 /= 3;  work3 *= 4;  work3 /= 7;  if (work3 > 25) {    work3 = 25;  }  work2 += work3;  erase(oScrlBox);  set.cel(oScrlBox, 0);  position.v(oScrlBox, work1, work2);  draw(oScrlBox);    reset(redrawList);}[ dropupif (dropmode == DROPUP) {  erase(oCursorB);  erase(oCursorL);  erase(oCursorT);  erase(oCursorR);  [ to restore the window, move an object across it  work1 = 72;  work2 = currentInst;  work2 *= 24;  work2 += 24;  erase(oScrlBkgd);  erase(oScrlBox);  set.cel(oScrlBox, 1);  position.v(oScrlBox, work1, work2);  draw(oScrlBox);  work1 = 156;  work2 += 39;  reposition.to.v(oScrlBox, work1, work2);    if (cursormode) {    [ in kb mode, restore selection by forcing update    cursorpos = -1;    btnAction = currentInst;    btnAction += 11;  }    [ done - force an update  set(update);}[ if showing dropbox, don't process other cursor statementsif (dropmode != NODROP) {  [ nothing else to do  return();}[ is cursor in text mode?if (cursormode) {  [ check for direction arrow keypress  if (egoDir != STOPPED) {    [ cursor up    if (egoDir == UP) {      if (cursorpos == CP_1CHAN) {        newpos = CP_MOUSE;      }      if (cursorpos > CP_1CHAN && cursorpos < CP_TESTALL) {        --newpos;      }      if (cursorpos == CP_TESTALL) {        newpos = CP_4CHAN;      }      if (cursorpos > CP_TEST0 && cursorpos < CP_INST0) {        --newpos;      }      if (cursorpos > CP_INST0) {        --newpos;      }      if (cursorpos == CP_VOLUME) {        newpos = CP_INST4;      }    }        [ cursor right    if (egoDir == RIGHT) {      if (cursorpos == CP_MOUSE) {        newpos = CP_KEYB;      }      if (cursorpos > CP_MOUSE && cursorpos < CP_OK) {        newpos += 6;      }      if ((cursorpos == CP_OK || cursorpos == CP_CANCEL)) {        newpos = CP_TESTALL;      }      if (cursorpos == CP_TESTALL) {        newpos = CP_TEST4;      }      if (cursorpos > CP_TESTALL && cursorpos < CP_INST0) {        newpos += 5;      }      if (cursorpos == CP_VOLUME) {        if (attenuation > 0) {          --attenuation;          [ move slider          work1 = 144;          work1 -= attenuation;          work2 = 166;          reposition.to.v(oVolSlider, work1, work2);        }      }    }        [ cursor down    if (egoDir == DOWN) {      if (cursorpos < CP_1CHAN) {        newpos = CP_1CHAN;      }      if (cursorpos > CP_KEYB && cursorpos < CP_CANCEL) {        ++newpos;      }      if (cursorpos > CP_TESTALL && cursorpos < CP_TEST4) {        ++newpos;      }      if (cursorpos > CP_TEST4 && cursorpos < CP_VOLUME) {        ++newpos;      }    }        [ cursor left    if (egoDir == LEFT) {      if (cursorpos == CP_KEYB) {        newpos = CP_MOUSE;      }      if (cursorpos == CP_TESTALL) {        newpos = CP_CANCEL;      }      if (cursorpos == CP_TEST0) {        newpos = CP_KEYB;      }      if (cursorpos == CP_TEST1) {        newpos = CP_1CHAN;      }      if (cursorpos == CP_TEST2) {        newpos = CP_4CHAN;      }      if (cursorpos == CP_TEST4) {        newpos = CP_TESTALL;      }      if (cursorpos > CP_TEST4 && cursorpos != CP_VOLUME) {        newpos -= 5;      }      if (cursorpos == CP_VOLUME) {        if (attenuation < 63) {          ++attenuation;          [ move slider          work1 = 144;          work1 -= attenuation;          work2 = 166;          reposition.to.v(oVolSlider, work1, work2);        }      }    }        [ always reset dir so another keypress can be detected    egoDir = 0;        [ ignore chages that move to disabled buttons    if (newpos > CP_TESTALL && !4channelsound) {      [reset back to current      newpos = cursorpos;    }  }    [ check for new cursor position  if (cursorpos != newpos) {    [ to move cursor, erase it first, otherwise, it will    [ clear any text that is present anywhere between the    [ new position and the old position    erase(oCursorB);    erase(oCursorL);    erase(oCursorT);    erase(oCursorR);    [ update the position    cursorpos = newpos;    [ depending on where cursor is, set the position and size/shape    [ input mode options    if ((cursorpos == CP_MOUSE || cursorpos == CP_KEYB)) {      [ option buttons      set.cel(oCursorB, 0);      set.cel(oCursorT, 0);      set.cel(oCursorL, 6);      set.cel(oCursorR, 6);      cursorY = 65;      if (cursorpos == 1) {        cursorX = 7;      }      if (cursorpos == 2) {        cursorX = 31;      }    }        [ channel count options    if ((cursorpos == CP_1CHAN || cursorpos == CP_4CHAN)) {      set.cel(oCursorB, 1);      set.cel(oCursorT, 1);      set.cel(oCursorL, 6);      set.cel(oCursorR, 6);      [ convert cursorpos into desired y value      cursorX = 7;      cursorY = cursorpos;      cursorY -= 3;      cursorY *= 16;      cursorY += 89;    }          [ OK, Cancel    if ((cursorpos == CP_OK || cursorpos == CP_CANCEL)) {      set.cel(oCursorB, 2);      set.cel(oCursorT, 2);      set.cel(oCursorL, 7);      set.cel(oCursorR, 7);            [ convert cursorpos into desired y value      cursorX = 3;      cursorY = cursorpos;      cursorY -= 5;      cursorY *= 16;      cursorY += 136;    }        [ test all    if (cursorpos == CP_TESTALL) {      set.cel(oCursorB, 3);      set.cel(oCursorT, 3);      set.cel(oCursorL, 7);      set.cel(oCursorR, 7);      cursorX = 35;      cursorY = 144;    }        [ test channel buttons    if (cursorpos > CP_TESTALL && cursorpos < CP_INST0) {      set.cel(oCursorB, 4);      set.cel(oCursorT, 4);      set.cel(oCursorL, 7);      set.cel(oCursorR, 7);            [ convert cursorpos into desired y value      cursorX = 63;      cursorY = cursorpos;      cursorY -= 8;      cursorY *= 24;      cursorY += 48;    }              [ instrument text boxes    if (cursorpos > CP_TEST4 && cursorpos < CP_VOLUME) {      set.cel(oCursorB, 5);      set.cel(oCursorT, 5);      set.cel(oCursorL, 7);      set.cel(oCursorR, 7);            [ convert cursorpos into desired y value      cursorX = 75;      cursorY = cursorpos;      cursorY -= 13;      cursorY *= 24;      cursorY += 48;    }        [ volume slider    if (cursorpos == CP_VOLUME) {     [ don't use the cursor, just change the cel      set.cel(oVolSlider, 1);      [ if something was selected      if (currentInst < 255) {        [ unselect it        btnAction = B_UNSEL;      }    } else {      [ always deselect the volume slider      set.cel(oVolSlider, 0);            [ redraw the cursor      position.v(oCursorB, cursorX, cursorY);      draw(oCursorB);      --cursorY;      position.v(oCursorL, cursorX, cursorY);      draw(oCursorL);      if (cursorpos < CP_OK) {        cursorY -= 10;      } else {        cursorY -= 8;      }      position.v(oCursorT, cursorX, cursorY);      draw(oCursorT);      if (cursorpos < CP_1CHAN) {        cursorX += 17;        cursorY += 10;      } else {        if ((cursorpos == CP_1CHAN || cursorpos == CP_4CHAN)) {          cursorX += 41;          cursorY += 10;        } else {          if ((cursorpos == CP_OK || cursorpos == CP_CANCEL)) {            cursorX += 25;          }          if (cursorpos == CP_TESTALL) {            cursorX += 17;          }          if (cursorpos > CP_TESTALL && cursorpos < CP_INST0) {            cursorX += 5;          }          if (cursorpos > CP_TEST4) {            cursorX += 77;          }          cursorY += 8;        }      }      position.v(oCursorR, cursorX, cursorY);      draw(oCursorR);            [ if cursor moves to an instrument text box      [ automatically select it      if (cursorpos > CP_TEST4) {        [ select the highlighted text box        btnAction = cursorpos;        btnAction -= 2;      } else {        [ if something was selected        if (currentInst < 255) {          [ unselect it          btnAction = B_UNSEL;        }      }    }  }  [ check for selection (space/enter for buttons)  if (have.key()) {    [ space/enter    if ((lastChar == 32 || lastChar == 13 || lastChar == 10)) {      if (cursorpos  == CP_MOUSE) {        [ switch to mouse control        reset(cursormode);        enable.item(mouse);        erase(oMode);        position(oMode, 8, 65);        draw(oMode);        [ erase the cursor objects        erase(oCursorB);        erase(oCursorT);        erase(oCursorL);        erase(oCursorR);      }      if (cursorpos > CP_KEYB && cursorpos < CP_INST0) {        btnAction = cursorpos;        btnAction -= 2;      }      if (cursorpos > CP_TEST4 && cursorpos < CP_VOLUME) {        [ display dropdown list        dropmode = DROPDOWN;      }    }    }} else {  [ check for mouse click  if (controller(cLeftClick)) {    [ over cursor type keyboard option [33, 56 - 37, 63]    if (mouseX > 32 && mouseX < 38 && mouseY > 63 && mouseY < 72) {      [ switch to keyboard cursor      set(cursormode);      disable.item(mouse);      erase(oMode);      position(oMode, 32, 65);      draw(oMode);      [ start cursor on keyboard option button      cursorpos = CP_KEYB;      newpos = CP_KEYB;      set.cel(oCursorB, 0);      position(oCursorB, 31, 65);      draw(oCursorB);      set.cel(oCursorL, 6);      position(oCursorL, 31, 64);      draw(oCursorL);      set.cel(oCursorT, 0);      position(oCursorT, 31, 54);      draw(oCursorT);      set.cel(oCursorR, 6);      position(oCursorR, 48, 64);      draw(oCursorR);    }    [ 1channel [9, 80 - 13, 87]    if (mouseX > 8 && mouseX < 14 && mouseY > 87 && mouseY < 96) {      btnAction = B_1CHAN;    }        [ 4channel [9, 96 - 13, 103]    if (mouseX > 8 && mouseX < 14 && mouseY > 103 && mouseY < 112) {      btnAction = B_4CHAN;    }        [ over OK button [3, 127 - 32, 136]    if (mouseX > 2 && mouseX < 33 && mouseY > 134 && mouseY < 145) {      btnAction = B_OK;    }          [ over Cancel button [3, 143 - 32, 152]    if (mouseX > 2 && mouseX < 33 && mouseY > 150 && mouseY < 161) {      btnAction = B_CANCEL;    }        [ test all [35, 135 - 52, 144]    if (mouseX > 34 && mouseX < 53 && mouseY > 142 && mouseY < 153) {      btnAction = B_TESTALL;    }        [ test 0 [63, 39 - 68, 48]    if (mouseX > 62 && mouseX < 69 && mouseY > 46 && mouseY < 57) {      btnAction = B_TEST0;    }        [ test 1 [63, 63 - 68, 72]    if (mouseX > 62 && mouseX < 69 && mouseY > 70 && mouseY < 81) {      btnAction = B_TEST1;    }        [ test 2 [63, 87 - 68, 96]    if (mouseX > 62 && mouseX < 69 && mouseY > 94 && mouseY < 105) {      btnAction = B_TEST2;    }        [ test 3 [63, 111 - 68, 120]    if (mouseX > 62 && mouseX < 69 && mouseY > 118 && mouseY < 129) {      btnAction = B_TEST3;    }        [ test 4 [63, 135 - 68, 144]    if (mouseX > 62 && mouseX < 69 && mouseY > 142 && mouseY < 153) {      btnAction = B_TEST4;    }        [ instrument 0 [75, 39 - 152, 48]    if (mouseX > 74 && mouseX < 153 && mouseY > 46 && mouseY < 57) {      btnAction = B_INST0;    }        [ instrument 1 [75, 63 - 152, 72]    if (mouseX > 74 && mouseX < 153 && mouseY > 70 && mouseY < 81) {      btnAction = B_INST1;    }        [ instrument 2 [75, 87 - 152, 96]    if (mouseX > 74 && mouseX < 153 && mouseY > 94 && mouseY < 105) {      btnAction = B_INST2;    }        [ instrument 3 [75, 111 - 152, 120]    if (mouseX > 74 && mouseX < 153 && mouseY > 118 && mouseY < 129) {      btnAction = B_INST3;    }        [ instrument 4 [75, 135 - 152, 144]    if (mouseX > 74 && mouseX < 153 && mouseY > 142 && mouseY < 153) {      btnAction = B_INST4;    }    [ over slider zone (y between 154, 167)    if (mouseY > 160 && mouseY < 175) {      get.posn(oVolSlider, cursorX, cursorY);      [ adjust for button width      cursorY = cursorX;      cursorY += 3;      [ is mouse on the slider?      if (mouseX >= cursorX && mouseX < cursorY) {        [ start slide action        set(sliding);        [ calculate offset from object position to mouse position        slideoffset = cursorX;        slideoffset -= mouseX;      }    }  }    [ check for mouse up, to clear slider movement  if (mouseBtn != 1) {    [ cancel slide operation    reset(sliding);  }    if (sliding) {    [ convert mousepos to a slider position    [ (slideX = mouseX + offset)    work1 = mouseX;    work1 += slideoffset;    [ limit to valid range (81-144)    if (work1 > 144) {      work1 = 144;    }    if (work1 < 81) {      work1 = 81;    }    [ reposition the slider    cursorY = 166;    reposition.to.v(oVolSlider, work1, cursorY);    [ convert position to attenuation value    work1 *= -1;    work1 += 144;    [ if it changed, update speed    if (work1 != attenuation) {      attenuation = work1;    }  }    [ check for dblclick (only if in 4channel mode)  if (controller(cLeftDblClick) && 4channelSound) {    [ instrument 0 [75, 39, - 152, 48]    if (mouseX > 74 && mouseX < 153 && mouseY > 46 && mouseY < 57) {      dropmode = DROPDOWN;    }        [ instrument 1 [75, 63 - 152, 72]    if (mouseX > 74 && mouseX < 153 && mouseY > 70 && mouseY < 81) {      dropmode = DROPDOWN;    }        [ instrument 2 [75, 87 - 152, 96]    if (mouseX > 74 && mouseX < 153 && mouseY > 94 && mouseY < 105) {      dropmode = DROPDOWN;    }        [ instrument 3 [75, 111 - 152, 120]    if (mouseX > 74 && mouseX < 153 && mouseY > 118 && mouseY < 129) {      dropmode = DROPDOWN;    }        [ instrument 4 [75, 135 - 152, 144]    if (mouseX > 74 && mouseX < 153 && mouseY > 142 && mouseY < 153) {      dropmode = DROPDOWN;    }  }}[[ check for button action[if (btnAction == 0) {[  return();[}[ check for button actionif (btnAction > 0) {  [ always stop sound when a new button is pushed  stop.sound();    [ 1channel  if (btnAction == B_1CHAN) {    [ if currently 4chan    if (4channelsound) {      [ switch to one channel      reset(4channelsound);      [ move the button      erase(oChannels);      position(oChannels, 8, 89);      draw(oChannels);      [ and update button colors      set(update);    }  }    [ 4channel  if (btnAction == B_4CHAN) {    [ if currently 1chan    if (!4channelsound) {      [ switch to four channel      set(4channelsound);      [ move the button      erase(oChannels);      position(oChannels, 8, 105);      draw(oChannels);      [ and update button colors      set(update);    }  }    [ ok  if (btnAction == B_OK) {    print.at("sound changed ", 5, 6, 31);        [ restore game functions    reset(disableGameFunctions);        [ restore ego movement parameters    egoX = egoPrevX;    egoY = egoPrevY;    egoDir = egoPrevDir;        [ update sound parameters/instruments    instrument0 = tmpInst0;    --instrument0;    cursorX = 0;    if (instrument0 < 131) {      set.key(-2, 223, c63); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument0;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }        instrument1 = tmpInst1;    --instrument1;    ++cursorX;    if (instrument1 < 131) {      set.key(-2, 223, c64); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument1;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }        instrument2 = tmpInst2;    --instrument2;    ++cursorX;    if (instrument2 < 131) {      set.key(-2, 223, c65); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument2;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }        instrument3 = tmpInst3;    --instrument3;    ++cursorX;    if (instrument3 < 131) {      set.key(-2, 223, c66); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument3;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }        instrument4 = tmpInst4;    --instrument4;    ++cursorX;    if (instrument4 < 131) {      set.key(-2, 223, c67); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument4;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }        [ go back to previous room    new.room.v(previousRoom);   }    if (btnAction == B_CANCEL) {    [ restore game functions    reset(disableGameFunctions);        [ restore ego movement parameters    egoX = egoPrevX;    egoY = egoPrevY;    egoDir = egoPrevDir;        [ restore sound parameters/instruments    if (old4Chan) {      set(4channelsound);    } else {      reset(4channelsound);    }    attenuation = tmpAttn;        cursorX = 0;    if (instrument0 < 131) {      set.key(-2, 223, c63); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument0;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }    ++cursorX;    if (instrument1 < 131) {      set.key(-2, 223, c64); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument1;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }    ++cursorX;    if (instrument2 < 131) {      set.key(-2, 223, c65); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument1;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }    ++cursorX;    if (instrument3 < 131) {      set.key(-2, 223, c66); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument3;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }    ++cursorX;    if (instrument4 < 131) {      set.key(-2, 223, c67); [ set.inst(vCHANNEL, vINSTRUMENT);    } else {      [ assign a custom instrument      work1 = instrument4;      work1 += 13;      set.key(-3, 223, c46); [ set.inst.data(vCHANNEL, vMSG);    }        [ and go back to previous room    new.room.v(previousRoom);  }    [ test all sound channels  if (btnAction == B_TESTALL) {    [ if sound is playing, stop it    [ otherwise, start a sound    if (!sndTest) {      [ set all instruments      work1 = tmpInst0;      --work1;      cursorX = 0;      if (work1 < 131) {        set.key(-2, 223, c46); [ set.inst(vCHANNEL, vINSTRUMENT);      } else {        [ assign a custom instrument        work2 = work1;        work2 += 13;        set.key(-3, 223, c47); [ set.inst.data(vCHANNEL, vMSG);      }            work1 = tmpInst1;      --work1;      ++cursorX;      if (work1 < 131) {        set.key(-2, 223, c46); [ set.inst(vCHANNEL, vINSTRUMENT);      } else {        [ assign a custom instrument        work2 = work1;        work2 += 13;        set.key(-3, 223, c47); [ set.inst.data(vCHANNEL, vMSG);      }            work1 = tmpInst2;      --work1;      ++cursorX;      if (work1 < 131) {        set.key(-2, 223, c46); [ set.inst(vCHANNEL, vINSTRUMENT);      } else {        [ assign a custom instrument        work2 = work1;        work2 += 13;        set.key(-3, 223, c47); [ set.inst.data(vCHANNEL, vMSG);      }            sound(m.Theme, sndDone);      [ update button text      set.text.attribute(-1, 0);      set.text.attribute(BLACK, WHITE);      display(18, 9, "Stop");      set.text.attribute(0, -1);      set(sndTest);    }  }    [ if any non-textbox button OR unselecting  if ((btnAction < B_INST0 || btnAction == B_UNSEL)) {    [ deselect instrument    if (currentInst < 255) {      set.text.attribute(-1, 0);      set.text.attribute(BLACK, WHITE);      cursorY = 19;      cursorX = currentInst;      cursorX *= 3;      cursorX += 6;      [ convert selection to instrument value      work1 = currentInst;      work1 += &tmpInst0;      work1 = *work1;      display.v(cursorX, cursorY, work1);      set.text.attribute(0, -1);            [ reset selection      currentInst = -1;    }    [ if forcing,     if (btnAction == B_UNSEL) {      [ reset button value here      btnAction = 0;      return();    }  }    [ instrument buttons only work1 if 4chan is active  if (4channelsound) {    if (btnAction == B_TEST0) {      [ set first channel to inst0      work1 = tmpInst0;      --work1;      cursorX = 0;      if (work1 < 131) {        set.key(-2, 223, c46); [ set.inst(vCHANNEL, vINSTRUMENT);      } else {        [ assign a custom instrument        work2 = work1;        work2 += 13;        set.key(-3, 223, c47); [ set.inst.data(vCHANNEL, vMSG);      }      sound(s.InstTest, sndDone);    }    if (btnAction == B_TEST1) {      [ set first channel to inst1      work1 = tmpInst1;      --work1;      cursorX = 0;      if (work1 < 131) {        set.key(-2, 223, c46); [ set.inst(vCHANNEL, vINSTRUMENT);      } else {        [ assign a custom instrument        work2 = work1;        work2 += 13;        set.key(-3, 223, c47); [ set.inst.data(vCHANNEL, vMSG);      }      sound(s.InstTest, sndDone);    }    if (btnAction == B_TEST2) {      [ set first channel to inst2      work1 = tmpInst2;      --work1;      cursorX = 0;      if (work1 < 131) {        set.key(-2, 223, c46); [ set.inst(vCHANNEL, vINSTRUMENT);      } else {        [ assign a custom instrument        work2 = work1;        work2 += 13;        set.key(-3, 223, c47); [ set.inst.data(vCHANNEL, vMSG);      }      sound(s.InstTest, sndDone);    }    if (btnAction == B_TEST3) {      [ set noise channel to inst3      work1 = tmpInst3;      --work1;      cursorX = 3;      if (work1 < 131) {        set.key(-2, 223, c46); [ set.inst(vCHANNEL, vINSTRUMENT);      } else {        [ assign a custom instrument        work2 = work1;        work2 += 13;        set.key(-3, 223, c47); [ set.inst.data(vCHANNEL, vMSG);      }      sound(s.NoiseTest1, sndDone);    }    if (btnAction == B_TEST4) {      [ set noise channel to inst4      work1 = tmpInst4;      --work1;      cursorX = 4;      if (work1 < 131) {        set.key(-2, 223, c46); [ set.inst(vCHANNEL, vINSTRUMENT);      } else {        [ assign a custom instrument        work2 = work1;        work2 += 13;        set.key(-3, 223, c47); [ set.inst.data(vCHANNEL, vMSG);      }      sound(s.NoiseTest2, sndDone);    }      [ if an istrument text box, selection is shown by inverting colors    if (btnAction > B_TEST4 && btnAction < B_VOLUME) {      [ deselect current instrument      if (currentInst < 255) {        set.text.attribute(-1, 0);        set.text.attribute(BLACK, WHITE);        cursorY = 19;        cursorX = currentInst;        cursorX *= 3;        cursorX += 6;        [ convert selection to instrument value        work1 = currentInst;        work1 += &tmpInst0;        work1 = *work1;        display.v(cursorX, cursorY, work1);        set.text.attribute(0, -1);      }      [ reselect new instrument      currentInst = btnAction;      currentInst -= 11;            set.text.attribute(-1, 0);      set.text.attribute(WHITE, BLACK);      cursorY = 19;      cursorX = currentInst;      cursorX *= 3;      cursorX += 6;      [ convert selection to instrument value      work1 = currentInst;      work1 += &tmpInst0;      work1 = *work1;      display.v(cursorX, cursorY, work1);      set.text.attribute(0, -1);    }  }}[ if sound stopped, reset buttonif (sndDone) {  reset(sndDone);  reset(sndTest);  set.text.attribute(-1, 0);  set.text.attribute(BLACK, WHITE);  display(18, 9, "Test");  set.text.attribute(0, -1);}[ always reset button actionbtnAction = 0;return();[ **************************************[ DECLARED MESSAGES[ **************************************#message 1 "Acoust. Grand Piano"#message 2 "Bright Acous. Piano"#message 3 "Elec. Grand Piano  "#message 4 "Honky-tonk Piano   "#message 5 "Electric Piano 1   "#message 6 "Electric Piano 2   "#message 7 "Harpsichord        "#message 8 "Clavinet           "#message 9 "Celesta            "#message 10 "Glockenspiel       "#message 11 "Music Box          "#message 12 "Vibraphone         "#message 13 "Marimba            "#message 14 "Xylophone          "#message 15 "Tubular Bells      "#message 16 "Dulcimer           "#message 17 "Drawbar Organ      "#message 18 "Percussive Organ   "#message 19 "Rock Organ         "#message 20 "Church Organ       "#message 21 "Reed Organ         "#message 22 "Accordion          "#message 23 "Harmonica          "#message 24 "Tango Accordion    "#message 25 "Ac. Guitar (nylon) "#message 26 "Ac. Guitar (steel) "#message 27 "Elec. Guitar (jazz)"#message 28 "El. Guitar (clean) "#message 29 "El. Guitar (muted) "#message 30 "Overdriven Guitar  "#message 31 "Distortion Guitar  "#message 32 "Guitar harmonics   "#message 33 "Acoustic Bass      "#message 34 "Elec. Bass (finger)"#message 35 "Elec. Bass (pick)  "#message 36 "Fretless Bass      "#message 37 "Slap Bass 1        "#message 38 "Slap Bass 2        "#message 39 "Synth Bass 1       "#message 40 "Synth Bass 2       "#message 41 "Violin             "#message 42 "Viola              "#message 43 "Cello              "#message 44 "Contrabass         "#message 45 "Tremolo Strings    "#message 46 "Pizzicato Strings  "#message 47 "Orchestral Harp    "#message 48 "Timpani            "#message 49 "String Ensemble 1  "#message 50 "String Ensemble 2  "#message 51 "Synth Strings 1    "#message 52 "Synth Strings 2    "#message 53 "Choir Aahs         "#message 54 "Voice Oohs         "#message 55 "Synth Voice        "#message 56 "Orchestra Hit      "#message 57 "Trumpet            "#message 58 "Trombone           "#message 59 "Tuba               "#message 60 "Muted Trumpet      "#message 61 "French Horn        "#message 62 "Brass Section      "#message 63 "Synth Brass 1      "#message 64 "Synth Brass 2      "#message 65 "Soprano Sax        "#message 66 "Alto Sax           "#message 67 "Tenor Sax          "#message 68 "Baritone Sax       "#message 69 "Oboe               "#message 70 "English Horn       "#message 71 "Bassoon            "#message 72 "Clarinet           "#message 73 "Piccolo            "#message 74 "Flute              "#message 75 "Recorder           "#message 76 "Pan Flute          "#message 77 "Blown Bottle       "#message 78 "Shakuhachi         "#message 79 "Whistle            "#message 80 "Ocarina            "#message 81 "Lead 1 (square)    "#message 82 "Lead 2 (sawtooth)  "#message 83 "Lead 3 (calliope)  "#message 84 "Lead 4 (chiff)     "#message 85 "Lead 5 (charang)   "#message 86 "Lead 6 (voice)     "#message 87 "Lead 7 (fifths)    "#message 88 "Lead 8 (bass+lead) "#message 89 "Pad 1 (new age)    "#message 90 "Pad 2 (warm)       "#message 91 "Pad 3 (polysynth)  "#message 92 "Pad 4 (choir)      "#message 93 "Pad 5 (bowed)      "#message 94 "Pad 6 (metallic)   "#message 95 "Pad 7 (halo)       "#message 96 "Pad 8 (sweep)      "#message 97 "FX 1 (rain)        "#message 98 "FX 2 (soundtrack)  "#message 99 "FX 3 (crystal)     "#message 100 "FX 4 (atmosphere)  "#message 101 "FX 5 (brightness)  "#message 102 "FX 6 (goblins)     "#message 103 "FX 7 (echoes)      "#message 104 "FX 8 (sci-fi)      "#message 105 "Sitar              "#message 106 "Banjo              "#message 107 "Shamisen           "#message 108 "Koto               "#message 109 "Kalimba            "#message 110 "Bag pipe           "#message 111 "Fiddle             "#message 112 "Shanai             "#message 113 "Tinkle Bell        "#message 114 "Agogo              "#message 115 "Steel Drums        "#message 116 "Woodblock          "#message 117 "Taiko Drum         "#message 118 "Melodic Tom        "#message 119 "Synth Drum         "#message 120 "Reverse Cymbal     "#message 121 "Guitar Fret Noise  "#message 122 "Breath Noise       "#message 123 "Seashore           "#message 124 "Bird Tweet         "#message 125 "Telephone Ring     "#message 126 "Helicopter         "#message 127 "Applause           "#message 128 "Gunshot            "#message 129 "AGISB Default      "#message 130 "Sierra White Noise "#message 131 "Sierra Tone Noise  "#message 132 "Custom Inst 1      "#message 133 "Custom Inst 2      "#message 134 "Custom Inst 3      "#message 135 "Custom Inst 4      "#message 136 "Custom Inst 5      "#message 137 "\x1E"#message 138 "\x1F"#message 139 "%g53"#message 140 "%g54"#message 141 "%g55"#message 142 "%g56"#message 143 "%g57"#message 144 "0000000000000000000000"#message 145 "0000000000000000000000"#message 146 "0000000000000000000000"#message 147 "0000000000000000000000"#message 148 "0000000000000000000000"