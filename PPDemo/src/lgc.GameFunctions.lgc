[ ********************************************************************
[
[ lgc.GameFunctions: Game-specific functions
[
[ You should use this logic to perform any game specific functions, 
[ such as counting down timers, etc and processing player input 
[ related to the game (such as examining/using inventory items) and 
[ any other things that are required in several rooms that you don't
[ want to duplicate in each room.
[
[ This logic is called from logic 0, on every cycle, unless 
[ disableGameFunctions is set.
[
[ Sierra did not use a separate logic for all this - they just did it
[ all from logic 0. I find it is neater this way, as you can keep your
[ game specific processing separate from other system-related things
[ (although these may require some modification for your game). Also,
[ this makes logic 0 easier to manage.
[
[ ********************************************************************

#define entryDelay v240

#define tmpStr1    s20
#define tmpStr2    s21

[ *************************************************
[ put all non-input functions that are not
[ room-specific here
[ *************************************************


[ saving a cursor
if (saveCursor) {
  reset(saveCursor);
  [ copy s16 into designated cursor msg value
  [ v227 is cursor index value in cp.Mouse logic
  work1 = v227;
  work1 += 40;
  work2 = 16;
  block(SET.MSG, 1, &work1, &work2); [ set.msg(BYVAR, MSGOLD, STRNEW) 
  [ provide feedback
  print.at("Cursor saved.", 14, 19, 15);

print("%v46, %m44");
  
  return();
}

[ restore a cursor
if (restoreCursor) {
  reset(restoreCursor);
  [ set s12 to default of designated cursor
  work1 = &s12;
  work2 = v227;
  work2 += 46;
  block(SET.STRING.V, &work1, &work2, 0); [ set.string.v(vSTR, vMSG);
  [ now copy it to the current cursor msgnum
  work2 -= 6;
  block(SET.MSG, 1, &work2, &work1); [ set.msg(BYVAR, MSGOLD, STRNEW)
  [ force update by resetting the cursor index
  v227 = -1;
  [ provide feedback
  print.at("Cursor restored.", 14, 19, 17);
  return();
}

[ check for instrument change
if (saveCustomInst) {
  reset(saveCustomInst);
  work1 = 22;
  block(STR.LEFT, &s12, &s12, &work1); [ str.left(sINPUT, sRESULT, vLEN);
  work1 = v221; [ selinst in cp.Instrument
  work1 += 52; [convert to msg offset
  work2 = &s12; [ use string 12
  block(SET.MSG, 1, &work1, &work2); [set.msg(BYVAR, MSGNUM, STRNEW);
  return();
}

[ convert game time into 20 minute timer intervals
if (elapsedMinutes != oldMinutes) {
  oldMinutes = elapsedMinutes;
  ++patientClock;
  if (patientClock == 20) {
    patientClock = 0;
  }
  [ update patient locations 
  if (currentRoom != rm.Lobby) {
    if (patientClock > 0 && patientClock < 6) {
      patient2Loc = LOC_LOBBY;
    } else {
      if (patientClock > 5 && patientClock < 10) {
        patient2Loc = LOC_EXAM;
      } else {
        patient2Loc = LOC_GONE;
      }
    }
    if (patientClock > 4 && patientClock < 12) {
      patient3Loc = LOC_LOBBY;
    } else {
      if (patientClock > 11 && patientClock < 15) {
        patient3Loc = LOC_EXAM;
      } else {
        patient3Loc = LOC_GONE;
      }
    }
    if (patientClock > 10 && patientClock < 16) {
      patient4Loc = LOC_LOBBY;
    } else {
      if (patientClock > 15 && patientClock < 19) {
        patient4Loc = LOC_EXAM;
      } else {
        patient4Loc = LOC_GONE;
      }
    }
  }
}

[ check for cancel click2move
if (controller(cRightClick)) {
  if (click2move) {
    egoDir = 0;
    set.dir(ego, egoDir); 
  }
}

[ **************************************
[ PROCESS PLAYER INPUT
[ **************************************

[ check for cussing
work1 = 0;
:loop1
  get.string(tmpStr1, m1, -1, 0, 0);
  work2 = 70; ['F'
  [ pass starting pos via vRESULT
  work3 = work1;
  block(INSTR, &tmpStr1, &work2, &work3); [ instr(sINPUT, vCHAR, vRESULT);
  if (work3 == 255) {
    work2 = 102; [ 'f'
    work3 = work1;
    block(INSTR, &tmpStr1, &work2, &work3); [ instr(sINPUT, vCHAR, vRESULT);
  }
  [ save result in work1
  work1 = work3;
  [ if letter 'f' is found
  if (work1 < 255) {
    [ check for match against 'fuck' by getting 
    [ 'f' plus next three letters
    work2 = 4;
    block(STR.MID, &tmpStr1, &work1, &work2); [ str.mid(sINPUT, vPOS, vLEN);
    tmpStr2 = "fuck";
    [ advance position so loop can look for next 'f'
    ++work1;
    if (compare.strings(tmpStr1, tmpStr2)) {
      print("Watch your language, you son of a bitch!");
      get.string(tmpStr1, m1, -1, 0, 0);
      block(STR.LEFT, &tmpStr1, &tmpStr1, &work1); [ str.left(sINPUT, sRESULT, vLEN);
      tmpStr2 = "***";
      block(STR.CONCAT, &tmpStr1, &tmpStr2, 0);
      set.string(SET.INPUT, "%s20");
    } else {
      [ check rest of line
      goto(loop1);
    }
  }

[ if player hasn't provided input or if match already found, no need
[ to do said tests
if ((!haveInput || haveMatch)) {
  goto(done);
}
  
[ put all generic said tests (those that apply in all rooms) here

[ if player says any dirty words
[ realtime check for a few words
  

if ((said("bad word", "rol") || 
     said("anyword", "bad word", "rol") || 
     said("anyword", "anyword", "bad word", "rol") || 
     said("anyword", "anyword", "anyword", "bad word", "rol") || 
     said("anyword", "anyword", "anyword", "anyword", "bad word", "rol") || 
     said("anyword", "anyword", "anyword", "anyword", "anyword", "bad word", "rol"))) {
  ++badWordCount;
  if (badWordCount == 1) {
    [ first warning
    print("I am going to tell on you!");
  }
  if (badWordCount == 2) {
    [second warning
    print("Don't say anymore words like that!");
  }
  if (badWordCount == 3) {
    [ no more warnings
    print("Don't say I didn't warn you.");
    quit(1);
  }
}

if (said("read", "magazine")) {
  call(lgc.ReadMagazine);
}
[[ look cube
[if (said("look", "cube")) 
[  {
[  if (has("strange colored cube")) 
[    {
[    show.obj(vw.Inv.TestItem);
[    }
[  else 
[    {
[    print("You don't have it.");
[    }
[  }
[  
[[ drop cube
[if (said("drop", "cube"))
[  {
[  print("The cube is too interesting; you decide to keep it.");
[  }
[  
[[ anything cube
[if ((said("anyword", "cube") || 
[    said("cube", "rol") ||
[    said("anyword", "anyword", "cube")))
[  {
[  print("There's no need to do anything with the cube.");
[  }
  

[ look anything
if ((said("look", "anyword") || said("look", "anyword", "rol"))) {
  print("What? Where?");
}


[ get anything
if ((said("get", "anyword") || said("get", "anyword", "rol"))) {
  print("You can't get that here!");
}

[ use anything
if ((said("use", "anyword") || said("use", "anyword", "rol"))) {
  print("What do you want me to do with it?");
}

:done
return();

[ **************************************
[ MESSAGES
[ **************************************
#message 1 "I am going to tell on you!"
#message 2 "Don't say anymore words like that!"
#message 3 "Don't say I didn't warn you."
#message 4 "You don't have it."
#message 5 "What? Where?"
#message 6 "You can't get that here!"
#message 7 "What do you want me to do with it?"
#message 8 "You have explored a new room in this world! Good job!"
#message 9 "The cube is too interesting; you decide to keep it."
#message 10 "There's no need to do anything with the cube."

[ active cursors
#message 40 "0000FF3FFF1FFF0FFF07FF03FF01FF007F003F001F00FF01FF00FF307FF87FF8FFFC"
            "00000040006000700078007C007E007F807F007C006C00460006000300030000"
[ walk
#message 41 "040FFFF1FFE07FC07FC0FFE0FFF1FFE17FC03FC07FE0FFE1FFC1FF80FF087F183FBC"
            "0000000E001D001F000E0004000C0016801B0006000C001C0036006200430000"
[ look
#message 42 "0709FFFFFFFFFFFFFFFEEFF62DB40BD0024001808001018003C00FF03FFCFFFFFFFF"
            "000000000000000000000000C003F00F7C3E3E7C7C3EF00FC003000000000000"
[ talk
#message 43 "050E1FF807E0018000000000000000000000008001E007FC0FFE3FFC7FF8FFF9FFFF"
            "0000E007F81FFE7FFE7FFE7FFE7FFE7FFE1FF803F000C0008001000200000000"
[ use 
#message 44 "0803FFFFFFFF1FFE07F801F000F000F000F00090000000000000018001C003E007F0"
            "000000000000C000D806DA06DA06DA06DA06FA6FFE7FFE7FFC3FFC1FF80F0000"
[ wait 
#message 45 "0707018003C003C007E007E00FF01FF83FFC3FFC1FF80FF007E007E003C003C00180"
            "0000F81FF81F5005A00A40058002000180004003E007700E1008081000000000"
[ default cursors
#message 46 "0000FF3FFF1FFF0FFF07FF03FF01FF007F003F001F00FF01FF00FF307FF87FF8FFFC"
            "00000040006000700078007C007E007F807F007C006C00460006000300030000"
[ walk
#message 47 "040FFFF1FFE07FC07FC0FFE0FFF1FFE17FC03FC07FE0FFE1FFC1FF80FF087F183FBC"
            "0000000E001D001F000E0004000C0016801B0006000C001C0036006200430000"
[ look
#message 48 "0709FFFFFFFFFFFFFFFEEFF62DB40BD0024001808001018003C00FF03FFCFFFFFFFF"
            "000000000000000000000000C003F00F7C3E3E7C7C3EF00FC003000000000000"
[ talk
#message 49 "050E1FF807E0018000000000000000000000008001E007FC0FFE3FFC7FF8FFF9FFFF"
            "0000E007F81FFE7FFE7FFE7FFE7FFE7FFE1FF803F000C0008001000200000000"
[ use 
#message 50 "0803FFFFFFFF1FFE07F801F000F000F000F00090000000000000018001C003E007F0"
            "000000000000C000D806DA06DA06DA06DA06FA6FFE7FFE7FFC3FFC1FF80F0000"
[ wait
#message 51 "0707018003C003C007E007E00FF01FF83FFC3FFC1FF80FF007E007E003C003C00180"
            "0000F81FF81F5005A00A40058002000180004003E007700E1008081000000000"
            
#message 52 "%s16"
#message 53 "22215909FFFF030F020000"
#message 54 "22215909FFFF030F020000"
#message 55 "22215909FFFF030F020000"
#message 56 "22215909FFFF030F020000"
#message 57 "22215909FFFF030F020000"