[ [ lgc.TestPart2[ [ **************************************[ LOCAL DEFINES[ **************************************#define strN              s3#define strNo             s4#define strAnswer         s5#define tmpTimer1         v220#define tmpTimer2         v221#define msgTimer          v222#define stepcounter       v223#define tmpRow            v224#define tmpCol            v225#define tmpMsg            v226#define maxCPS            v227[ run tests 21-34if (newtest) { clear.lines(23, 24, BLACK);}++stepcounter;[ TEST21: fix for 'get.string' cursor reset bugif (teststep == stepcounter) {  [  --SKIP THIS ONE--  ++teststep;[  if (subteststep == 0) {[    if (newtest) {[      display(24, 0, "%v63: GET.STRING BUG TEST");[      reset(newtest);[      print("Cursor and get.string bugfix. Setting input colors to "[            "blue on yellow. Check that no 'ghost' cursor shows up "[            "when switching between text/graphics mode, or when "[            "showing inventory screen.");[      [ for this test, don't bother pushing color;[      [ it gets overridden by custom status logic [      [ set.text.attribute(-1, 0);[      set.text.attribute(BLUE, YELLOW);[    }[    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {[      [ check results[      get.string(strAnswer, "No ghosts? Fix worked? ", 22, 0, 3);[      goto(nextsubtest);[    }[  }[  if (subteststep == 1) {[    if (newtest) {[      reset(newtest);[      print("Disabling input. Watch for ghost cursor.");[      prevent.input();[      tmpTimer1 = 30;[    }[    if (tmpTimer1 > 0) {[      --tmpTimer1;[      display(24, 20, "%v220 ");[      if (tmpTimer1 == 0) {[        [ don't bother popping color; the custom status[        [ line logic has pushed the blue/yellow colors;[        [ instead, just set white on black[        set.text.attribute(WHITE, BLACK);[        accept.input();[        [ check results[        get.string(strAnswer, "No ghosts? Fix worked? ", 22, 0, 3);[        display(24, 0, "CUSTOM STATUS LINE TEST");[        goto(nexttest);[      }[    }[  }[  return();}[ TEST22: 60 Hz mode++stepcounter;if (teststep == stepcounter) {  if (subteststep == 0) {    if (newtest) {      display(24, 0, "%v63: TURBO TEST");      reset(newtest);      tmpTimer1 = 0;      tmpTimer2 = elapsedSeconds;      maxCPS = 0;      print("Testing normal speed. There should be 20 ticks per "            "second.");      animationInterval = 1;    }    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {      [ check results      get.string(strAnswer, "Twenty ticks per second? ", 22, 0, 3);      goto(nextsubtest);    }  }  [ subtest 1: testing turbo mode  if (subteststep == 1) {    if (newtest) {      print("Enabling turbo mode. There should be 60 ticks per "            "second.");      reset(newtest);      work1 = 1;      cycle.time(o255, work1);      work1 = 3;      step.time(ego, work1);      dblClickDelay = 12;    }    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {      [ check results      get.string(strAnswer, "Sixty ticks per second? ", 22, 0, 3);      goto(nexttest);    }  }    [ run the timer  ++tmpTimer1;  display(4, 32, "%v220/%v227  ");  if (tmpTimer2 != elapsedSeconds) {[    if (tmpTimer1 > maxCPS) {      maxCPS = tmpTimer1;[    }    tmpTimer2 = elapsedSeconds;    tmpTimer1 = 0;  }  return();}[ TEST23: delay counter and countdown timer++stepcounter;if (teststep == stepcounter) {  if (newtest && subteststep == 0) {    display(24, 0, "%v63: TIMER TEST");    reset(newtest);    print("Testing a delay counter. The next message should appear "          "in ~5 seconds.");        work1 = 250;    work2 = 20;    :delay      cycle.time(o254, work1);      --work2;    if (work2) {      goto(delay);    }    print("Test complete.");    [ check results    get.string(strAnswer, "Five second delay? ", 22, 0, 3);    goto(nextsubtest);  }  if (subteststep == 1) {    if (newtest) {      display(24, 0, "%v63: TIMER TEST");      reset(newtest);      print("Starting a 10 second countdown timer. Enter "            "'stop' to pause the timer, 'start' to resume it, "            "or 'reset' to begin over at 8 seconds.");      tmpTimer1 = 0;      tmpTimer2 = 10;      block(START.TIMER, &tmpTimer1, &tmpTimer2, &f220);    }    display(4, 32, "%v221 ");    if (said("stop")) {      block(TOGGLE.TIMER, 0, 0, 0);    }    if (said("start")) {      block(TOGGLE.TIMER, 1, 0, 0);    }    if (said("reset")) {      tmpTimer2 = 8;    }    [ check for timer actually counting down; compare to elapsed seconds?        if (f220) {      print("Countdown successful. Moving on to next test.");      ++teststep;      subteststep = 0;      set(newtest);    } else {      [ if timer is at zero, and no flag      if (tmpTimer2 == 0) {        goto(fail);      }    }  }  return();}[ TEST24: retrieve current input line or previously entered[         input line text into a string++stepcounter;if (teststep == stepcounter) {  if (newtest) {    display(24, 0, "%v63: GET LINE TEST");    reset(newtest);    print("Testing inputline copy functions. The current "          "input line will be copied to row 23 and the "          "previous input line will be shown on row 24");  }  clear.lines(23, 24, BLACK);  get.string(s6, m0, -1, 0, 0);  display(23, 1, "%s6");  get.string(s6, m0, -2, 0, 0);  display(24, 1, "%s6");    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {    [ check results    get.string(strAnswer, "Input line copied correctly? ", 22, 0, 3);    goto(nexttest);  }  return();}[ TEST25: trace function enhancements (40/80 modes)++stepcounter;if (teststep == stepcounter) {  if (newtest) {    display(24, 0, "%v63: TRACE FUNCTION TEST");    reset(newtest);        [ early version(2.089/2.272) use different message set    if (IntVersion > VERSION_2272) {      load.logics(lgc.TraceInfo);      trace.info(lgc.TraceInfo, 3, 15);    } else {      load.logics(lgc.traceinfo160);      trace.info(lgc.traceinfo160, 3, 15);    }    [ set left/width    trace.info(0, 3, 34); [ l >3, l+w <77    set(enableTrace);    print("Testing trace mode. Try the new intractive features "          "(CTRL+V/F/O; ego direction keys/INS for input.");    trace.on();    trace.on();  }  if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {    [ check results    get.string(strAnswer, "Trace function working? ", 22, 0, 3);    goto(nexttest);  }  return();}[ TEST26: full control of trace window placement ++stepcounter;if (teststep == stepcounter) {  if (newtest) {    display(24, 0, "%v63: TRACE WINDOW TEST");    reset(newtest);    print("Switching to 80 column mode, and adjusting trace window "          "location.");    [ switch to 80col    set(graphics80);    configure.screen(-1, 0, 1);    trace.info(0, 44, 32); [ l >3, l+w <77    [ early version(2.089/2.272) use different message set    if (IntVersion > VERSION_2272) {      load.logics(lgc.TraceInfo);      trace.info(lgc.TraceInfo, 3, 9);    } else {      load.logics(lgc.traceinfo160);      trace.info(lgc.traceinfo160, 3, 9);    }    trace.on();  }  if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {    [ check results    get.string(strAnswer, "Trace window OK? ", 22, 0, 3);    [ back to 40    reset(graphics80);    configure.screen(-1, 0, 0);    goto(nexttest);  }  return();}[ TEST27: string manipulation functions++stepcounter;if (teststep == stepcounter) {  if (newtest) {    display(24, 0, "%v63: STRING FUNCTIONS TEST");    reset(newtest);    [ use binary string compare    set.string(s254, m2);    print("Testing string manipulation functions. First test is "          "extra-long string comparison check.");    s6 = "0123456789012345678901234567890123456789abcdef";    s7 = "0123456789012345678901234567890123456789ghijkl";    if (!compare.strings(s6, s7)) {      print("Long string match check failed.");      goto(fail);    }                print("Long string check passed. Checking STR.LEN function");    [strLen:    block(-4, sSrc, vRESULT, ANY);    s6 = "abc";    block(STR.LEN, &s6, &work1, 0);    if (work1 != 3) {      print("STR.LEN check1 failed.");      goto(fail);    }    s6 = "";    block(STR.LEN, &s6, &work1, 0);    if (work1 != 0) {      print("STR.LEN check2 failed.");      goto(fail);    }    print("STR.LEN check passed. Checking STR.COPY");        [strCopy:   block(-5, sSrc, sTgt, ANY);    s6 = "a string";    s7 = "";    block(STR.COPY, &s6, &s7, 0);    if (!compare.strings(s6, s7)) {      print("STR.COPY check failed.");      goto(fail);    }    print("STR.COPY check passed. Checking STR.CONCAT");        [strConcat: block(-6, sSrc, sAdd, ANY);    s6 = "This is ";    s8 = "This is a string";    block(STR.CONCAT, &s6, &s7, 0);    if (!compare.strings(s6, s8)) {      print("STR.CONCAT check1 failed.");      goto(fail);    }    s7 = "";    block(STR.CONCAT, &s6, &s7, 0);    if (!compare.strings(s6, s8)) {      print("STR.CONCAT check2 failed.");      goto(fail);    }    s6 = "string";    s8 = "stringstring";    block(STR.CONCAT, &s6, &s6, 0);    if (!compare.strings(s6, s8)) {      print("STR.CONCAT check3 failed.");      goto(fail);    }    print("STR.CONCAT check passed. Checking STR.LEFT");        [sLeft:     block(-7, sSrc, sTgt, vLEN);    work1 = 3;    s6 = "test string";    s7 = "tes";    block(STR.LEFT, &s6, &s6, &work1);    if (!compare.strings(s6, s7)) {      print("STR.LEFT check1 failed.");      goto(fail);    }    work1 = 0;    s6 = "test string";    s7 = "";    block(STR.LEFT, &s6, &s6, &work1);    if (!compare.strings(s6, s7)) {      print("STR.LEFT check2 failed.");      goto(fail);    }    work1 = 25;    s6 = "test string";    s7 = "test string";    block(STR.LEFT, &s6, &s6, &work1);    if (!compare.strings(s6, s7)) {      print("STR.LEFT check3 failed.");      goto(fail);    }    print("STR.LEFT check passed. Checking STR.RIGHT");        [sRight:    block(-8, sSrc, sTgt, vLEN);    work1 = 3;    s6 = "test string";    s7 = "ing";    block(STR.RIGHT, &s6, &s6, &work1);    if (!compare.strings(s6, s7)) {      print("STR.RIGHT check1 failed.");      goto(fail);    }    work1 = 0;    s6 = "test string";    s7 = "";    block(STR.RIGHT, &s6, &s6, &work1);    if (!compare.strings(s6, s7)) {      print("STR.RIGHT check2 failed.");      goto(fail);    }    work1 = 25;    s6 = "test string";    s7 = "test string";    block(STR.RIGHT, &s6, &s6, &work1);    if (!compare.strings(s6, s7)) {      print("STR.RIGHT check3 failed.");      goto(fail);    }    print("STR.RIGHT check passed. Checking STR.MID");        [sMid:      block(-9, sSrc, vPOS, vLEN); overwrites source, different from rest    work1 = 0;    work2 = 4;    s6 = "test string";    s7 = "test";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check1 failed.");      goto(fail);    }    work1 = 0;    work2 = 11;    s6 = "test string";    s7 = "test string";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check2 failed.");      goto(fail);    }    work1 = 0;    work2 = 12;    s6 = "test string";    s7 = "test string";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check3 failed.");      goto(fail);    }    work1 = 0;    work2 = 20;    s6 = "test string";    s7 = "test string";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check4 failed.");      goto(fail);    }    work1 = 3;    work2 = 5;    s6 = "test string";    s7 = "t str";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check5 failed.");      goto(fail);    }    work1 = 3;    work2 = 8;    s6 = "test string";    s7 = "t string";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check6 failed.");      goto(fail);    }    work1 = 3;    work2 = 9;    s6 = "test string";    s7 = "t string";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check7 failed.");      goto(fail);    }    work1 = 3;    work2 = 20;    s6 = "test string";    s7 = "t string";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check8 failed.");      goto(fail);    }    work1 = 10;    work2 = 5;    s6 = "test string";    s7 = "g";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check9 failed.");      goto(fail);    }    work1 = 11;    work2 = 5;    s6 = "test string";    s7 = "";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check10 failed.");      goto(fail);    }    work1 = 12;    work2 = 5;    s6 = "test string";    s7 = "";    block(STR.MID, &s6, &work1, &work2);    if (!compare.strings(s6, s7)) {      print("STR.MID check11 failed.");      goto(fail);    }    print("STR.MID check passed. Checking STR.TRIM");        [strTrim:   block(-10, sSrc, sTgt, MODE); mode 0=fulltrim, 1=ltrim, 2=rtrim, 3=agiparsetrim    work1 = 3;    s6 = " a,.!string {[(ABC)]}     ";    s7 = "";    s8 = "a string ABC";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check1 failed.");      goto(fail);    }    work1 = 2;    s6 = " a,.!string {[(ABC)]}     ";    s7 = "";    s8 = " a,.!string {[(ABC)]}";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check2 failed.");      goto(fail);    }    work1 = 1;    s6 = " a,.!string {[(ABC)]}     ";    s7 = "";    s8 = "a,.!string {[(ABC)]}     ";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check3 failed.");      goto(fail);    }    work1 = 0;    s6 = " a,.!string {[(ABC)]}     ";    s7 = "";    s8 = "a,.!string {[(ABC)]}";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check4 failed.");      goto(fail);    }    work1 = 3;    s6 = "      ";    s7 = "x";    s8 = "";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check5 failed.");      goto(fail);    }    work1 = 2;    s6 = "      ";    s7 = "x";    s8 = "";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check6 failed.");      goto(fail);    }    work1 = 1;    s6 = "      ";    s7 = "x";    s8 = "";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check7 failed.");      goto(fail);    }    work1 = 0;    s6 = "      ";    s7 = "x";    s8 = "";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check8 failed.");      goto(fail);    }    work1 = 3;    s6 = "";    s7 = "x";    s8 = "";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check9 failed.");      goto(fail);    }    work1 = 2;    s6 = "";    s7 = "x";    s8 = "";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check10 failed.");      goto(fail);    }    work1 = 1;    s6 = "";    s7 = "x";    s8 = "";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check11 failed.");      goto(fail);    }    work1 = 0;    s6 = "";    s7 = "x";    s8 = "";    block(STR.TRIM, &s6, &s7, &work1);    if (!compare.strings(s7, s8)) {      print("STR.TRIM check12 failed.");      goto(fail);    }    print("STR.TRIM check passed. Checking INSTR");        [sInstr:    block(-11, sSrc, vCHAR, vPOS);    work1 = 110;    work2 = 0;    s6 = "one banana";    block(INSTR, &s6, &work1, &work2);    if (work2 != 1) {      print("INSTR check1 failed.");      goto(fail);    }    work1 = 110;    ++work2;    block(INSTR, &s6, &work1, &work2);    if (work2 != 6) {      print("INSTR check2 failed.");      goto(fail);    }    work1 = 110;    ++work2;    block(INSTR, &s6, &work1, &work2);    if (work2 != 8) {      print("INSTR check3 failed.");      goto(fail);    }    work1 = 110;    ++work2;    block(INSTR, &s6, &work1, &work2);    if (work2 != -1) {      print("INSTR check4 failed.");      goto(fail);    }    work1 = 110;    work2 = 50;    block(INSTR, &s6, &work1, &work2);    if (work2 != -1) {      print("INSTR check5 failed.");      goto(fail);    }    work1 = 0;    work2 = 0;    block(INSTR, &s6, &work1, &work2);    if (work2 != -1) {      print("INSTR check6 failed.");      goto(fail);    }    print("INSTR check passed. Checking STR.FORMAT");        [ strFormat block(-12, sINPUT, sRESULT, ANY**)    s6 = "test";    work1 = 1;    #message 1 "msg"    work2 = 4;    s7 = "%s6%v46%m1%o47";    s8 = "test1msgdagger";    block(STR.FORMAT, &s7, &s9, 0);    if (!compare.strings(s9, s8)) {      print("STR.FORMAT check1 failed.");      goto(fail);    }    print("STR.FORMAT check passed. Checking STR2BYTE");        [ str2byte block(-13, sINPUT, vRESULT, ANY**)    s6 = "123";    work1 = 0;    block(STR2BYTE, &s6, &work1, 0);    if (work1 != 123) {      print("STR2BYTE check1 failed.");      goto(fail);    }    print("STR2BYTE check passed. Checking HEX2BYTE");        [ hex2byte block(-14, sINPUT, vRESULT, ANY**)    s6 = "FF";    work1 = 0;    block(HEX2BYTE, &s6, &work1, 0);    if (work1 != 255) {      print("HEX2BYTE check1 failed.");      goto(fail);    }    s6 = "ff";    work1 = 0;    block(HEX2BYTE, &s6, &work1, 0);    if (work1 != 255) {      print("HEX2BYTE check2 failed.");      goto(fail);    }    print("HEX2BYTE check passed. Checking BYTE2HEX");        [ byte2hex block(-15, sRESULT, vINPUT, ANY**)    s6 = "";    s7 = "ff";    work1 = 255;    block(BYTE2HEX, &s6, &work1, 0);    if (!compare.strings(s6, s7)) {      print("BYTE2HEX check1 failed.");      goto(fail);    }    print("BYTE2HEX check passed. Checking STR.UPPER");        [ strUpper block(-16, sINPUT, sRESULT, ANY**)    s6 = "abc123DEF";    s7 = "";    s8 = "ABC123DEF";    block(STR.UPPER, &s6, &s7, 0);    if (!compare.strings(s7, s8)) {      print("STR.UPPER check1 failed.");      goto(fail);    }    print("STR.UPPER check passed. Checking STR.LOWER");        [ strLower    s6 = "abc123DEF";    s7 = "";    s8 = "abc123def";    block(STR.LOWER, &s6, &s7, 0);    if (!compare.strings(s7, s8)) {      print("STR.LOWER check1 failed.");      goto(fail);    }    print("STR.LOWER check passed. Checking BYTE2CHAR");        [ byte2char block(-18, sRESULT, vCHAR, ANY**)    s6 = "";    s7 = "A";    work1 = 65;    block(BYTE2CHAR, &s6, &work1, 0);    if (!compare.strings(s6, s7)) {      print("BYTE2CHAR check1 failed.");      goto(fail);    }    print("BYTE2CHAR check passed. Checking set.string.v");        [ set.string.v block(-19, sINPUT, vMSG, ANY**)    s6 = "";    s7 = "test string";    work1 = 3;    work2 = 6;    block(SET.STRING.V, &work2, &work1, 0);    if (!compare.strings(s6, s7)) {      print("set.string.v check1 failed.");      goto(fail);    }    print("set.string.v check passed. Checking parse patch.");        [ parse patch test    if (IntVersion > VERSION_2272 && IntVersion != VERSION_3002149) {      s23 = "use a test  fast";      parse(s23);      if (!said("use", "test", "fast")) {        print("parse patch check failed.");        goto(fail);      }    }    print("Parse patch check passed. ALL STRING CHECKS PASSED.");    print("Moving on to next test.");    ++teststep;    set(newtest);    subteststep = 0;  }  return();}[ TEST28: palette functions including fading the screen[         in/out++stepcounter;if (teststep == stepcounter) {  if (newtest && subteststep == 0) {    display(24, 0, "%v63: PALETTE AND FADE TEST");    reset(newtest);        print("Testing palette change; changing to red theme.");    block(SET.PALETTE, 0, &m37, 0);    [ check results    get.string(strAnswer, "Palette change is correct? ", 22, 0, 3);    goto(nextsubtest);  }  if (subteststep == 1) {    display(24, 0, "%v63: PALETTE AND FADE TEST");    print("Next test will fade to black, then fade in with same red palette.");    block(FADE.OUT, 0, 20, BLACK);    [ one second pause    work1 = 250;    cycle.time(o254, work1);    cycle.time(o254, work1);    cycle.time(o254, work1);    cycle.time(o254, work1);    work1 = 20;    work2 = 0;    block(FADE.IN, 1, &work1, &work2);    [ check results    get.string(strAnswer, "Fade to/from black worked? ", 22, 0, 3);    goto(nextsubtest);  }  if (subteststep == 2) {    display(24, 0, "%v63: PALETTE AND FADE TEST");    print("Next test will fade to white, and then fade in back to normal palette.");    work1 = 20;    work2 = 1;    block(FADE.OUT, 1, &work1, &work2);    [block(FADE.OUT, 0, 20, 1);    [one second pause    work1 = 250;    cycle.time(o254, work1);    cycle.time(o254, work1);    cycle.time(o254, work1);    cycle.time(o254, work1);    [ set palette, but don't update    work1 = &m38;    work2 = 1;    block(SET.PALETTE, 1, &work1, &work2);    [ fade in    block(FADE.IN, 0, 20, 1);    [ check results    get.string(strAnswer, "Fade to/from white worked? ", 22, 0, 3);    goto(nexttest);  }  return();}[ TEST29: setmessage function++stepcounter;if (teststep == stepcounter) {  if (newtest && subteststep == 0) {    display(24, 0, "%v63: SET MESSAGE TEST");    reset(newtest);    print("Testing message change function. First test will change a local message.");    print("Original message: \n  '%m9'");    s6 = m10;    block(SET.MSG, 0, &m9, &s6);    print("Changed message: \n  '%m9'");    [ check results    get.string(strAnswer, "Did message change? ", 22, 0, 3);    goto(nextsubtest);  }  if (subteststep == 1) {    if (IntVersion <= VERSION_2272) {      [ skip menu checks      ++teststep;      subteststep = 0;      set(newtest);      return();    }    if (newtest) {      display(24, 0, "%v63: SET MESSAGE TEST");      reset(newtest);      print("Next test will change menu and menu items. The "            "Speed menu will be hidden, the Special menu will "            "be changed to TEST, the Pause menu will be "            "changed to Halt, and the Joystick item will "            "be hidden.");      print("Press CTRL+Z or enter 'continue' when you are ready to move on.");      set(changeMenu);    }    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {      [ check results      get.string(strAnswer, "did menu changes work? ", 22, 0, 3);      set(restoreMenu);      goto(nextsubtest);    }  }  if (subteststep == 2) {    if (newtest) {      reset(newtest);      display(24, 0, "%v63: SET MESSAGE TEST");      print("Check the menu, make sure it's back to normal. "            "Press CTRL+Z or enter 'continue' when you are "            "ready to move on.");    }    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {      [ check results      get.string(strAnswer, "Is menu back to normal? ", 22, 0, 3);      goto(nexttest);    }  }  return();}[ TEST30: setitem function++stepcounter;if (teststep == stepcounter) {  if (subteststep == 0) {    if (newtest) {      display(24, 0, "%v63: SET ITEM TEST");      reset(newtest);      work2 = 1;      print("Testing inventory item change function. Open your "            "inventory. You should see a %o47. When ready to "            "run the test, press CTRL+Z or enter 'continue'.");            get(i1);    }    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {      subteststep = 1;      set(newtest);    }  }  if (subteststep == 1) {    if (newtest) {      display(24, 0, "%v63: SET ITEM TEST");      reset(newtest);      s6 = "Rubik's cube";      block(SET.ITEM, 0, &i1, &s6);      print("You should now have a %o47. After confirming, press "            "CTRL+Z or enter 'continue'.");      return();    }    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {      [ check results      get.string(strAnswer, "Do you have a Rubik's cube? ", 22, 0, 3);      goto(nextsubtest);    }  }  if (subteststep == 2) {    if (newtest) {      reset(newtest);      display(24, 0, "%v63: SET ITEM TEST");      print("Changing the item back. After confirming, press "            "CTRL+Z or enter 'continue'.");      s6 = "strange colored cube";      work2 = &i1;      work3 = &s6;      block(SET.ITEM, 1, &work2, &work3);    }    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {      [ check results      get.string(strAnswer, "Is it back to a strange cube? ", 22, 0, 3);      goto(nexttest);    }  }  return();}[ TEST31: itemcount function++stepcounter;if (teststep == stepcounter) {  if (newtest) {    display(24, 0, "%v63: ITEM COUNT TEST");    reset(newtest);    print("Checking ITEM.COUNT function.");    [ reset items to correct locations for the test    if (!has(i1)) {      get(i1);    }    if (has(i2)) {      work1 = 3;      put(i2, work1);    }    if (has(i3)) {      work1 = 3;      put(i3, work1);    }    if (has(i4)) {      work1 = 0;      put(i4, work1);    }    if (has(i5)) {      work1 = 0;      put(i5, work1);    }    if (has(i6)) {      work1 = 0;      put(i6, work1);    }    if (has(i7)) {      work1 = 0;      put(i7, work1);    }    if (has(i8)) {      work1 = 0;      put(i8, work1);    }    [ total items (including i0('?')    work2 = 0;    work3 = 0;    block(ITEM.COUNT, &work2, &work3, 0);    if (work3 != 9) {      print("ITEM.COUNT check1 failed.");      goto(fail);    }    [ items in inventory    work2 = 255;    work3 = 0;    block(ITEM.COUNT, &work2, &work3, 0);    if (work3 != 1) {      print("ITEM.COUNT check2 failed.");      goto(fail);    }    work2 = 3;    work3 = 0;    block(ITEM.COUNT, &work2, &work3, 0);    if (work3 != 2) {      print("ITEM.COUNT check3 failed. %v48");      goto(fail);    }    print("ITEM.COUNT checks passed. Moving to next test.");    ++teststep;    set(newtest);    subteststep = 0;  }  return();}[ TEST32: picture draw function++stepcounter;if (teststep == stepcounter) {  if (subteststep == 0) {    if (newtest) {      display(24, 0, "%v63: PIC DRAW TEST");      reset(newtest);      print("This test will add draw commands to current picture. "            "A red block with priority 14 will be drawn in center of "            "the room. Confirm the block shows up correctly. Move "            "ego around to check that it is right priority and blocks "            "movement vertically. Press CTRL+Z or enter 'continue' "            "when ready to move on.");      s6 = "04"; [ when formatting, make sure char following the                 [ formatcode number is NONNUMERIC or wrong value                 [ gets used!      s7 = "F0%s6F20EF43D879B60873DF83E88F1F200F53D9B60FF";      block(PIC.DRAW, &s7, 1, 0);    }    if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {      [ check results      get.string(strAnswer, "Was block drawn correctly? ", 22, 0, 3);      goto(nextsubtest);    }  }  if (subteststep == 1) {     if (newtest) {      display(24, 0, "%v63: PIC DRAW TEST");      print("Next test will blank the entire screen to blue. ");      block(PIC.DRAW, 0, -1, 65);      get.string(strAnswer, "Did screen go blue? ", 22, 0, 3);      [ restore original picture      load.pic(currentRoom);      draw.pic(currentRoom);      discard.pic(currentRoom);      [ check results      goto(nexttest);    }  }  return();}[ TEST33: get the priority and visual colors for any[         coordinate++stepcounter;if (teststep == stepcounter) {  if (newtest) {    display(24, 0, "%v63: PIXEL COLOR TEST");    reset(newtest);    print("Click anywhere on the screen. The pixel color and priority "          "value for that coordinate will be displayed below. When "          "you are ready to continue, press CTRL+Z or enter 'continue'");  }  if (controller(cLeftClick)) {    if (mouseY > 7 && mouseY < 176) {      work1 = 0;      block(GET.PIXEL, &mouseX, &mouseY, &work1);      [ lower nibble is visual      work2 = work1;      if (IntVersion > VERSION_2272) {        work2 *= 16;        work2 /= 16;        [ upper nibble is priority        work1 /= 16;      } else {        block(MUL, 0, &work2, 16);        block(DIV, 0, &work2, 16);        [ upper nibble is priority        block(DIV, 0, &work1, 16);      }      [ convert to msg number      work1 += 40;      work2 += 40;      work3 = 5;      block(SET.STRING.V, &work3, &work2, 0);      work3 = 6;      block(SET.STRING.V, &work3, &work1, 0);      tmpMsg = 39;      tmpRow = 23;      tmpCol = 0;      display.v(tmpRow, tmpCol, tmpMsg);    } else {      display(23, 0, "NOT ON PICTURE                  ");    }  }  if ((said("continue") || controller(cNext) || controller(cRightDblClick))) {    [ check results    clear.lines(23, 24, BLACK);    get.string(strAnswer, "Pixel colors shown correctly? ", 22, 0, 3);    goto(nexttest);  }  return();}[ TEST34: bitwise math functions (or, and, xor, bitshift)++stepcounter;if (teststep == stepcounter) {  if (newtest) {    display(24, 0, "%v63: BIT MATH TEST");    reset(newtest);    print("Testing bit math functions. First test is "          "BIT.AND function.");        [ BIT.AND    work1 = 255;    block(BIT.AND, 0, &work1, 3);    if (work1 != 3) {      print("BIT.AND check1 failed.");      goto(fail);    }    work1 = 255;    work2 = 6;    block(BIT.AND, 1, &work1, &work2);    if (work1 != 6) {      print("BIT.AND check2 failed.");      goto(fail);    }    print("BIT.AND check passed. Checking BIT.OR");        [ BIT.OR    work1 = 129;    block(BIT.OR, 0, &work1, 3);    if (work1 != 131) {      print("BIT.OR check1 failed.");      goto(fail);    }    work1 = 129;    work2 = 3;    block(BIT.OR, 1, &work1, &work2);    if (work1 != 131) {      print("BIT.OR check2 failed.");      goto(fail);    }    print("BIT.OR check passed. Checking BIT.XOR");        [ BIT.XOR    work1 = 129;    block(BIT.XOR, 0, &work1, 9);    if (work1 != 136) {      print("BIT.XOR check1 failed.");      goto(fail);    }    work1 = 129;    work2 = 9;    block(BIT.XOR, 1, &work1, &work2);    if (work1 != 136) {      print("BIT.XOR check2 failed.");      goto(fail);    }    print("BIT.XOR check passed. Checking BIT.NOT");        [ BIT.NOT    work1 = 170;    block(BIT.NOT, 0, &work1, 0);    if (work1 != 85) {      print("BIT.NOT check1 failed.");      goto(fail);    }    print("BIT.NOT check passed. Checking BIT.SHL");        [ BIT.SHL    work1 = 255;    block(BIT.SHL, 0, &work1, 4);    if (work1 != 240) {      print("BIT.SHL check1 failed.");      goto(fail);    }    work1 = 255;    work2 = 4;    block(BIT.SHL, 1, &work1, &work2);    if (work1 != 240) {      print("BIT.SHL check2 failed.");      goto(fail);    }    print("BIT.SHL check passed. Checking BIT.SHR");        [ BIT.SHR    work1 = 255;    block(BIT.SHR, 0, &work1, 4);    if (work1 != 15) {      print("BIT.SHR check1 failed.");      goto(fail);    }    work1 = 255;    work2 = 4;    block(BIT.SHR, 1, &work1, &work2);    if (work1 != 15) {      print("BIT.SHR check2 failed.");      goto(fail);    }    print("BIT.SHR check passed. ALL BIT.MATH CHECKS PASSED.");    print("Moving on to next test.");    ++teststep;    set(newtest);    subteststep = 0;  }  return();}return();:nexttestclear.lines(22, 22, BLACK);accept.input();[display(24, 0, "%s5, %s3, %s4");if (!compare.strings(strAnswer, strN) && !compare.strings(strAnswer, strNo)) {  [ if successful, move to next test  print("Moving on to next test.");  show.pic();  ++teststep;  set(newtest);  subteststep = 0;} else {  :fail  set.text.attribute(LT_RED, BLACK);  display(24, 0, "TEST %v63 FAILED                   ");  print("TEST %v63 FAILED. INVESTIGATE.");  quit(1);}return();:nextsubtestclear.lines(22, 22, BLACK);accept.input();[display(24, 0, "%s3, %s4, %s5");if (!compare.strings(strAnswer, strN) && !compare.strings(strAnswer, strNo)) {  [ if successful, move to next test  print("Moving on to next test.");  show.pic();  ++subteststep;[print("new subteststep: %v64  %v63");  set(newtest);} else {  set.text.attribute(LT_RED, BLACK);  display(24, 0, "TEST %v63 FAILED                   ");  print("TEST %v63 FAILED. INVESTIGATE.");  quit(1);}return();[*****[ messages         [  declared messages go here[*****#message 3 "test string"#message  9 "TEST MESSAGE"#message 10 "Changed msg!"#message 37 "0000000800001000001900002200002A00003300003B0000"            "3F04043F0C0C3F15153F1D1D3F26263F2E2E3F37373F3F3F"#message 38 "00000000002A002A00002A2A2A00002A002A2A15002A2A2A"            "15151515153F003F15153F3F3F15153F153F3F3F153F3F3F"#message 39 "VIS: %s5  PRI: %s6"#message 40 "BLACK     "#message 41 "BLUE      "#message 42 "GREEN     "#message 43 "CYAN      "#message 44 "RED       "#message 45 "MAGENTA   "#message 46 "BROWN     "#message 47 "LT GRAY   "#message 48 "DK GRAY   "#message 49 "LT BLUE   "#message 50 "LT GREEN  "#message 51 "LT CYAN   "#message 52 "LT RED    "#message 53 "LT MAGENTA"#message 54 "YELLOW    "#message 55 "WHITE     "